# syntax عمومی

---

**فرمت**

    شناسه‌ها، اعداد و token ها با space ها، tab ها، carriage return ها و "form feed" ها جدا می‌شن. سری‌هایی از یک یا چند تا از این جداکننده‌ها white space نامیده می‌شن.

**semicolon های اختیاری**

    semicolon ها (برای پایان دادن به یک statement) اختیاری هستن اگر در انتهای یک خط قرار بگیرن. semicolon ها برای جدا کردن چندین statement در یک خط ضروری هستن. یک expression هنوز ممکنه روی چندین خط wrap بشه، ولی عملگرهای postfix (++, -- و char) باید در همون خط operand شون ظاهر بشن.

**کامنت‌ها**

    متن بین token های /* و */ (هر دو token ممکنه در همون خط یا در خطوط مختلف باشن) و متن پشت // (تا انتهای خط) یک کامنت برنامه‌نویسی هست. parser یک کامنت رو به عنوان white space در نظر می‌گیره. کامنت‌ها نمی‌تونن nested باشن.

    کامنتی که با "/** " (دو ستاره و white-space پشت ستاره دوم) شروع می‌شه و با "*/" تمام می‌شه یک کامنت مستندسازی هست. کامنتی که با "/// " (سه slash و white-space پشت slash سوم) شروع می‌شه هم یک کامنت مستندسازی هست. parser ممکنه کامنت‌های مستندسازی رو به روش خاصی در نظر بگیره؛ مثلاً، ممکنه ازشون راهنمای آنلاین بسازه.

**شناسه‌ها**

    نام‌های متغیرها، توابع و ثابت‌ها. شناسه‌ها از کاراکترهای a. . . z, A. . . Z, 0. . . 9, _ یا @ تشکیل شدن؛ اولین کاراکتر نمی‌تونه رقم باشه. کاراکترهای @ و _ خودشون شناسه‌های معتبر نیستن،

    یعنی "_Up" یک شناسه معتبر هست، ولی "_" نیست.

    pawn case sensitive هست.

    یک parser ممکنه یک شناسه رو بعد از حداکثر طول truncate کنه. تعداد کاراکترهای مهم implementation defined هست، ولی باید حداقل 16 کاراکتر باشه.

**کلمات رزرو شده (کلیدواژه‌ها)**

| Statement ها | عملگرها | Directive ها | دیگر     |
| ------------ | -------- | ------------ | -------- |
| assert       | char     | #assert      | const    |
| break        | defined  | #define      | enum     |
| case         | sizeof   | #else        | forward  |
| continue     | state    | #elseif      | native   |
| default      | tagof    | #emit        | new      |
| do           |          | #endif       | operator |
| else         |          | #endinput    | public   |
| exit         |          | #endscript   | static   |
| for          |          | #error       | stock    |
| goto         |          | #file        |          |
| if           |          | #if          |          |
| return       |          | #include     |          |
| sleep        |          | #line        |          |
| state        |          | #pragma      |          |
| switch       |          | #section     |          |
| while        |          | #tryinclude  |          |
|              |          | #undef       |          |

علاوه بر کلمات رزرو شده، pawn چندین ثابت از پیش تعریف شده هم داره، نمی‌تونی از نام‌های نمادی ثابت‌های از پیش تعریف شده برای نام‌های متغیر یا تابع استفاده کنی.

**ثابت‌ها (literal ها)**

**ثابت‌های عددی Integer**
. **باینری**
0b و بعدش سری‌ای از رقم‌های 0 و 1.
. **دهدهی**
سری‌ای از رقم‌های بین 0 و 9.
. **هگزادسیمال**
0x و بعدش سری‌ای از رقم‌های بین 0 و 9 و حروف a تا f.

    در همه radix های عدد، یک underscore ممکنه برای جدا کردن گروه‌هایی از رقم‌های (هگزا-)دسیمال استفاده بشه. کاراکترهای underscore بین رقم‌ها نادیده گرفته می‌شن.

**ثابت‌های عدد Rational**

یک عدد rational عددی با بخش کسری هست. یک عدد rational با یک یا چند رقم شروع می‌شه، شامل یک نقطه اعشار هست و حداقل یک رقم بعد از نقطه اعشار داره. مثلاً، "12.0" و "0.75" اعداد rational معتبر هستن. به صورت اختیاری، یک exponent ممکنه به عدد rational اضافه بشه؛ نمادگذاری exponent حرف "e" (کوچک) و بعدش یک ثابت عددی integer signed هست. مثلاً، "3.12e4" یک عدد rational معتبر با exponent هست.

پشتیبانی برای اعداد rational باید با directive #pragma rational فعال بشه. بسته به گزینه‌هایی که با این directive تنظیم شدن، عدد rational یک عدد floating point یا fixed point رو نمایش می‌ده.

**ثابت‌های کاراکتر**

یک کاراکتر ASCII محصور در single quote ها یک ثابت کاراکتر هست (مثلاً: 'a', '7', '\$'). ثابت‌های کاراکتر به عنوان ثابت‌های عددی در نظر گرفته می‌شن.

| Escape sequence ها |     |                                            |
| ------------------ | --- | ------------------------------------------ |
| '\a'               |     | هشدار صوتی (beep)                       |
| '\b'               |     | Backspace                                  |
| '\e'               |     | Escape                                     |
| '\f'               |     | Formfeed                                   |
| '\n'               |     | Newline                                    |
| '\r'               |     | Carriage Return                            |
| '\t'               |     | Horizontal tab                             |
| '\v'               |     | Vertical tab                               |
| '\\'               | \   | کاراکتر escape                       |
| '\''               | '   | single quote                               |
| '\"'               | "   | double quote                               |
| '\%                | %   | علامت درصد                               |
| '\ddd;'            |     | کد کاراکتر با کد دهدهی "ddd"     |
| '\xhhh;'           |     | کد کاراکتر با کد هگزادسیمال "hhh" |

semicolon بعد از کدهای ddd; و xhhh; اختیاری هست. هدفش دادن یک نماد پایان صریح به escape sequence وقتی در یک ثابت string استفاده می‌شه هست.

backslash ("\") کاراکتر "escape" پیش‌فرض هست. می‌تونی یک کاراکتر escape متفاوت با directive #pragma ctrlchar تنظیم کنی (صفحه 120).

**ثابت‌های String**

ثابت‌های string به عنوان آرایه‌هایی با اندازه‌ای که برای نگه داشتن همه کاراکترها به علاوه یک '\0' پایانی کافی باشه در نظر گرفته می‌شن. هر string در موقعیت منحصر به فردی در حافظه ذخیره می‌شه؛ حذف string های تکراری وجود نداره.

یک unpacked string سری‌ای از صفر یا چند کاراکتر ASCII محصور در double quote ها هست. هر element آرایه شامل یک کاراکتر هست. یک unpacked string می‌تونه کاراکترهایی در یک character set چندبایتی، مثل Unicode یا UCS-4، نگه داره.

**ثابت unpacked string:**

    "the quick brown fox..."

یک packed string literal از syntax یک unpacked string پیروی می‌کنه، ولی یک "!" قبل از اولین double quote می‌آد.

**ثابت packed string:**

    !"...packed and sacked the lazy dog"

در مورد یک packed string، parser تا جایی که جا می‌شه کاراکترها رو در یک cell pack می‌کنه. یک کاراکتر به عنوان یک واحد منفرد قابل آدرس‌دهی نیست، به جاش هر element آرایه شامل چندین کاراکتر هست. اولین کاراکتر در یک "pack" بالاترین bit های element آرایه رو اشغال می‌کنه. در محیط‌هایی که memory word ها رو با high byte در آدرس پایین‌تر ذخیره می‌کنن (Big Endian، یا فرمت Motorola)، کاراکترهای منفرد در cell های حافظه به همون ترتیبی که در string هستن ذخیره می‌شن. یک packed string با یک کاراکتر صفر تمام می‌شه و string به مضربی از cell ها pad می‌شه (با بایت‌های صفر).

یک packed string فقط می‌تونه کاراکترهایی از یک character set تک‌بایتی، مثل ascii یا یکی از مجموعه‌های ascii توسعه یافته از استاندارد ISO 8859، نگه داره.

escape sequence ها ممکنه داخل string ها استفاده بشن. بخش ثابت‌های کاراکتر (صفحه 99) رو برای لیست escape sequence ها ببین.

یک syntax جایگزین برای "plain string ها" وجود داره. در یک plain string، هر کاراکتر همونطور که هست گرفته می‌شه و escape sequence ها تشخیص داده نمی‌شن. plain string ها برای ذخیره نام‌های فایل/منبع راحت هستن، مخصوصاً در مواردی که کاراکتر escape به عنوان کاراکتر خاص توسط سیستم‌عامل یا host application هم استفاده می‌شه.

syntax برای یک plain string کاراکتر escape و بعدش string در double quote ها هست. backslash ("\") کاراکتر "escape" پیش‌فرض هست.

نمی‌تونی escape sequence ها در یک plain string وارد کنی: همه کاراکترها به صورت literal گرفته می‌شن.

**ثابت plain string:**

    \"C:\all my work\novel.rtf"

در مثال بالا، وقوع "\a" و "\n" نشان‌دهنده escape sequence ها نیستن، بلکه جفت کاراکترهای literal "\" و "a"، و "\" و "n" هستن.

یک packed plain string هم "!" و هم کاراکتر escape رو قبل از double quote باز prefix می‌کنه. هر دو string زیر

**packed plain string ها هستن:**

    !\"C:\all my work\novel.rtf"

    \!"C:\all my work\novel.rtf"

**ثابت‌های آرایه**

سری‌ای از ثابت‌های عددی بین brace ها یک ثابت آرایه هست. ثابت‌های آرایه می‌تونن برای initialize کردن متغیرهای آرایه (صفحه 65 رو ببین) و به عنوان آرگومنت‌های تابع پاس داده بشن (صفحه 71 رو ببین).

**ثابت‌های نمادین**

یک source file ثابت‌های نمادین رو با دستورات const و enum اعلان می‌کنه. کلیدواژه const یک ثابت منفرد اعلان می‌کنه و enum لیستی از ثابت‌های —معمولاً— متوالی که همون نام tag رو به اشتراک می‌ذارن تعریف می‌کنه.

**const** _identifier = constant expression_

یک ثابت نمادین با مقدار constant expression سمت راست عملگر assignment ایجاد می‌کنه. ثابت می‌تونه در هر جایی که یک عدد literal معتبر هست استفاده بشه (مثلاً: در expression ها، در اعلان‌های آرایه و در directive هایی مثل "#if" و "#assert").

**enum** _name (increment) \{ constant list \}_

دستور enum سری‌ای از ثابت‌ها با مقادیر افزایشی ایجاد می‌کنه. لیست ثابت سری‌ای از شناسه‌های جدا شده با کاما هست. مگر اینکه نقض بشه، اولین ثابت یک لیست enum مقدار 0 داره و هر ثابت بعدی مقدار predecessor اش به علاوه 1 داره.

هم مقدار یک ثابت و هم مقدار increment می‌تونن با اضافه کردن مقدار به شناسه ثابت تنظیم بشن. برای تنظیم یک مقدار، از

name = value

در لیست ثابت استفاده کن. برای تنظیم increment، از:

name [ increment ]

استفاده کن. مقدار increment بعد از هر اعلان نماد ثابت در لیست ثابت به 1 reset می‌شه.

اگر هم increment و هم مقدار باید برای یک ثابت تنظیم بشه، increment (نمادگذاری "[. . . ]") باید قبل از مقدار (نمادگذاری "=") بیاد.

نمادها در لیست ثابت ممکنه یک tag صریح داشته باشن، که باید قبل از نام نماد بیاد.

token name ای که بعد از کلیدواژه enum می‌آد اختیاری هست. اگر شامل بشه، و اگر نام‌های نماد tag صریح نداشته باشن، این نام به عنوان نام tag برای هر نماد در لیست ثابت استفاده می‌شه. علاوه بر این، دستور enum یک ثابت اضافی با نام برای نام ثابت و نام tag ایجاد می‌کنه. مقدار آخرین ثابت مقدار آخرین نماد در لیست ثابت به علاوه مقدار increment اون آخرین ثابت هست.

token increment ای که بعد از token نام اختیاری می‌آد هم اختیاری هست. اگر شامل بشه، یک قانون post-increment متفاوت مشخص می‌کنه. به صورت پیش‌فرض، یک enum مقدار هر ثابت متوالی رو با 1 increment می‌کنه، ولی می‌تونی قانون متفاوتی با syntax "(operator constant)" مشخص کنی، که operator باید +=، *= یا `<<=` باشه. عملگر += یک increment جمعی ایجاد می‌کنه، *= و `<<=` یک increment ضربی ایجاد می‌کنن. ثابت ممکنه یک مقدار literal یا یک ثابت نمادین باشه. قانون increment باید در پرانتز محصور بشه. اگر هیچ قانون increment ای مشخص نشده، پرانتزها هم ممکنه حذف بشن.

یک ثابت نمادین که به صورت محلی تعریف شده، در سراسر بلوک معتبر هست. یک ثابت نمادین محلی نمی‌تونه همون نام یک متغیر (محلی یا global)، یک تابع، یا ثابت دیگه (محلی یا global) رو داشته باشه.

**ثابت‌های از پیش تعریف شده**

| نام      | توضیحات                                                                                                                                                                                                                                                      |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| cellbits | اندازه یک cell به bit؛ معمولاً 32.                                                                                                                                                                                                                          |
| cellmax  | بزرگ‌ترین مقدار مثبت معتبری که یک cell می‌تونه نگه داره؛ معمولاً 2147483647.                                                                                                                                                                       |
| cellmin  | بزرگ‌ترین مقدار منفی معتبری که یک cell می‌تونه نگه داره؛ معمولاً -2147483648.                                                                                                                                                                      |
| charbits | اندازه یک کاراکتر packed به bit؛ معمولاً 8.                                                                                                                                                                                                               |
| charmax  | بزرگ‌ترین مقدار کاراکتر packed معتبر؛ معمولاً یک کاراکتر packed 8-bit هست و حداکثر مقدار معتبر بنابراین 255 هست.                                                                                                                                           |
| charmin  | کوچک‌ترین مقدار کاراکتر معتبر، برای هم مقادیر packed و هم unpacked؛ فعلاً روی صفر (0) تنظیم شده.                                                                                                                                                              |
| debug    | سطح debug: 2 اگر parser اطلاعات نمادین کامل به علاوه بررسی bounds زمان اجرا ایجاد کنه، 1 اگر parser فقط بررسی زمان اجرا تولید کنه (assertion ها و بررسی bounds آرایه)، و 0 (صفر) اگر همه پشتیبانی debug و بررسی زمان اجرا خاموش شده باشه. |
| false    | 0 (این ثابت به عنوان bool: tagged شده)                                                                                                                                                                                                                             |
| \_\_Pawn | شماره نسخه pawn compiler در Binary Coded Decimals (BCD) —یعنی، برای نسخه 2.8.1 ثابت "0x281" هست.                                                                                                                                                      |
| true     | 1 (این ثابت به عنوان bool: tagged شده)                                                                                                                                                                                                                             |
| ucharmax | بزرگ‌ترین مقدار کاراکتر unpacked، مقدارش به اندازه یک cell بستگی داره. یک استفاده معمول برای این ثابت بررسی اینکه آیا یک string packed هست یا unpacked، صفحه 137 رو ببین.                                                                              |

**نام‌های Tag**

یک tag از یک شناسه و بعدش یک colon تشکیل شده. ممکنه هیچ white space بین شناسه و colon نباشه.

**نام‌های tag از پیش تعریف شده**

| نام    | توضیحات                                                                                 |
| ------ | --------------------------------------------------------------------------------------- |
| bool:  | برای flag های "true/false". ثابت‌های از پیش تعریف شده true و false این tag رو دارن.              |
| Fixed: | اعداد rational معمولاً این tag رو دارن وقتی پشتیبانی fixed point فعال باشه (صفحه 121).    |
| Float: | اعداد rational معمولاً این tag رو دارن وقتی پشتیبانی floating point فعال باشه (صفحه 121). |

---

`semicolon های اختیاری: 122`

`ثابت‌های از پیش تعریف شده: 102`

`اعداد Rational "اعداد real" یا "اعداد floating point" هم نامیده می‌شن`

`#pragma rational: 121`

`syntax های برای packed literal string ها و unpacked literal string ها می‌تونن با directive "#pragma pack" عوض بشن، صفحه 121 رو ببین`

`مثال‌ها: 21, 26`

`مثال‌ها: 9, 21`

`شناسه‌ها: 97`

`صفحه 68 رو برای مثال‌هایی از اعلان‌های ثابت "enum" ببین`

`صفحه 26 رو برای مثالی از یک قانون increment سفارشی ببین`

`شناسه‌ها: 97`

---

[برگشت به فهرست](00-Contents.md)
