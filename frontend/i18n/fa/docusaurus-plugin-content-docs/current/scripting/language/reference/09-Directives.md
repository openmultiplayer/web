# دستورالعمل‌ها

---

همه دستورالعمل‌ها باید در ابتدای یک خط ظاهر شوند (ممکن است قبل از آنها فضای خالی وجود داشته باشد،
اما نه هیچ کاراکتر دیگری). همه دستورالعمل‌ها با کاراکتر # شروع می‌شوند و
دستورالعمل کامل نمی‌تواند بیش از یک خط را در بر بگیرد.

**#assert** _عبارت ثابت_

    اگر عبارت ثابت ارائه شده به صفر ارزیابی شود، یک خطای زمان کامپایل صادر می‌کند.
    دستورالعمل #assert برای محافظت در برابر ساختارهای تعریف شده پیاده‌سازی که یک برنامه ممکن است به آنها وابسته باشد،
    مانند اندازه cell به بیت، یا تعداد کاراکترهای packed در هر cell، بسیار مفید است.

**#define** _الگو جایگزین_

    یک ماکروی جایگزینی متن تعریف می‌کند. الگو با تمام خطوط
    خوانده شده از فایل‌های منبع مطابقت داده می‌شود؛ بخش‌هایی که مطابقت دارند با
    متن‌های جایگزین جایگزین می‌شوند. الگو و متن‌های جایگزین ممکن است
    شامل پارامترهایی باشند که با "%0" تا "%9" نشان داده می‌شوند. برای جزئیات
    و مثال‌هایی در مورد جایگزینی متن، صفحه 93 را ببینید.

**#emit** _کد عملیاتی، پارامترها_

    دستورالعمل #emit به عنوان یک اسمبلر درون خطی عمل می‌کند. در حال حاضر فقط
    برای آزمایش ماشین انتزاعی استفاده می‌شود.

**#endinput و #endscript**

    فایل فعلی را می‌بندد و در نتیجه
    تمام متن زیر دستورالعمل #endinput را نادیده می‌گیرد.
    دستورالعمل #endscript مترادف #endinput است.

**#error**

    پیام: یک "خطای کاربر" را با پیام مشخص شده نشان می‌دهد. خطاهای کاربر
    خطاهای مهلک هستند و هدف مشابهی با دستورالعمل #assert دارند.

**#file** _نام_

    نام فایل فعلی را تنظیم می‌کند. این دستورالعمل به طور ضمنی
    توسط پیش‌پردازنده متن استفاده می‌شود؛ معمولاً نیازی به تنظیم صریح نام فایل
    نیست.

**#if** _عبارت ثابت_، #elseif، #else، #endif

    بخش‌هایی از یک برنامه ممکن است بسته به شرایط خاصی تجزیه شوند یا نادیده گرفته شوند.
    تجزیه‌کننده pawn (کامپایلر یا مفسر) فقط برای بخش‌هایی که شرط برای آنها درست است کد تولید می‌کند.

    دستورالعمل #if باید با یک عبارت ثابت دنبال شود. برای بررسی
    اینکه آیا یک متغیر یا ثابت تعریف شده است، از عملگر defined استفاده کنید.

    صفر یا چند دستورالعمل #elseif ممکن است پس از دستورالعمل اولیه #if بیایند.
    این بلوک‌ها اگر هر یک از بلوک‌های #if یا #elseif قبلی
    تجزیه شده باشند (یعنی نادیده گرفته نشده باشند)، رد می‌شوند. مانند دستورالعمل #if، یک عبارت ثابت
    باید پس از عبارت #elseif بیاید.

    #else باعث می‌شود تجزیه‌کننده تمام خطوط تا #endif را رد کند اگر
    دستورالعمل #if قبلی یا هر یک از دستورالعمل‌های #elseif قبلی "درست" بودند، و
    این خطوط را تجزیه می‌کند اگر تمام بلوک‌های قبلی رد شده باشند. دستورالعمل #else
    ممکن است حذف شود؛ اگر وجود داشته باشد، فقط می‌تواند یک #else
    مرتبط با هر #if وجود داشته باشد.

    دستورالعمل #endif یک بخش برنامه را که به صورت شرطی
    تجزیه می‌شود، پایان می‌دهد. دستورالعمل‌های شرطی می‌توانند تو در تو باشند و هر دستورالعمل #if
    باید با یک دستورالعمل #endif پایان یابد.

**#include** _نام فایل_ یا _< نام فایل >_

    محتویات فایل مشخص شده را در موقعیت فعلی در
    فایل فعلی وارد می‌کند. یک نام فایل بین براکت‌های زاویه‌ای ("\<" و ">")
    به یک فایل سیستمی اشاره دارد؛ تجزیه‌کننده pawn (کامپایلر یا مفسر)
    چنین فایل‌هایی را فقط در یک لیست از پیش تعیین شده از دایرکتوری‌ها جستجو می‌کند و نه در
    دایرکتوری "فعلی". نام‌های فایل که بدون نقل قول هستند یا در
    نقل قول‌های دوتایی ظاهر می‌شوند، فایل‌های include معمولی هستند، که برای آنها یک تجزیه‌کننده pawn
    ابتدا در دایرکتوری فعلی جستجو می‌کند.

    تجزیه‌کننده pawn ابتدا تلاش می‌کند فایل را با نام مشخص شده
    باز کند. اگر این کار شکست بخورد، سعی می‌کند پسوندهای ".inc"، ".p"
    و ".pawn" را به نام فایل اضافه کند (به همان ترتیب). پسوند پیشنهادی پیش‌فرض
    برای فایل‌های include، ".inc" است.

    هنگامی که فایل با موفقیت باز می‌شود، دستورالعمل #include یک
    ثابت با نام "_inc_" به علاوه نام پایه فایل
    (نام فایل بدون مسیر و پسوند) و مقدار 1 تعریف می‌کند. اگر
    ثابت از قبل وجود داشته باشد، دستورالعمل #include باز کردن و
    شامل کردن فایل را رد می‌کند، و بنابراین از شمول دوباره جلوگیری می‌کند. برای اجبار به
    شمول دوباره، تعریف ثابت را با دستورالعمل #undef
    قبل از شمول دوم فایل حذف کنید.

**#line** _شماره_

    شماره خط فعلی (در فایل فعلی). این دستورالعمل به طور ضمنی
    توسط پیش‌پردازنده متن استفاده می‌شود؛ معمولاً نیازی به تنظیم صریح
    شماره خط نیست.

**#pragma** _اطلاعات اضافی_

    یک "pragma" یک قلاب برای یک تجزیه‌کننده برای مشخص کردن تنظیمات اضافی، مانند
    سطوح هشدار یا قابلیت‌های اضافی است. #pragma های رایج عبارتند از:

    **#pragma** align

        اعلان بعدی را با آفست تنظیم شده با گزینه تراز کامپایلر
        تراز می‌کند. برخی توابع (بومی) ممکن است با پارامترهایی که
        با ارجاع منتقل می‌شوند، زمانی که این‌ها در مرزهای 8، 16 یا حتی 32 بایت هستند،
        عملکرد بهتری داشته باشند. نیازهای تراز
        به برنامه‌های میزبان بستگی دارند.

        قرار دادن خط #pragma align در جلوی اعلان یک
        متغیر سراسری یا استاتیک، این متغیر را با مرزی که با گزینه کامپایلر
        تنظیم شده است، تراز می‌کند. توجه داشته باشید که این #pragma
        فقط متغیری را که بلافاصله پس از #pragma می‌آید تراز می‌کند.
        تراز متغیرهای بعدی به اندازه و
        تراز متغیرهایی که قبل از آن قرار دارند بستگی دارد. به عنوان مثال، اگر
        یک متغیر آرایه سراسری با 2 cell در یک مرز 16 بایتی تراز شده باشد
        و یک cell 4 بایت باشد، متغیر سراسری بعدی 8 بایت
        جلوتر قرار می‌گیرد.

        قرار دادن خط #pragma align در جلوی اعلان
        یک تابع، فریم پشته آن تابع را با مرزی که قبلاً
        مشخص شده است تراز می‌کند، با این نتیجه که اولین متغیر محلی
        غیر "استاتیک" با آن مرز تراز می‌شود. تراز
        متغیرهای بعدی به اندازه و تراز متغیرهایی که
        قبل از آن قرار دارند بستگی دارد. در عمل، برای تراز یک
        متغیر محلی غیر استاتیک، باید فریم پشته تابع را تراز کنید
        و آن متغیر را قبل از هر متغیر دیگری اعلام کنید.

    **#pragma** amxlimit *مقدار*

        حداکثر اندازه، به بایت، که اسکریپت کامپایل شده ممکن است
        به آن رشد کند را تنظیم می‌کند. این pragma برای محیط‌های (تعبیه شده)
        که حداکثر اندازه یک اسکریپت به یک حد بالای سخت محدود است،
        مفید است.

        اگر تنظیمی برای مقدار RAM برای داده و
        پشته وجود نداشته باشد (به pragma amxram مراجعه کنید)، این به کل نیازهای حافظه
        اشاره دارد؛ اگر مقدار RAM به صورت صریح تنظیم شده باشد، این مقدار

        فقط مقدار حافظه مورد نیاز برای کد و داده
        استاتیک را می‌دهد.

    **#pragma** amxram *مقدار*

        حداکثر نیازهای حافظه، به بایت، برای داده
        و پشته که یک اسکریپت کامپایل شده ممکن است داشته باشد را تنظیم می‌کند. این مقدار برای
        محیط‌های (تعبیه شده) که حداکثر اندازه داده
        یک اسکریپت به یک حد بالای سخت محدود است، مفید است. به ویژه در

        موردی که اسکریپت pawn از ROM اجرا می‌شود، اندازه‌های
        بخش‌های کد و داده هر دو باید تنظیم شوند.

    **#pragma** codepage *نام/مقدار*

        تجزیه‌کننده pawn می‌تواند کاراکترها را در رشته‌های unpacked
        و ثابت‌های کاراکتری به کاراکترهای "عریض" Unicode/UCS-4 ترجمه کند.
        این #pragma صفحه کدی را که باید برای
        ترجمه استفاده شود، نشان می‌دهد. برای جزئیات و منابع اضافی مورد نیاز برای ترجمه
        صفحه کد، بخش "بین‌المللی‌سازی" در صفحه

        139 را ببینید.

    **#pragma** compress *مقدار*

        تجزیه‌کننده pawn ممکن است P-code تولید شده را در رمزگذاری
        فشرده یا ساده ("غیر فشرده") بنویسد. پیش‌فرض به پیکربندی
        تجزیه‌کننده (و شاید تنظیمات کاربر) بستگی دارد. این
        #pragma به نویسنده اسکریپت اجازه می‌دهد پیش‌فرض را لغو کند و

        رمزگذاری فشرده را اجبار کند (وقتی مقدار غیر صفر است) یا رمزگذاری
        ساده را اجبار کند (وقتی مقدار صفر است). به ویژه تغییر وضعیت
        رمزگذاری فشرده به خاموش (اجبار رمزگذاری ساده) مفید است، زیرا

        تجزیه‌کننده pawn ممکن است قادر به کامپایل یک اسکریپت خاص
        در حالت "رمزگذاری فشرده" نباشد.

    **#pragma** ctrlchar *کاراکتر*

        کاراکتری را که برای نشان دادن شروع یک "دنباله escape" استفاده می‌شود، تعریف می‌کند.
        به طور پیش‌فرض، کاراکتر کنترل "\" است.

        به عنوان مثال

        `#pragma ctrlchar '\$'**`

        می‌توانید مقدار جدید برای کاراکتر کنترل را به عنوان یک ثابت
        کاراکتری (بین نقل قول‌های تکی) یا به عنوان یک مقدار دهدهی یا هگزادسیمال
        بدهید. وقتی مقدار کاراکتر کنترل جدید را حذف می‌کنید،
        تجزیه‌کننده به کاراکتر کنترل پیش‌فرض برمی‌گردد.

    **#pragma dynamic** *مقدار*

        اندازه، در cell ها، بلوک حافظه برای داده‌های پویا
        (پشته و هیپ) را به مقدار مشخص شده توسط عبارت
        تنظیم می‌کند. اندازه پیش‌فرض بلوک داده‌های پویا وابسته به پیاده‌سازی
        است. یک پیاده‌سازی همچنین ممکن است انتخاب کند که بلوک را
        بر اساس نیاز افزایش دهد (به مستندات برنامه میزبان، یا
        "راهنمای پیاده‌سازی کننده" برای جزئیات مراجعه کنید).

    **#pragma** library *نام*

        نام ماژول توسعه (پیوند شده به صورت پویا) را تنظیم می‌کند
        که شامل توابع بومی مورد نیاز است. این #pragma باید
        بالای اعلان‌های تابع بومی که بخشی از
        ماژول توسعه هستند، ظاهر شود.

        پارامتر نام کتابخانه ممکن است وجود نداشته باشد، که در این صورت
        هر اعلان تابع بومی بعدی با هیچ
        ماژول توسعه‌ای مرتبط نیست.

        محدوده این #pragma از خطی که در آن ظاهر می‌شود
        تا پایان فایلی که در آن ظاهر می‌شود، ادامه دارد. در استفاده معمول،
        یک خط #pragma library در بالای یک
        فایل include که توابع بومی را برای یک ماژول توسعه
        اعلام می‌کند، ظاهر می‌شود، و محدوده "پیوند" کتابخانه در پایان آن
        فایل include پایان می‌یابد.

    **#pragma** pack *مقدار*

        اگر مقدار صفر باشد، رشته‌های لیترال packed با "!"" (علامت
        تعجب + نقل قول دوتایی) و رشته‌های لیترال unpacked با
        فقط یک نقل قول دوتایی (""")، همانطور که در این راهنما در صفحه 99 توضیح داده شده است، شروع می‌شوند.
        اگر مقدار غیر صفر باشد، نحو برای رشته‌های لیترال packed و unpacked
        جابجا می‌شود: رشته‌های لیترالی که با یک نقل قول
        دوتایی شروع می‌شوند packed هستند و رشته‌های لیترالی که با "!""
        شروع می‌شوند unpacked هستند.

    **#pragma** rational *نام‌تگ(مقدار)*

        پشتیبانی از اعداد گویا را فعال می‌کند. نام‌تگ نام
        تگی است که اعداد گویا خواهند داشت؛ معمولاً نام‌های
        "Float:" یا "Fixed:" را انتخاب می‌کنند. وجود
        مقدار در پرانتز پشت نام‌تگ اختیاری است: اگر حذف شود،
        یک عدد گویا به عنوان یک مقدار "نقطه شناور" طبق
        استاندارد IEEE 754 ذخیره می‌شود؛ اگر وجود داشته باشد، یک عدد
        گویا یک عدد با دقت ثابت ("عدد صحیح مقیاس شده") با
        تعداد مشخص شده از اعشار است.

    **#pragma** semicolon *مقدار*

        اگر مقدار صفر باشد، هیچ نقطه‌ویرگولی برای پایان دادن به یک دستور اگر
        آن دستور آخرین در یک خط باشد، لازم نیست. نقطه‌ویرگول‌ها هنوز برای
        جدا کردن چندین دستور در یک خط مورد نیاز هستند.

        وقتی نقطه‌ویرگول‌ها اختیاری هستند (پیش‌فرض)، یک عملگر پسوند
        (یکی از "++", "--" و "char") نمی‌تواند اولین توکن در
        یک خط باشد، زیرا به عنوان عملگرهای پیشوند تفسیر خواهند شد.

    **#pragma** tabsize *مقدار*

        تعداد کاراکترها بین دو موقعیت tab متوالی.
        مقدار پیش‌فرض 8 است. ممکن است نیاز داشته باشید اندازه tab را تنظیم کنید
        تا از هشدار 217 (تورفتگی آزاد) جلوگیری کنید اگر کد منبع
        به صورت متناوب با فاصله‌ها و با کاراکترهای tab تورفتگی داشته باشد.
        به طور جایگزین، با تنظیم #pragma "tabsize" به صفر،
        تجزیه‌کننده دیگر هشدار 217 را صادر نخواهد کرد.

    **#pragma** unused *نماد,...*

        نماد نامگذاری شده را به عنوان "استفاده شده" علامت‌گذاری می‌کند. معمولاً،
        تجزیه‌کننده pawn در مورد متغیرهای استفاده نشده و ثابت‌های محلی استفاده نشده
        هشدار می‌دهد. در اکثر موقعیت‌ها، این متغیرها و ثابت‌ها
        زائد هستند، و برای وضوح کد بهتر است آنها را حذف کنید.
        به ویژه در مورد ثابت‌های محلی، ممکن است
        با این حال، بهتر (یا لازم) باشد که تعاریف ثابت را حفظ کنید.
        این #pragma سپس اجازه می‌دهد نماد (متغیر یا
        ثابت) را به عنوان "استفاده شده" علامت‌گذاری کنید، و از هشدار تجزیه‌کننده جلوگیری کنید.

        #pragma باید پس از اعلان نماد ظاهر شود —اما
        لازم نیست بلافاصله پس از اعلان ظاهر شود.

        چندین نام نماد ممکن است در یک #pragma واحد ظاهر شوند؛
        نمادها باید با کاما جدا شوند.

**#section** _نام_

    یک بخش جدید برای کد تولید شده شروع می‌کند. هر متغیر و تابعی
    که "static" اعلام شده‌اند فقط برای بخشی که به آن
    تعلق دارند قابل مشاهده هستند. به طور پیش‌فرض، هر فایل منبع یک بخش جداگانه
    است و فقط یک بخش در هر فایل وجود دارد.

    با دستورالعمل #section، می‌توانید چندین بخش در یک

    فایل منبع ایجاد کنید. نام یک بخش اختیاری است، اگر تنظیم نشده باشد، یک شناسه
    منحصر به فرد برای فایل منبع به عنوان نام بخش استفاده می‌شود.

    هر بخش اعلام شده به طور خودکار در پایان فایل پایان می‌یابد.

**#tryinclude** _نام فایل_ یا _< نام فایل >_

    این دستورالعمل مشابه دستورالعمل #include رفتار می‌کند، اما
    وقتی فایلی که باید شامل شود وجود ندارد، خطا نمی‌دهد —یعنی، سعی کنید
    شامل کنید اما در صورت خطا به آرامی شکست بخورید.

**#undef** _نام_

    یک ماکروی جایگزینی متن یا یک ثابت عددی اعلام شده
    با const را حذف می‌کند. پارامتر "نام" باید "پیشوند" ماکرو باشد —بخش
    الفبایی-عددی ماکرو. برای جزئیات و مثال‌هایی
    در مورد جایگزینی متن، صفحه 93 را ببینید.

---

`همچنین "ثابت‌های از پیش تعریف شده" در صفحه 102 را ببینید`

`کاراکتر escape: 99`

`پشتیبانی از اعداد گویا: 98`

`پیام‌های هشدار: 161`

---

[برگشت به فهرست](00-Contents.md)
