# دام‌ها: تفاوت‌ها با C

---

- PAWN فاقد مکانیزم تایپینگ C است. PAWN یک نوع "فقط-عدد صحیح" از C است؛ هیچ ساختار یا اتحادیه‌ای وجود ندارد، و پشتیبانی از اعداد اعشاری باید با عملگرهای تعریف شده توسط کاربر و کمک توابع بومی پیاده‌سازی شود.

- نحو پذیرفته شده برای اعداد گویا سخت‌گیرانه‌تر از مقادیر اعشاری در C است. مقادیری مانند ".5" و "6." در C قابل قبول هستند، اما در PAWN باید به ترتیب "0.5" و "6.0" را بنویسید. در C، نقطه اعشار اختیاری است اگر یک نما (exponent) شامل شود، بنابراین می‌توان "2E8" را نوشت؛ PAWN "E" بزرگ را نمی‌پذیرد (از "e" کوچک استفاده کنید) و به نقطه اعشار نیاز دارد: مثلاً "2.0e8". برای اطلاعات بیشتر صفحه 98 را ببینید.

- PAWN "اشاره‌گرها" را ارائه نمی‌دهد. برای هدف ارسال آرگومان‌های تابع با ارجاع، PAWN یک آرگومان "ارجاع" ارائه می‌دهد (صفحه 71). آرگومان "نگهدارنده" برخی از استفاده‌های اشاره‌گر NULL را جایگزین می‌کند (صفحه 75).

- اعداد می‌توانند مبنای هگزادسیمال، دهدهی یا باینری داشته باشند. مبنای هشت‌تایی پشتیبانی نمی‌شود. "ثابت‌ها" را در صفحه 98 ببینید. اعداد هگزادسیمال باید با "0x" (یک "x" کوچک) شروع شوند، پیشوند "0X" نامعتبر است.

- دنباله‌های escape ("\n"، "\t" و غیره) یکسان هستند، به جز "\ddd" که "ddd" نشان‌دهنده سه رقم دهدهی است، به جای ارقام هشت‌تایی که C/C++ استفاده می‌کند. بک‌اسلش ("\") ممکن است با نماد دیگری جایگزین شود؛ #pragma ctrlchar را در صفحه 120 ببینید —به ویژه، نسخه‌های قبلی PAWN از کاراکتر کارت ("^") به عنوان کاراکتر escape استفاده می‌کردند.

- موارد در یک دستور switch "عبور نمی‌کنند". فقط یک دستورالعمل می‌تواند (و باید) پس از هر برچسب case بیاید. برای اجرای چندین دستورالعمل، باید از یک دستور مرکب استفاده کنید. بند default یک دستور switch باید آخرین بند دستور switch باشد. اطلاعات بیشتر در صفحه 115. در C/C++، switch یک "goto شرطی" است، شبیه به برچسب‌های محاسبه شده Fortran. در PAWN، switch یک "if" ساختاری است.

- یک دستور break فقط از حلقه‌ها خارج می‌شود. در C/C⁺⁺، دستور break همچنین یک case را در یک دستور switch پایان می‌دهد. دستورات switch در PAWN به شکل متفاوتی پیاده‌سازی شده‌اند (صفحه 115 را ببینید).

- PAWN از "انتساب آرایه" پشتیبانی می‌کند، با این محدودیت که هر دو آرایه باید اندازه یکسانی داشته باشند. به عنوان مثال، اگر "a" و "b" هر دو آرایه‌هایی با 6 cell باشند، عبارت "a = b" معتبر است. علاوه بر رشته‌های لیترال، PAWN همچنین از آرایه‌های لیترال پشتیبانی می‌کند، که اجازه می‌دهد عبارت "a = {0,1,2,3,4,5}" (که "a" یک متغیر آرایه با 6 عنصر است) را بنویسید.

- _char_ یک عملگر است، نه یک نوع. صفحه 110 و نکات صفحه 137 را ببینید.

- _defined_ یک عملگر است، نه یک دستور پیش‌پردازنده. عملگر defined در PAWN روی ثابت‌ها (با const و enum)، متغیرهای سراسری، متغیرهای محلی و توابع عمل می‌کند.

- عملگر _sizeof_ اندازه یک متغیر را در "عناصر" برمی‌گرداند، نه در "بایت‌ها". یک عنصر ممکن است یک cell یا یک زیر-آرایه باشد. برای جزئیات صفحه 109 را ببینید.

- دستورالعمل خالی یک بلوک مرکب خالی است، نه یک نقطه‌ویرگول (صفحه 112). این اصلاح از یک خطای رایج جلوگیری می‌کند.

- دستورالعمل‌های کامپایلر با دستورات پیش‌پردازنده C متفاوت هستند. به ویژه، دستورالعمل #define با C/C⁺⁺ ناسازگار است، و #ifdef و #ifndef با دستورالعمل عمومی‌تر #if جایگزین شده‌اند (به "دستورالعمل‌ها" در صفحه 117 مراجعه کنید). برای ایجاد ثابت‌های عددی، همچنین صفحه 101 را ببینید؛ برای ایجاد ثابت‌های رشته‌ای، همچنین صفحه 93 را ببینید.

- جایگزینی‌های متن (ماکروهای پیش‌پردازنده؛ دستورالعمل #define را ببینید) در سراسر خطوط مطابقت داده نمی‌شوند. یعنی، متنی که می‌خواهید با یک ماکروی #define مطابقت دهید و جایگزین کنید باید در یک خط واحد ظاهر شود. تعریف یک ماکروی #define نیز باید در یک خط واحد ظاهر شود.

- جهت کوتاه کردن برای عملگر "/" همیشه به سمت مقدار کوچکتر است، جایی که -2 کوچکتر از -1 است. عملگر "%" همیشه یک نتیجه مثبت می‌دهد، صرف نظر از علامت‌های عملوندها. صفحه 104 را ببینید.

- هیچ عملگر "+" یکتایی وجود ندارد، که در هر صورت یک عملگر "بدون-عملیات" است.

- سه تا از عملگرهای بیتی اولویت متفاوتی نسبت به C دارند. سطوح اولویت عملگرهای "&"، "^" و "|" بالاتر از عملگرهای رابطه‌ای است (دنیس ریچی توضیح داد که این عملگرها سطوح اولویت پایین خود را در C به دست آوردند زیرا کامپایلرهای اولیه C هنوز عملگرهای منطقی "&&" و "||" را نداشتند، بنابراین به جای آن از عملگرهای بیتی "&" و "|" استفاده می‌شد).

- کلمه کلیدی "extern" در PAWN وجود ندارد؛ پیاده‌سازی فعلی کامپایلر "فاز پیوند" ندارد. برای ایجاد یک برنامه از چندین فایل منبع، همه فایل‌های منبع را به خط فرمان کامپایلر اضافه کنید، یا یک فایل اسکریپت پروژه اصلی ایجاد کنید که همه فایل‌های منبع دیگر را "#include" می‌کند. کامپایلر PAWN می‌تواند توابع و متغیرهای سراسری که استفاده نمی‌کنید را بهینه‌سازی کند. برای جزئیات صفحات 63 و 84 را ببینید.

- در اکثر موقعیت‌ها، اعلان‌های پیشرو توابع (یعنی، پروتوتایپ‌ها) ضروری نیستند. PAWN یک کامپایلر دو-گذر است، در گذر اول همه توابع را می‌بیند و در گذر دوم از آنها استفاده می‌کند. با این حال، عملگرهای تعریف شده توسط کاربر باید قبل از استفاده اعلام شوند.

اگر ارائه شوند، اعلان‌های پیشرو باید دقیقاً با تعریف تابع مطابقت داشته باشند، نام‌های پارامتر نباید از پروتوتایپ حذف شوند یا با تعریف تابع متفاوت باشند. PAWN به نام‌های پارامتر در پروتوتایپ‌ها اهمیت می‌دهد به دلیل ویژگی "پارامترهای نام‌گذاری شده". از پروتوتایپ‌ها برای فراخوانی توابع اعلام شده به صورت پیشرو استفاده می‌کنید. هنگام انجام این کار با پارامترهای نام‌گذاری شده، کامپایلر باید از قبل نام‌های پارامترها (و موقعیت آنها در لیست پارامتر) را بداند. در نتیجه، نام‌های پارامتر در یک پروتوتایپ باید با نام‌های موجود در تعریف برابر باشند.

---

[برگشت به فهرست](00-Contents.md)
