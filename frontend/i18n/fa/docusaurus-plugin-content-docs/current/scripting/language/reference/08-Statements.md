# دستورات

---

یک دستور ممکن است یک یا چند خط را اشغال کند، در حالی که یک خط ممکن است شامل دو یا
چند دستور باشد.

دستورات کنترل جریان (if، if–else، for، while، do–while و switch) ممکن است تو در تو باشند.

**برچسب دستور**

    یک برچسب شامل یک شناسه و به دنبال آن یک دو نقطه (":") است.
    یک برچسب یک "هدف پرش" برای دستور goto است.

    هر دستور ممکن است با یک برچسب شروع شود.
    باید یک دستور پس از برچسب وجود داشته باشد؛ یک دستور خالی مجاز است.

    محدوده یک برچسب، تابعی است که در آن اعلام شده است
    (بنابراین یک دستور goto نمی‌تواند از تابع فعلی به تابع دیگری پرش کند).

**دستور مرکب**

    یک دستور مرکب، مجموعه‌ای از صفر یا چند دستور است
    که توسط آکولادها (`{` و `}`) احاطه شده‌اند. آکولاد پایانی (`}`) نباید با نقطه‌ویرگول دنبال شود.
    هر دستور ممکن است با یک دستور مرکب جایگزین شود.
    یک دستور مرکب همچنین یک بلوک نامیده می‌شود.
    یک دستور مرکب با صفر دستور یک حالت خاص است،
    و "دستور خالی" نامیده می‌شود.

**دستور عبارت**

    هر عبارت زمانی که یک نقطه‌ویرگول (";") به آن اضافه شود، به یک دستور تبدیل می‌شود.
    یک عبارت همچنین زمانی به یک دستور تبدیل می‌شود که فقط فضای خالی
    پس از آن در خط وجود داشته باشد و عبارت نتواند به خط بعدی گسترش یابد.

**دستور خالی**

    یک دستور خالی هیچ عملیاتی انجام نمی‌دهد و شامل یک
    بلوک مرکب با صفر دستور است؛ یعنی، شامل توکن‌های "{ }" است.
    دستورات خالی در دستورات کنترل جریان استفاده می‌شوند
    اگر هیچ عملی وجود نداشته باشد (مثلاً while (!iskey()) {}) یا هنگام تعریف یک برچسب درست
    قبل از آکولاد بسته یک دستور مرکب.
    یک دستور خالی با نقطه‌ویرگول پایان نمی‌یابد.

**assert** _عبارت_

    اگر عبارت از نظر منطقی "false" ارزیابی شود،
    برنامه را با یک خطای زمان اجرا متوقف می‌کند.

**break**

    کوچکترین دستور do، for یا while محصور کننده را از هر نقطه‌ای
    درون حلقه به جز پایان منطقی آن، خاتمه داده و از آن خارج می‌شود.
    دستور break کنترل برنامه را به دستور بعدی خارج از حلقه منتقل می‌کند.

**continue**

    تکرار فعلی کوچکترین دستور do، for یا while محصور کننده را خاتمه می‌دهد
    و کنترل برنامه را به بخش شرط حلقه منتقل می‌کند.
    اگر دستور حلقه یک دستور for باشد،
    کنترل به عبارت سوم در دستور for منتقل می‌شود
    (و پس از آن به عبارت دوم).

**do** _دستور_ **while** ( _عبارت_ )

    یک دستور را قبل از ارزیابی بخش شرط (بند while) اجرا می‌کند.
    دستور تا زمانی که شرط از نظر منطقی "true" باشد تکرار می‌شود.
    دستور حداقل یک بار اجرا می‌شود.

**exit** _عبارت_

    برنامه را متوقف می‌کند. عبارت اختیاری است، اما اگر وجود داشته باشد،
    باید در همان خط دستور exit شروع شود.
    دستور exit مقدار عبارت (به علاوه تگ عبارت) را
    به برنامه میزبان برمی‌گرداند، یا اگر هیچ عبارت exit وجود نداشته باشد، صفر را برمی‌گرداند.
    اهمیت و هدف کدهای خروج وابسته به پیاده‌سازی است.

**for** ( _عبارت 1_ ; _عبارت 2_ ; _عبارت 3_ ) _دستور_

    هر سه عبارت اختیاری هستند.

    *عبارت 1*
        فقط یک بار و قبل از ورود به حلقه ارزیابی می‌شود.
        این عبارت ممکن است برای مقداردهی اولیه یک متغیر استفاده شود.
        این عبارت همچنین ممکن است شامل اعلان یک متغیر با استفاده از نحو جدید باشد.
        متغیری که در این عبارت اعلام می‌شود فقط در حلقه for وجود دارد.

    *عبارت 2*
        قبل از هر تکرار حلقه ارزیابی می‌شود و
        اگر نتیجه عبارت از نظر منطقی "false" باشد، حلقه را پایان می‌دهد.
        اگر حذف شود، نتیجه عبارت 2 از نظر منطقی "true" فرض می‌شود.

    *عبارت 3*
        پس از هر اجرای دستور ارزیابی می‌شود.
        کنترل برنامه از عبارت 3 به عبارت 2
        برای تکرار بعدی (شرطی) حلقه منتقل می‌شود.
        دستور for( ; ; ) معادل با while (true) است.

**goto** _برچسب_

    کنترل برنامه را (بدون شرط) به دستوری که پس از برچسب مشخص شده می‌آید منتقل می‌کند.
    برچسب باید در همان تابعی باشد که
    دستور goto در آن قرار دارد (یک دستور goto نمی‌تواند از یک تابع خارج شود).

**if** ( _عبارت_ ) _دستور 1_ **else** _دستور 2_

    اگر نتیجه عبارت از نظر منطقی "true" باشد، دستور 1 را اجرا می‌کند.
    بند else دستور if اختیاری است.
    اگر نتیجه عبارت از نظر منطقی "false" باشد و یک بند else وجود داشته باشد،
    دستور مرتبط با بند else (دستور 2) اجرا می‌شود.

    هنگامی که دستورات if تو در تو هستند و بندهای else وجود دارند،
    یک else مشخص با نزدیک‌ترین دستور if قبلی در همان بلوک مرتبط است.

**return** _عبارت_

    تابع فعلی را خاتمه می‌دهد و کنترل برنامه را
    به دستور پس از دستور فراخوانی منتقل می‌کند.
    مقدار عبارت به عنوان نتیجه تابع برگردانده می‌شود.
    عبارت ممکن است یک متغیر آرایه یا یک آرایه لیترال باشد.

    عبارت اختیاری است، اما اگر وجود داشته باشد،
    باید در همان خط دستور return شروع شود.
    اگر وجود نداشته باشد، مقدار تابع صفر است.

**sleep** _عبارت_

    برنامه را متوقف می‌کند، اما آن را در حالت قابل راه‌اندازی مجدد باقی می‌گذارد.
    عبارت اختیاری است. اگر شامل شود، دستور sleep
    مقدار عبارت (به علاوه تگ عبارت) را به برنامه میزبان برمی‌گرداند.
    اهمیت و هدف کدهای خروج/تگ‌ها وابسته به پیاده‌سازی است؛
    معمولاً، یک برنامه از دستور sleep برای امکان
    چند وظیفه‌ای سبک چندین برنامه pawn همزمان استفاده می‌کند،
    یا برای پیاده‌سازی توابع "نهفته".

**state** ( _عبارت_ ) **automaton** :_نام_

    حالت فعلی را در اتوماتون مشخص شده تغییر می‌دهد.
    عبارت بین پرانتزها اختیاری است؛ اگر وجود نداشته باشد،
    پرانتزها نیز باید حذف شوند.
    نام اتوماتون نیز اختیاری است،
    هنگام تغییر حالت اتوماتون پیش‌فرض، بی‌نام؛
    اگر نام اتوماتون وجود نداشته باشد، دو نقطه (":") نیز باید حذف شود.

    در زیر دو مثال از تغییرات حالت بدون شرط آمده است. اولی برای اتوماتون پیش‌فرض است:

```

state handshake

```

    و دومی برای یک اتوماتون خاص:

```

state gps:handshake

```

    اغلب، اینکه آیا یک حالت تغییر می‌کند یا نه به پارامترهای رویداد یا شرایط کلی اتوماتون بستگی دارد.
    از آنجا که تغییرات حالت شرطی بسیار رایج هستند،
    شرط ممکن است در خود دستور state قرار گیرد.
    ∗ شرط پس از کلیدواژه state، بین پرانتزها می‌آید.
    حالت فقط در صورتی تغییر می‌کند که شرط از نظر منطقی "true" باشد.

    دستور state باعث یک فراخوانی ضمنی به
    تابع ورودی برای حالت مشخص شده می‌شود —اگر چنین تابع ورودی وجود داشته باشد.

**switch** ( _عبارت_ ) \{ _لیست case_ \}

    کنترل را بسته به مقدار عبارت switch به دستورات مختلف درون بدنه switch منتقل می‌کند.
    بدنه دستور switch یک دستور مرکب است،
    که شامل مجموعه‌ای از "بندهای case" است.

    هر "بند case" با کلیدواژه case و به دنبال آن یک لیست ثابت و یک دستور شروع می‌شود.
    لیست ثابت مجموعه‌ای از عبارات است که با کاما جدا شده‌اند،
    و هر کدام به یک مقدار ثابت ارزیابی می‌شوند.
    لیست ثابت با یک دو نقطه پایان می‌یابد. برای مشخص کردن یک "محدوده" در لیست ثابت،
    حد پایین و بالای محدوده را با یک نقطه دوتایی ("..") جدا کنید.
    مثالی از یک محدوده: "case 1..9:".

    دستور switch کنترل را به یک "بند case" منتقل می‌کند اگر مقدار یکی از
    عبارات در لیست ثابت برابر با نتیجه عبارت switch باشد.

    "بند default" شامل کلیدواژه default و یک دو نقطه است.
    بند default اختیاری است، اما اگر شامل شود، باید آخرین بند در بدنه switch باشد.
    دستور switch کنترل را به "بند default" منتقل می‌کند
    اگر هیچ یک از بندهای case با نتیجه عبارت مطابقت نداشته باشند.

    مثال:

---

###### ∗ جایگزین این است که تغییرات حالت بدون شرط را در ساختار معمول if–else قرار دهیم.

---

```c

switch (weekday(12,31,1999))
{
    case 0, 1:              /* 0 == شنبه، 1 == یکشنبه */
        print("آخر هفته")
    case 2:
        print("دوشنبه")
    case 3:
        print("سه‌شنبه")
    case 4:
        print("چهارشنبه")
    case 5:
        print("پنج‌شنبه")
    case 6:
        print("جمعه")
    default:
        print("روز هفته نامعتبر")
}

```

**while** ( _عبارت_ ) _دستور_

    عبارت را ارزیابی می‌کند و اگر نتیجه عبارت
    از نظر منطقی "true" باشد، دستور را اجرا می‌کند.
    پس از اجرای دستور، کنترل برنامه دوباره به عبارت برمی‌گردد.
    بنابراین دستور تا زمانی که عبارت true است اجرا می‌شود.

---

`شناسه‌ها: 97`

`مثال: 11 (assert)`

`مثال: 21 (break)`

`مثال: 27 (do while)`

`مثال‌ها: 9، 11، 21 (for)`

`اعلان‌های متغیر: 62 (for)`

`مثال: 7 (if else)`

`مثال‌ها: 11، 21 (return)`

`برای مثال‌هایی از تغییرات حالت شرطی صفحه 40 را ببینید (state automaton)`

`توابع "ورودی": 44 (state automaton)`

`مثال‌ها: 7، 21، 26 (while)`

---

[برگشت به فهرست](00-Contents.md)
