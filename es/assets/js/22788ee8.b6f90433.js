"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["71044"],{24469:function(e,a,n){n.r(a),n.d(a,{frontMatter:()=>l,toc:()=>d,default:()=>u,metadata:()=>s,assets:()=>c,contentTitle:()=>i});var s=JSON.parse('{"id":"scripting/callbacks/OnPlayerKeyStateChange","title":"OnPlayerKeyStateChange","description":"Descripci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/scripting/callbacks/OnPlayerKeyStateChange.md","sourceDirName":"scripting/callbacks","slug":"/scripting/callbacks/OnPlayerKeyStateChange","permalink":"/es/docs/scripting/callbacks/OnPlayerKeyStateChange","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/i18n/es/docusaurus-plugin-content-docs/current/scripting/callbacks/OnPlayerKeyStateChange.md","tags":[{"inline":true,"label":"player","permalink":"/es/docs/tags/player"}],"version":"current","frontMatter":{"t\xedtulo":"OnPlayerKeyStateChange","descripci\xf3n":"Este callback se llama cuando el estado de alguna tecla soportada cambia (presionada/soltada).","tags":["player"]},"sidebar":"docsSidebar","previous":{"title":"OnPlayerInteriorChange","permalink":"/es/docs/scripting/callbacks/OnPlayerInteriorChange"},"next":{"title":"OnPlayerLeaveCheckpoint","permalink":"/es/docs/scripting/callbacks/OnPlayerLeaveCheckpoint"}}'),o=n(85893),r=n(50065);let l={"t\xedtulo":"OnPlayerKeyStateChange","descripci\xf3n":"Este callback se llama cuando el estado de alguna tecla soportada cambia (presionada/soltada).",tags:["player"]},i=void 0,c={},d=[{value:"Descripci\xf3n",id:"descripci\xf3n",level:2},{value:"Devoluciones",id:"devoluciones",level:2},{value:"Notas",id:"notas",level:2},{value:"Funciones Relacionadas",id:"funciones-relacionadas",level:2},{value:"Informaci\xf3n adicional",id:"informaci\xf3n-adicional",level:2},{value:"Introducci\xf3n",id:"introducci\xf3n",level:3},{value:"Par\xe1metros",id:"par\xe1metros",level:3},{value:"C\xf3mo no comprobar una tecla",id:"c\xf3mo-no-comprobar-una-tecla",level:3},{value:"C\xf3mo comprobar una tecla correctamente",id:"c\xf3mo-comprobar-una-tecla-correctamente",level:3},{value:"C\xf3mo comprobar si una tecla ha sido presionada",id:"c\xf3mo-comprobar-si-una-tecla-ha-sido-presionada",level:3},{value:"C\xf3mo comprobar si una tecla se liber\xf3/dej\xf3 de presionarse",id:"c\xf3mo-comprobar-si-una-tecla-se-liber\xf3dej\xf3-de-presionarse",level:3},{value:"C\xf3mo comprobar m\xfaltiples teclas",id:"c\xf3mo-comprobar-m\xfaltiples-teclas",level:3},{value:"Simplificaci\xf3n",id:"simplificaci\xf3n",level:2},{value:"Detectar una tecla sosteniendose/hundi\xe9ndose",id:"detectar-una-tecla-sosteniendosehundi\xe9ndose",level:3},{value:"Detectando una tecla pulsada una sola vez",id:"detectando-una-tecla-pulsada-una-sola-vez",level:3},{value:"Detectar si un jugador est\xe1 presionando una tecla actualmente",id:"detectar-si-un-jugador-est\xe1-presionando-una-tecla-actualmente",level:3},{value:"Detectando una tecla liberada",id:"detectando-una-tecla-liberada",level:3},{value:"Ejemplos",id:"ejemplos",level:2},{value:"A\xf1adiendo nitro x10 al veh\xedculo del jugador cuando presiona disparar",id:"a\xf1adiendo-nitro-x10-al-veh\xedculo-del-jugador-cuando-presiona-disparar",level:3},{value:"Super salto",id:"super-salto",level:3},{value:"God mode mientras se sostiene &#39;KEY_ACTION&#39;",id:"god-mode-mientras-se-sostiene-key_action",level:3},{value:"Explicaci\xf3n",id:"explicaci\xf3n",level:3}];function t(e){let a={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.h2,{id:"descripci\xf3n",children:"Descripci\xf3n"}),"\n",(0,o.jsxs)(a.p,{children:["Este callback se llama cuando el estado de alguna tecla ",(0,o.jsx)(a.a,{href:"../resources/keys",children:"soportada"})," cambia (presionada/soltada).",(0,o.jsx)("br",{}),"Las teclas direccionales no desencadenan OnPlayerKeyStateChange (arriba, abajo, izquierda, derecha)."]}),"\n",(0,o.jsxs)(a.table,{children:[(0,o.jsx)(a.thead,{children:(0,o.jsxs)(a.tr,{children:[(0,o.jsx)(a.th,{children:"Nombre"}),(0,o.jsx)(a.th,{children:"Descripci\xf3n"})]})}),(0,o.jsxs)(a.tbody,{children:[(0,o.jsxs)(a.tr,{children:[(0,o.jsx)(a.td,{children:"playerid"}),(0,o.jsx)(a.td,{children:"El ID del jugador que presion\xf3 o solt\xf3 una tecla."})]}),(0,o.jsxs)(a.tr,{children:[(0,o.jsx)(a.td,{children:"newkeys"}),(0,o.jsxs)(a.td,{children:["Un mapa (m\xe1scara de bits) de las teclas actualmente presionadas. - ",(0,o.jsx)(a.a,{href:"../resources/keys",children:"ver ac\xe1"}),"."]})]}),(0,o.jsxs)(a.tr,{children:[(0,o.jsx)(a.td,{children:"oldkeys"}),(0,o.jsxs)(a.td,{children:["Un mapa (m\xe1scara de bits) de las teclas presionadas previo al cambio actual - ",(0,o.jsx)(a.a,{href:"../resources/keys",children:"ver ac\xe1"}),"."]})]})]})]}),"\n",(0,o.jsx)(a.h2,{id:"devoluciones",children:"Devoluciones"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"Este callback no controla devoluciones."}),"\n",(0,o.jsx)(a.li,{children:"Siempre se llama primero en el gamemode."}),"\n"]}),"\n",(0,o.jsx)(a.h2,{id:"notas",children:"Notas"}),"\n",(0,o.jsx)(a.admonition,{type:"info",children:(0,o.jsx)(a.p,{children:"Este callback tambi\xe9n puede ser llamado por NPC."})}),"\n",(0,o.jsx)(a.admonition,{type:"tip",children:(0,o.jsxs)(a.p,{children:["Las teclas direccionales no desencadenan OnPlayerKeyStateChange (arriba, abajo, izquierda, derecha).",(0,o.jsx)("br",{}),"Estas s\xf3lo pueden ser detectadas con ",(0,o.jsx)(a.a,{href:"../functions/GetPlayerKeys",children:"GetPlayerKeys"})," (en ",(0,o.jsx)(a.a,{href:"OnPlayerUpdate",children:"OnPlayerUpdate"})," o en un timer)."]})}),"\n",(0,o.jsx)(a.h2,{id:"funciones-relacionadas",children:"Funciones Relacionadas"}),"\n",(0,o.jsx)(a.p,{children:"#test"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.a,{href:"../functions/GetPlayerKeys",children:"GetPlayerKeys"}),": Comprueba qu\xe9 teclas est\xe1 apretando un jugador."]}),"\n"]}),"\n",(0,o.jsx)(a.h2,{id:"informaci\xf3n-adicional",children:"Informaci\xf3n adicional"}),"\n",(0,o.jsx)(a.h3,{id:"introducci\xf3n",children:"Introducci\xf3n"}),"\n",(0,o.jsxs)(a.p,{children:["Este callback es llamado cuando un jugador presiona o suelta una de las teclas soportadas (vea ",(0,o.jsx)(a.a,{href:"../resources/keys",children:"Teclas"}),").",(0,o.jsx)("br",{})," Las teclas que son compatibles no son las teclas actuales del teclado, sino las teclas funcionales mapeadas del GTA San Andreas, esto quiere decir que, por ejemplo, no pod\xe9s detectar cuando alguien presiona la ",(0,o.jsx)("strong",{children:"barra espaciadora"}),", pero s\xed pod\xe9s detectar cuando este presiona su tecla la tecla de correr, (que puede, o no, ser asignada a la barra espaciadora (as\xed es por defecto en el juego))."]}),"\n",(0,o.jsx)(a.h3,{id:"par\xe1metros",children:"Par\xe1metros"}),"\n",(0,o.jsx)(a.p,{children:"Los par\xe1metros de esta funcion son una lista de todas las teclas actualmente siendo presionadas y todas las teclas presionadas hace un momento. Este callback es llamado cuando el estado de la tecla cambia (esto ser\xe1, cuando una tecla sea sea presionada o soltada) y pasa los estados de todas las teclas antes y despu\xe9s de este cambio. Esta informaci\xf3n puede ser usada para ver ex\xe1ctamente que pas\xf3 pero las variables no pueden ser usadas directamente de la misma manera como par\xe1metros a otras funciones. Para reducir el n\xfamero de variables un solo BIT es usado para representar una tecla, esto quiere decir que una variable puede contener m\xfaltiples teclas al mismo tiempo y comparar los valores simplemente no va a funcionar siempre."}),"\n",(0,o.jsx)(a.h3,{id:"c\xf3mo-no-comprobar-una-tecla",children:"C\xf3mo no comprobar una tecla"}),"\n",(0,o.jsx)(a.p,{children:"Vamos a suponer que quer\xe9s detectar cuando un jugador presiona el bot\xf3n DISPARO, el c\xf3digo obvio ser\xeda:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (newkeys == KEY_FIRE)\n"})}),"\n",(0,o.jsx)(a.p,{children:"Este c\xf3digo puede funcionar en su testeo, pero es incorrecto y su testeo es insuficiente. Prob\xe1 agachandote y presionando disparo - tu c\xf3digo ya no va a funcionar como antes. \xbfPor qu\xe9? Esto es porque 'newkeys' ya no es lo mismo que 'KEY_FIRE', en este caso el valor ser\xe1 'KEY_FIRE' COMBINADO CON 'KEY_CROUCH'."}),"\n",(0,o.jsx)(a.h3,{id:"c\xf3mo-comprobar-una-tecla-correctamente",children:"C\xf3mo comprobar una tecla correctamente"}),"\n",(0,o.jsx)(a.p,{children:"Entonces, si la variable puede contener m\xfaltiples teclas al mismo tiempo, \xbfc\xf3mo comprobamos por una en espec\xedfico? La respuesta es enmascaramiento de bits. Cada tecla tiene su propio bit en la variable (algunas teclas tienen el mismo bit, pero estas son teclas a pie/en veh\xedculo, entonces nunca podr\xe1n ser presionadas al mismo tiempo) y necesit\xe1s comprobar por un solo bit:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (newkeys & KEY_FIRE)\n"})}),"\n",(0,o.jsxs)(a.p,{children:["Notese que el uso de un solo ",(0,o.jsx)("strong",{children:"&"})," es correcto - este es un bitwise AND (operador de manipulaci\xf3n de bits), no un AND l\xf3gico, que es como se llama el operador de los dos signos ",(0,o.jsx)("strong",{children:"&&"}),"."]}),"\n",(0,o.jsx)(a.p,{children:"Ahora si prob\xe1s este c\xf3digo va a funcionar mientras est\xe9s agachando o parado cuando apretes la tecla/bot\xf3n de disparo. Sin embargo ac\xe1 sigue un ligero problema - el personaje disparar\xe1 hasta que dejes de presionar la tecla. OnPlayerKeyStateChange se llama cada vez que hay un cambio en las teclas y este c\xf3digo funciona mientras que la tecla de disparo es presionada. Si presionas disparar el c\xf3digo ser\xe1 desencadenado, y si esta tecla es retenida y presionas agacharse - este c\xf3digo se desencadenar\xe1 de nuevo porque una tecla (agacharse) cambi\xf3 su estado y disparo a\xfan sigue presionado. \xbfC\xf3mo detectamos cuando una tecla es presionada por primera vez, pero sin desencadenar el callback de nuevo cuando sigue presionada y otra tecla diferente cambia?"}),"\n",(0,o.jsx)(a.h3,{id:"c\xf3mo-comprobar-si-una-tecla-ha-sido-presionada",children:"C\xf3mo comprobar si una tecla ha sido presionada"}),"\n",(0,o.jsx)(a.p,{children:'Ac\xe1 es cuando entra "oldkeys". Para comprobar si una tecla fue presionada necesitas primero verificar si esta est\xe1 como valor en "newkeys" - lo que significa que fue presionada, y entonces comprobar si esta tecla NO est\xe1 en "oldkeys" - lo que quiere decir que esta s\xf3lo se ha presionado. El siguiente c\xf3digo hace lo anterior mencionado:'}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if ((newkeys & KEY_FIRE) && !(oldkeys & KEY_FIRE))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Esto SOLO ser\xe1 verdadero cuando la tecla DISPARO sea presionada una sola vez, y no cuando se mantenga y otra tecla cambie su estado."}),"\n",(0,o.jsx)(a.h3,{id:"c\xf3mo-comprobar-si-una-tecla-se-liber\xf3dej\xf3-de-presionarse",children:"C\xf3mo comprobar si una tecla se liber\xf3/dej\xf3 de presionarse"}),"\n",(0,o.jsx)(a.p,{children:"Exactamente el mismo concepto que antes, pero dado vuelta."}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if ((oldkeys & KEY_FIRE) && !(newkeys & KEY_FIRE))\n"})}),"\n",(0,o.jsx)(a.h3,{id:"c\xf3mo-comprobar-m\xfaltiples-teclas",children:"C\xf3mo comprobar m\xfaltiples teclas"}),"\n",(0,o.jsx)(a.p,{children:"Si quer\xe9s comprobar por jugadores PRESIONANDO agacharse y disparando el siguiente c\xf3digo funcionar\xe1 correctamente:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if ((newkeys & KEY_FIRE) && (newkeys & KEY_CROUCH))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Sin embargo si quer\xe9s detectar cuando el jugador presiona por primera vez disparar y se agacha el siguiente c\xf3digo NO funcionar\xe1. Este funcionar\xe1 si el jugador presiona las dos teclas al mismo tiempo exactamente, pero si estas est\xe1n fraccionadamente afuera del mismo desencadenamiento (mucho menos de medio segundo desde que se apret\xf3 la primer tecla en cuesti\xf3n), este no funcionar\xe1:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if ((newkeys & KEY_FIRE) && !(oldkeys & KEY_FIRE) && (newkeys & KEY_CROUCH) && !(oldkeys & KEY_CROUCH))\n"})}),"\n",(0,o.jsx)(a.p,{children:'\xbfPor qu\xe9 no? Esto es porque OnPlayerKeyStateChange se llama cada vez que una simple tecla cambia su estado. Entonces si el jugador presiona "KEY_FIRE" - OnPlayerKeyStateChange es llamado con "KEY_FIRE" en "newkeys" y no en "oldskeys", entonces presiona "KEY_CROUCH" - OnPlayerKeyStateChange es llamado con "KEY_CROUCH" y "KEY_FIRE" en "newkeys" pero "KEY_FIRE" es ahora tambi\xe9n en "oldkeys" como si ya fue presionado, entonces "!(oldkeys & KEY_FIRE)" fallar\xe1. Afortunadamente la soluci\xf3n es muy simple (de hecho m\xe1s simple que el c\xf3digo original):'}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if ((newkeys & (KEY_FIRE | KEY_CROUCH)) == (KEY_FIRE | KEY_CROUCH) && (oldkeys & (KEY_FIRE | KEY_CROUCH)) != (KEY_FIRE | KEY_CROUCH))\n"})}),"\n",(0,o.jsx)(a.p,{children:'Esto puede parecer complicado, pero comprueba que ambas teclas est\xe9n en "newkeys" y que no est\xe9n en "oldkeys", si una de ellas est\xe1 en "oldkeys" no importa ya que ambas no estaban. Todas estas cosas pueden ser muy simplificadas con macros (defines).'}),"\n",(0,o.jsx)(a.h2,{id:"simplificaci\xf3n",children:"Simplificaci\xf3n"}),"\n",(0,o.jsx)(a.h3,{id:"detectar-una-tecla-sosteniendosehundi\xe9ndose",children:"Detectar una tecla sosteniendose/hundi\xe9ndose"}),"\n",(0,o.jsx)(a.p,{children:"El macro:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"// HOLDING(keys)\n#define HOLDING(%0) \\\n	((newkeys & (%0)) == (%0))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Sosteniendo una tecla:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (HOLDING( KEY_FIRE ))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Sosteniendo m\xfaltiples teclas:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (HOLDING( KEY_FIRE | KEY_CROUCH ))\n"})}),"\n",(0,o.jsx)(a.h3,{id:"detectando-una-tecla-pulsada-una-sola-vez",children:"Detectando una tecla pulsada una sola vez"}),"\n",(0,o.jsx)(a.p,{children:"El macro:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"// PRESSED(keys)\n#define PRESSED(%0) \\\n	(((newkeys & (%0)) == (%0)) && ((oldkeys & (%0)) != (%0)))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Una tecla pulsada:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (PRESSED( KEY_FIRE ))\n"})}),"\n",(0,o.jsx)(a.p,{children:"M\xfaltiples teclas pulsadas:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (PRESSED( KEY_FIRE | KEY_CROUCH ))\n"})}),"\n",(0,o.jsx)(a.h3,{id:"detectar-si-un-jugador-est\xe1-presionando-una-tecla-actualmente",children:"Detectar si un jugador est\xe1 presionando una tecla actualmente"}),"\n",(0,o.jsx)(a.p,{children:"El macro:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"// PRESSING(keyVariable, keys)\n#define PRESSING(%0,%1) \\\n	(%0 & (%1))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Presionando una tecla:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (PRESSING( newkeys, KEY_FIRE ))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Presionando m\xfaltiples teclas:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (PRESSING( newkeys, KEY_FIRE | KEY_CROUCH ))\n"})}),"\n",(0,o.jsx)(a.h3,{id:"detectando-una-tecla-liberada",children:"Detectando una tecla liberada"}),"\n",(0,o.jsx)(a.p,{children:"El macro:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"// RELEASED(keys)\n#define RELEASED(%0) \\\n	(((newkeys & (%0)) != (%0)) && ((oldkeys & (%0)) == (%0)))\n"})}),"\n",(0,o.jsx)(a.p,{children:"Una tecla liberada:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (RELEASED( KEY_FIRE ))\n"})}),"\n",(0,o.jsx)(a.p,{children:"M\xfaltiples teclas liberadas:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"if (RELEASED( KEY_FIRE | KEY_CROUCH ))\n"})}),"\n",(0,o.jsx)(a.h2,{id:"ejemplos",children:"Ejemplos"}),"\n",(0,o.jsx)(a.h3,{id:"a\xf1adiendo-nitro-x10-al-veh\xedculo-del-jugador-cuando-presiona-disparar",children:"A\xf1adiendo nitro x10 al veh\xedculo del jugador cuando presiona disparar"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"public OnPlayerKeyStateChange(playerid, KEY:newkeys, KEY:oldkeys)\n{\n	if (PRESSED(KEY_FIRE))\n	{\n		if (IsPlayerInAnyVehicle(playerid))\n		{\n			AddVehicleComponent(GetPlayerVehicleID(playerid), 1010);\n		}\n	}\n	return 1;\n}\n"})}),"\n",(0,o.jsx)(a.h3,{id:"super-salto",children:"Super salto"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"public OnPlayerKeyStateChange(playerid, KEY:newkeys, KEY:oldkeys)\n{\n	if (PRESSED(KEY_JUMP))\n	{\n		new\n			Float:x,\n			Float:y,\n			Float:z;\n		GetPlayerPos(playerid, x, y, z);\n		SetPlayerPos(playerid, x, y, z + 10.0);\n	}\n	return 1;\n}\n"})}),"\n",(0,o.jsx)(a.h3,{id:"god-mode-mientras-se-sostiene-key_action",children:"God mode mientras se sostiene 'KEY_ACTION'"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-c",children:"new\n	Float:gPlayerHealth[MAX_PLAYERS];\n\n#if !defined INFINITY\n	#define INFINITY (Float:0x7F800000)\n#endif\n\npublic OnPlayerKeyStateChange(playerid, KEY:newkeys, KEY:oldkeys)\n{\n	if (PRESSED(KEY_ACTION))\n	{\n		// El jugador presion\xf3 la tecla de acci\xf3n, guardamos su\n		// salud anterior para restaurarla posteriormente.\n		GetPlayerHealth(playerid, gPlayerHealth[playerid]);\n		SetPlayerHealth(playerid, INFINITY);\n	}\n	else if (RELEASED(KEY_ACTION))\n	{\n		// Dej\xf3 de presionar la tecla de acci\xf3n - restauramos\n		// su antigua salud de nuevo.\n		SetPlayerHealth(playerid, gPlayerHealth[playerid]);\n	}\n	return 1;\n}\n"})}),"\n",(0,o.jsx)(a.h3,{id:"explicaci\xf3n",children:"Explicaci\xf3n"}),"\n",(0,o.jsx)(a.p,{children:"No necesitas preocuparte de C\xd3MO se hace, s\xf3lo que as\xed es. HOLDING detecta si est\xe1 presionando una tecla (o teclas), independientemente de si la estaban presionando antes, PRESSED detecta si solo se presion\xf3 la tecla y RELEASED detecta si acaba de soltar una tecla. Sin embargo si quer\xe9s saber m\xe1s - sigue leyendo."}),"\n",(0,o.jsx)(a.p,{children:"La raz\xf3n por la que necesitas hacerlo de esta manera, no solo usando & o ==, es detectar exactamente las teclas que desea mientras ignora otras que pueden o no estar presionadas. En binario KEY_SPRINT es:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{children:"0b00001000\n"})}),"\n",(0,o.jsx)(a.p,{children:"y KEY_JUMP es:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{children:"0b00100000\n"})}),"\n",(0,o.jsx)(a.p,{children:'Si solo estuvi\xe9ramos usando & y OnPlayerKeyStateChange es llamado por un jugador presionando "salto" podr\xedamos obtener el siguiente c\xf3digo:'}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{children:"newkeys = 0b00100000\nwanted  = 0b00101000\nANDed   = 0b00100000\n"})}),"\n",(0,o.jsx)(a.p,{children:"El AND de los dos n\xfameros no es 0, por lo que el resultado es verdadero, que no es lo que queremos."}),"\n",(0,o.jsx)(a.p,{children:"Si usamos == los dos n\xfameros claramente no son iguales, entonces la verificaci\xf3n fallar\xeda, eso es lo que queremos."}),"\n",(0,o.jsx)(a.p,{children:'Si el jugador estuviera presionando "saltar", "correr" y agacharse, tendr\xedamos el siguiente c\xf3digo:'}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{children:"newkeys = 0b00101010\nwanted  = 0b00101000\nANDed   = 0b00101000\n"})}),"\n",(0,o.jsx)(a.p,{children:"La versi\xf3n con AND es la misma que las claves requeridas y tampoco es 0, por lo que dar\xe1 la respuesta correcta, sin embargo, los dos n\xfameros originales no son iguales, por lo que == fallar\xe1. En ambos ejemplos, uno de los dos result\xf3 en la respuesta correcta y el otro en la incorrecta. Si comparamos el primero usando & e == tenemos:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{children:"newkeys = 0b00100000\nwanted  = 0b00101000\nANDed   = 0b00100000\n"})}),"\n",(0,o.jsx)(a.p,{children:'Obviamente, "wanted" y AND no son lo mismo, por lo que la verificaci\xf3n falla, lo cual es correcto, para el segundo ejemplo:'}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{children:"newkeys = 0b00101010\nwanted  = 0b00101000\nANDed   = 0b00101000\n"})}),"\n",(0,o.jsx)(a.p,{children:'"wanted" y AND son lo mismo, por lo que compararlos devolver\xe1 verdadero, lo cual nuevamente es correcto.'}),"\n",(0,o.jsx)(a.p,{children:'Por lo tanto, al usar este m\xe9todo, podemos verificar con precisi\xf3n si se presionaron ciertas teclas e ignorar todas las dem\xe1s teclas. Las "oldkeys" lo usan en su verificaci\xf3n! - En lugar de == para asegurarse de que las teclas no fueron presionadas previamente, as\xed sabemos que una de ellas fue presionada.'})]})}function u(e={}){let{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}},50065:function(e,a,n){n.d(a,{Z:()=>i,a:()=>l});var s=n(67294);let o={},r=s.createContext(o);function l(e){let a=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),s.createElement(r.Provider,{value:a},e.children)}}}]);