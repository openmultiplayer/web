"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["66016"],{65283:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>s,toc:()=>c,default:()=>h,metadata:()=>o,assets:()=>l,contentTitle:()=>t});var o=JSON.parse('{"id":"scripting/language/reference/Functions","title":"Fun\xe7\xf5es","description":"---","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/scripting/language/reference/04-Functions.md","sourceDirName":"scripting/language/reference","slug":"/scripting/language/reference/Functions","permalink":"/pt-BR/docs/scripting/language/reference/Functions","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/i18n/pt-BR/docusaurus-plugin-content-docs/current/scripting/language/reference/04-Functions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Data-and-declarations","permalink":"/pt-BR/docs/scripting/language/reference/Data-and-declarations"},"next":{"title":"The-preprocessor","permalink":"/pt-BR/docs/scripting/language/reference/The-preprocessor"}}'),r=a(85893),i=a(50065);let s={},t="Fun\xe7\xf5es",l={},c=[{value:"\u2022 Argumentos (valor vs. refer\xeancia)",id:"-argumentos-valor-vs-refer\xeancia",level:3},{value:"\u2022 Calling functions",id:"-calling-functions",level:3},{value:"\u2022 Chamando fun\xe7\xf5es",id:"-chamando-fun\xe7\xf5es",level:3},{value:"\u2022 Par\xe2metros posicionais x nomeados",id:"-par\xe2metros-posicionais-x-nomeados",level:3},{value:"\u2022 Valores padr\xe3o",id:"-valores-padr\xe3o",level:3},{value:"\u2022 <code>sizeof</code> em argumentos padr\xe3o",id:"-sizeof-em-argumentos-padr\xe3o",level:3},{value:"\u2022 Argumentos com tags",id:"-argumentos-com-tags",level:3},{value:"\u2022 Argumentos vari\xe1veis",id:"-argumentos-vari\xe1veis",level:3},{value:"\u2022 Regras de coer\xe7\xe3o",id:"-regras-de-coer\xe7\xe3o",level:3},{value:"\u2022 Recurs\xe3o",id:"-recurs\xe3o",level:3},{value:"\u2022 Declara\xe7\xf5es antecipadas",id:"-declara\xe7\xf5es-antecipadas",level:3},{value:"\u2217 Other implementations of the Pawn language (if they exist) may use \u201Csingle pass\u201D parsers, requiring functions to be defined before use.",id:"-other-implementations-of-the-pawn-language-if-they-exist-may-use-single-pass-parsers-requiring-functions-to-be-defined-before-use",level:6},{value:"\u2022 Classificadores de estado",id:"-classificadores-de-estado",level:3},{value:"\u2022 Fun\xe7\xf5es <code>public</code> e <code>main</code>",id:"-fun\xe7\xf5es-public-e-main",level:3},{value:"\u2022 Static functions",id:"-static-functions",level:3},{value:"\u2022 Stock functions",id:"-stock-functions",level:3},{value:"\u2022 Native functions",id:"-native-functions",level:3},{value:"\u2022 User-defined operators",id:"-user-defined-operators",level:3},{value:"\u2022 Floating point and fixed point arithmetic",id:"-floating-point-and-fixed-point-arithmetic",level:3},{value:"\u2217 Modern CPUs use two\u2019s complement integer arithmetic. For positive values, the bitwise representation of a value is the same in one\u2019s complement and two\u2019s complement, but the representations differ for negative values. For instance, the same bit pattern that means -5 in one\u2019s complement stands for -6 in two\u2019s complement.",id:"-modern-cpus-use-twos-complement-integer-arithmetic-for-positive-values-the-bitwise-representation-of-a-value-is-the-same-in-ones-complement-and-twos-complement-but-the-representations-differ-for-negative-values-for-instance-the-same-bit-pattern-that-means--5-in-ones-complement-stands-for--6-in-twos-complement",level:6},{value:"\u2020 See the application note \u201CFixed Point Support Library\u201D for where to obtain the include file.",id:"-see-the-application-note-fixed-point-support-library-for-where-to-obtain-the-include-file",level:6},{value:"\u2022 Call by Value and Call by Reference",id:"-call-by-value-and-call-by-reference",level:3},{value:"Call by value",id:"call-by-value",level:4},{value:"Call by reference",id:"call-by-reference",level:4},{value:"\u2022 Recursion / Function Recursion",id:"-recursion--function-recursion",level:3},{value:"Base Case:",id:"base-case",level:5},{value:"Recursive Case:",id:"recursive-case",level:5},{value:"Example",id:"example",level:4},{value:"Demonstrate the Output",id:"demonstrate-the-output",level:4},{value:"Stack Memory",id:"stack-memory",level:3},{value:"Example (Stack Overflow)",id:"example-stack-overflow",level:4},{value:"Output",id:"output",level:4}];function d(e){let n={a:"a",br:"br",code:"code",h1:"h1",h3:"h3",h4:"h4",h5:"h5",h6:"h6",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"fun\xe7\xf5es",children:"Fun\xe7\xf5es"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"A declara\xe7\xe3o de fun\xe7\xe3o define o nome e, entre par\xeanteses, os par\xe2metros formais. Fun\xe7\xf5es podem retornar valores. Essas declara\xe7\xf5es devem ficar em n\xedvel global (fora de outras fun\xe7\xf5es) e ficam acess\xedveis a todo o c\xf3digo."}),"\n",(0,r.jsx)(n.p,{children:"Se um ponto e v\xedrgula surgir logo ap\xf3s a declara\xe7\xe3o (no lugar de um bloco), trata-se de uma declara\xe7\xe3o antecipada (forward)."}),"\n",(0,r.jsxs)(n.p,{children:["O ",(0,r.jsx)(n.code,{children:"return"})," define o resultado da fun\xe7\xe3o. Em ",(0,r.jsx)(n.code,{children:"sum"}),", por exemplo, o retorno \xe9 a soma dos dois argumentos. O retorno \xe9 opcional, mas n\xe3o \xe9 poss\xedvel usar o valor de uma fun\xe7\xe3o que n\xe3o retorna nada."]}),"\n",(0,r.jsx)(n.p,{children:"Listing: sum function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nsum(a, b)\nreturn a + b\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Os par\xe2metros s\xe3o vari\xe1veis locais impl\xedcitas; a chamada define seus valores."}),"\n",(0,r.jsx)(n.p,{children:"Another example of a complete definition of the function leapyear\n(which returns true for a leap year and false for a non-leap year):"}),"\n",(0,r.jsx)(n.p,{children:"Listing: leapyear function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nleapyear(y)\nreturn y % 4 == 0 && y % 100 != 0 || y % 400 == 0\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Os operadores l\xf3gicos e aritm\xe9ticos do exemplo ",(0,r.jsx)(n.code,{children:"leapyear"})," est\xe3o detalhados nas p\xe1ginas 108 e 104."]}),"\n",(0,r.jsxs)(n.p,{children:["Em geral, fun\xe7\xf5es incluem declara\xe7\xf5es locais e formam um bloco composto. No exemplo a seguir, repare na instru\xe7\xe3o ",(0,r.jsx)(n.code,{children:"assert"})," para impedir expoentes negativos."]}),"\n",(0,r.jsx)(n.p,{children:"Listing: power function (raise to a power)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\npower(x, y)\n{\n    /* returns x raised to the power of y */\n    assert y >= 0\n    new r = 1\n    for (new i = 0; i < y; i++)\n        r *= x\n    return r\n}\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Uma fun\xe7\xe3o pode ter v\xe1rios ",(0,r.jsx)(n.code,{children:"return"})," \u2014usamos isso para sair rapidamente ao detectar erros de par\xe2metros ou situa\xe7\xf5es em que n\xe3o h\xe1 trabalho a fazer. Se a fun\xe7\xe3o retorna um array, todos os ",(0,r.jsx)(n.code,{children:"return"})," devem fornecer arrays do mesmo tamanho e dimens\xf5es."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"The preferred way to declare forward functions is at page 82"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201Cassert\u201D statement: 112"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-argumentos-valor-vs-refer\xeancia",children:"\u2022 Argumentos (valor vs. refer\xeancia)"}),"\n",(0,r.jsxs)(n.p,{children:["No programa a seguir, ",(0,r.jsx)(n.code,{children:"faculty"})," usa seu par\xe2metro em um loop para calcular o fatorial desse n\xfamero. Observe que a fun\xe7\xe3o modifica o argumento."]}),"\n",(0,r.jsx)(n.p,{children:"Listing: faculty.p"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\n/* Calculation of the faculty of a value */\n\nmain()\n{\n    print "Enter a value: "\n    new v = getvalue()\n    new f = faculty(v)\n    printf "The faculty of %d is %d\\n", v, f\n}\n\nfaculty(n)\n{\n    assert n >= 0\n\n    new result = 1\n    while (n > 0)\n        result *= n--\n\n    return result\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["N\xe3o importa qual valor positivo \u201Cn\u201D tinha ao entrar no ",(0,r.jsx)(n.code,{children:"while"}),", ele termina valendo zero. Como ",(0,r.jsx)(n.code,{children:"faculty"})," recebe o par\xe2metro por valor, a altera\xe7\xe3o fica restrita \xe0 fun\xe7\xe3o. ",(0,r.jsx)(n.code,{children:"main"})," passa ",(0,r.jsx)(n.code,{children:"v"}),", mas, ao retornar, ",(0,r.jsx)(n.code,{children:"v"})," continua igual."]}),"\n",(0,r.jsxs)(n.p,{children:["Argumentos que ocupam uma \xfanica c\xe9lula podem ser passados por valor ou refer\xeancia (padr\xe3o \xe9 por valor). Para pass\xe1-los por refer\xeancia, prefixe o nome com ",(0,r.jsx)(n.code,{children:"&"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: swap function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nswap(&a, &b)\n{\n    new temp = b\n    b = a\n    a = temp\n}\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To pass an array to a function, append a pair of brackets to the",(0,r.jsx)(n.br,{}),"\n","argument name. You may optionally indicate the size of the array; doing so improves\nerror checking of the parser."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: addvector function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\naddvector(a[], const b[], size)\n{\n    for (new i = 0; i < size; i++)\n        a[i] += b[i]\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Arrays are always passed by reference. As a side note, array b in the above\nexample does not change in the body of the function. The function argument\nhas been declared as const to make this explicit. In addition to improving\nerror checking, it also allows the pawn parser to generate more efficient code."}),"\n",(0,r.jsxs)(n.p,{children:["To pass an array of literals to a function, use the same syntax as for",(0,r.jsx)(n.br,{}),"\n","array initiallers: a literal string or the series of array indices enclosed in braces\n(see page 99; the ellipsis for progressive initiallers cannot be used). Literal\narrays can only have a single dimension."]}),"\n",(0,r.jsx)(n.p,{children:"The following snippet calls addvector to add five to every element of the array \u201Cvect\u201D:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: addvector usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnew vect[3] = { 1, 2, 3 }\n\naddvector(vect, {5, 5, 5}, 3)\n\n/* vect[] now holds the values 6, 7 and 8 */\n\n"})}),"\n",(0,r.jsx)(n.p,{children:'The invocation of function printf with the string "Hello world\\n" in the first\nubiquitous program is another example of passing a literal array to a function.'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Another example is function JulianToDate at page 13"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Constant variables: 64"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201CHello world\u201D program: 5"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-calling-functions",children:"\u2022 Calling functions"}),"\n",(0,r.jsxs)(n.p,{children:["When inserting a function name with its parameters in a statement or",(0,r.jsx)(n.br,{}),"\n","expression, the function will get executed in that statement/expression.",(0,r.jsx)(n.br,{}),"\n","The statement that refers to the function is the \u201Ccaller\u201D and the function itself,\nat that point, is the \u201Ccallee\u201D: the one being called."]}),"\n",(0,r.jsx)(n.p,{children:"The standard syntax for calling a function is to write the"}),"\n",(0,r.jsx)(n.h3,{id:"-chamando-fun\xe7\xf5es",children:"\u2022 Chamando fun\xe7\xf5es"}),"\n",(0,r.jsxs)(n.p,{children:["Para chamar uma fun\xe7\xe3o, escreva o nome seguido da lista de par\xe2metros entre par\xeanteses. Mesmo que n\xe3o haja argumentos, os par\xeanteses permanecem. O exemplo below mostra como chamar ",(0,r.jsx)(n.code,{children:"power"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"Listing: example program for the power function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\nmain()\n{\n    print "Please give the base value and the power to raise it to:"\n    new base = getvalue()\n    new power = getvalue()\n\n    new result = power(base, power)\n    printf "%d raised to the power %d is %d", base, power, result\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Fun\xe7\xf5es podem retornar valores (como ",(0,r.jsx)(n.code,{children:"sum"}),", ",(0,r.jsx)(n.code,{children:"leapyear"}),", ",(0,r.jsx)(n.code,{children:"power"}),"). ",(0,r.jsx)(n.code,{children:"swap"})," \xe9 um exemplo que n\xe3o retorna. Mesmo quando h\xe1 retorno, o chamador pode ignor\xe1-lo."]}),"\n",(0,r.jsx)(n.p,{children:"Quando o retorno n\xe3o \xe9 utilizado, h\xe1 uma sintaxe alternativa: os par\xeanteses ficam opcionais. No trecho anterior, por exemplo, poder\xedamos escrever:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'printf "%d raised to the power %d is %d", base, power, result'})}),"\n",(0,r.jsxs)(n.p,{children:["em vez de ",(0,r.jsx)(n.code,{children:"printf(...)"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Essa forma \u201Cprocedural\u201D s\xf3 \xe9 v\xe1lida quando:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"o resultado n\xe3o \xe9 usado em express\xf5es;"}),"\n",(0,r.jsxs)(n.li,{children:["o primeiro par\xe2metro n\xe3o come\xe7a com ",(0,r.jsx)(n.code,{children:"("}),";"]}),"\n",(0,r.jsx)(n.li,{children:"o primeiro par\xe2metro est\xe1 na mesma linha do nome (a menos que use par\xe2metros nomeados)."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Ela deixa chamadas como ",(0,r.jsx)(n.code,{children:"print"}),"/",(0,r.jsx)(n.code,{children:"printf"})," mais leg\xedveis, mas \xe9 opcional. Note que, no exemplo, as chamadas a ",(0,r.jsx)(n.code,{children:"getvalue"})," exigem par\xeanteses vazios, j\xe1 que o valor retornado \xe9 armazenado."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Function power: 70"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Functions sum & leapyear: 70"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Function swap: 71"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-par\xe2metros-posicionais-x-nomeados",children:"\u2022 Par\xe2metros posicionais x nomeados"}),"\n",(0,r.jsxs)(n.p,{children:["Nos exemplos anteriores, a ordem dos argumentos era relevante porque cada posi\xe7\xe3o correspondia a um par\xe2metro. Considere ",(0,r.jsx)(n.code,{children:"weekday"})," (que usa a congru\xeancia de Zeller):"]}),"\n",(0,r.jsx)(n.p,{children:"Listing: weekday function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nweekday(month, day, year)\n{\n    /* returns the day of the week: 0=Saturday, 1=Sunday, etc. */\n    if (month <= 2)\n        month += 12, --year\n    new j = year % 100\n    new e = year / 100\n    return (day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Como formatos de data variam (m\xeas/dia/ano nos EUA, dia/m\xeas/ano na Europa, ano/m\xeas/dia em publica\xe7\xf5es ISO etc.), nenhuma ordem \xe9 \u201Cnatural\u201D. Nesses casos, use par\xe2metros nomeados:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: weekday usage \u2014positional parameters"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnew wkday1 = weekday( .month = 12, .day = 31, .year = 1999)\n\nnew wkday2 = weekday( .day = 31, .month = 12, .year = 1999)\n\nnew wkday3 = weekday( .year = 1999, .month = 12, .day = 31)\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Em par\xe2metros nomeados, um ponto (",(0,r.jsx)(n.code,{children:"."}),") antecede o nome do argumento. A express\xe3o \xe0 direita de ",(0,r.jsx)(n.code,{children:"="})," \xe9 associada a esse par\xe2metro (n\xe3o \xe9 uma atribui\xe7\xe3o de fato)."]}),"\n",(0,r.jsx)(n.p,{children:"\xc9 poss\xedvel misturar par\xe2metros posicionais e nomeados, desde que os posicionais venham primeiro."}),"\n",(0,r.jsx)(n.h3,{id:"-valores-padr\xe3o",children:"\u2022 Valores padr\xe3o"}),"\n",(0,r.jsxs)(n.p,{children:["Argumentos podem receber valores padr\xe3o (que devem ser constantes). Basta usar ",(0,r.jsx)(n.code,{children:"="})," ap\xf3s o nome."]}),"\n",(0,r.jsxs)(n.p,{children:["Ao chamar a fun\xe7\xe3o, se quiser \u201Cpular\u201D um argumento com valor padr\xe3o, use o caractere ",(0,r.jsx)(n.code,{children:"_"}),". Placeholders \xe0 direita podem ser omitidos. Por exemplo:"]}),"\n",(0,r.jsx)(n.p,{children:"Listing: increment function \u2014default values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nincrement(&value, incr=1) value += incr\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"the following function calls are all equivalent:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: increment usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nincrement(a)\nincrement(a, \\_)\nincrement(a, 1)\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Valores padr\xe3o para argumentos por refer\xeancia podem tornar entradas opcionais. Se ",(0,r.jsx)(n.code,{children:"divmod"})," retorna quociente e resto pelos par\xe2metros, podemos fazer:"]}),"\n",(0,r.jsx)(n.p,{children:"Listing: divmod function \u2014default values for reference parameters"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\ndivmod(a, b, &quotient=0, &remainder=0)\n{\n    quotient = a / b\n    remainder = a % b\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"With the preceding definition of function divmod, the following function calls\nare now all valid:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: divmod usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnew p, q\n\ndivmod(10, 3, p, q)\ndivmod(10, 3, p, \\_)\ndivmod(10, 3, \\_, q)\ndivmod(10, 3, p)\ndivmod 10, 3, p, q\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Tamb\xe9m podemos definir uma string padr\xe3o para par\xe2metros de array:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: print error function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\nprint_error(const message[], const title[] = "Error: ")\n{\n    print title\n    print message\n    print "\\n"\n}\n\n'})}),"\n",(0,r.jsx)(n.p,{children:"No exemplo a seguir, somamos um array ao outro e, por padr\xe3o, incrementamos os tr\xeas primeiros elementos em 1:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: addvector function, revised"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\naddvector(a[], const b[] = {1, 1, 1}, size = 3)\n{\n    for (new i = 0; i < size; i++)\n    a[i] += b[i]\n}\n\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Public functions do not support default argument values; see page 83"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"-sizeof-em-argumentos-padr\xe3o",children:["\u2022 ",(0,r.jsx)(n.code,{children:"sizeof"})," em argumentos padr\xe3o"]}),"\n",(0,r.jsxs)(n.p,{children:["O valor padr\xe3o de um argumento precisa ser uma constante e \xe9 determinado na declara\xe7\xe3o. A \xfanica exce\xe7\xe3o \xe9 quando usamos ",(0,r.jsx)(n.code,{children:"sizeof"}),", pois nesse caso a avalia\xe7\xe3o ocorre na chamada e considera o tamanho do argumento real (n\xe3o o formal). Assim, o \u201Cvalor padr\xe3o\u201D pode mudar a cada invoca\xe7\xe3o."]}),"\n",(0,r.jsx)(n.p,{children:"Exemplo: sortear dez n\xfameros aleat\xf3rios entre 0 e 51 sem repeti\xe7\xe3o \u2014\xfatil em jogos de cartas. O algoritmo, de Robert W. Floyd, \xe9 eficiente e sem vieses (assumindo que o gerador aleat\xf3rio tamb\xe9m seja)."}),"\n",(0,r.jsx)(n.p,{children:"Listing: randlist.p"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\nmain()\n{\n    new HandOfCards[10]\n    FillRandom(HandOfCards, 52)\n\n    print "A draw of 10 numbers from a range of 0 to 51 \\\n        (inclusive) without duplicates:\\n"\n    for (new i = 0; i < sizeof HandOfCards; i++)\n        printf "%d ", HandOfCards[i]\n}\n\nFillRandom(Series[], Range, Number = sizeof Series)\n{\n    assert Range >= Number          /* cannot select 50 values\n                                     * without duplicates in the\n                                     * range 0..40, for example */\n    new Index = 0\n    for (new Seq = Range - Number; Seq < Range; Seq++)\n    {\n        new Val = random(Seq + 1)\n        new Pos = InSeries(Series, Val, Index)\n        if (Pos >= 0)\n        {\n            Series[Index] = Series[Pos]\n            Series[Pos] = Seq\n        }\n        else\n            Series[Index] = Val\n        Index++\n    }\n}\n\nInSeries(Series[], Value, Top = sizeof Series)\n{\n    for (new i = 0; i < Top; i++)\n        if (Series[i] == Value)\n            return i\n    return -1\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"main"})," declara ",(0,r.jsx)(n.code,{children:"HandOfCards"})," com 10 c\xe9lulas e chama ",(0,r.jsx)(n.code,{children:"FillRandom"})," para preencher com n\xfameros < 52. Repare que apenas dois par\xe2metros s\xe3o passados: o array e o limite \u201C52\u201D. A quantidade (10) \xe9 passada implicitamente."]}),"\n",(0,r.jsxs)(n.p,{children:["Isso acontece porque ",(0,r.jsx)(n.code,{children:"FillRandom"})," define o terceiro par\xe2metro como ",(0,r.jsx)(n.code,{children:"Number = sizeof Series"}),". Gra\xe7as ao caso especial do ",(0,r.jsx)(n.code,{children:"sizeof"}),", o valor padr\xe3o usa o tamanho do argumento real (",(0,r.jsx)(n.code,{children:"HandOfCards"}),"), e n\xe3o o do par\xe2metro formal."]}),"\n",(0,r.jsxs)(n.p,{children:["Dentro de ",(0,r.jsx)(n.code,{children:"FillRandom"}),", contudo, ",(0,r.jsx)(n.code,{children:"sizeof Series"})," ainda retorna zero, pois ",(0,r.jsx)(n.code,{children:"Series"})," foi declarado sem tamanho. Se tiv\xe9ssemos definido ",(0,r.jsx)(n.code,{children:"Series[10]"}),", seria desnecess\xe1rio incluir o par\xe2metro ",(0,r.jsx)(n.code,{children:"Number"}),": o compilador j\xe1 exigiria que o argumento real tivesse o mesmo tamanho."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201Csizeof \u201D operator 109"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201Crandom\u201D is a proposed core function, see page 124"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Array declarations: 64"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Tag names: 68"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-argumentos-com-tags",children:"\u2022 Argumentos com tags"}),"\n",(0,r.jsxs)(n.p,{children:["Uma tag pode preceder o par\xe2metro formal, melhorando a checagem em tempo de compila\xe7\xe3o e servindo como documenta\xe7\xe3o impl\xedcita. Por exemplo, uma fun\xe7\xe3o que calcula ra\xedzes usando ponto fixo pode exigir que o par\xe2metro e o retorno sejam ",(0,r.jsx)(n.code,{children:"Fixed:"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"No c\xf3digo abaixo, usamos o m\xf3dulo de ponto fixo e o algoritmo de bisse\xe7\xe3o. Repare no uso de \u201Coverride\u201D de tags em literais e resultados."}),"\n",(0,r.jsx)(n.p,{children:"Listing: sqroot function \u2014strong tags"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nFixed: sqroot(Fixed: value)\n{\n    new Fixed: low = 0.0\n    new Fixed: high = value\n    while (high - low > Fixed: 1)\n    {\n        new Fixed: mid = (low + high) >> 1\n        if (fmul(mid, mid) < value)\n            low = mid\n        else\n            high = mid\n    }\n    return low\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"With the above definition, the pawn parser issues a diagnostic if one calls the\nsqroot function with a parameter with a tag different from \u201CFixed:\u201D, or when\nit tries to store the function result in a variable with a \u201Cnon-Fixed:\u201D tag."}),"\n",(0,r.jsx)(n.p,{children:"O algoritmo de bisse\xe7\xe3o \xe9 parecido com busca bin\xe1ria: reduz pela metade o intervalo poss\xedvel a cada passo. M\xe9todos como Newton-Raphson (substitui\xe7\xe3o sucessiva) convergem mais r\xe1pido, mas definir o crit\xe9rio de parada \xe9 mais complicado. Implementa\xe7\xf5es modernas combinam bisse\xe7\xe3o e Newton-Raphson."}),"\n",(0,r.jsx)(n.p,{children:"Para arrays, os \xedndices tamb\xe9m podem ter tags. Veja a fun\xe7\xe3o que calcula a interse\xe7\xe3o entre dois ret\xe2ngulos:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: intersection function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\nintersection(dest[rectangle], const src1[rectangle], const src2[rectangle])\n{\n    if (src1[right] > src2[left] && src1[left] < src2[right]\n    && src1[bottom] > src2[top] && src1[top] < src2[bottom])\n    {\n        \\* there is an intersection, calculate it using the "min" and\n         *"max" functions from the "core" library, see page 124. */\n\n        dest[left] = max(src1[left], src2[left])\n        dest[right] = min(src1[right], src2[right])\n        dest[top] = max(src1[top], src2[top])\n        dest[bottom] = min(src1[bottom], src2[bottom])\n        return true\n    }\n    else\n    {\n        /* "src1" and "src2" do not intersect */\n        dest = { 0, 0, 0, 0 }\n        return false\n    }\n}\n\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Fixed point arithmetic: 90; see also the application note \u201CFixed Point Support Library\u201D"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"For the \u201Crectangle\u201D tag, see page 68"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-argumentos-vari\xe1veis",children:"\u2022 Argumentos vari\xe1veis"}),"\n",(0,r.jsxs)(n.p,{children:["Fun\xe7\xf5es com n\xfamero vari\xe1vel de argumentos usam ",(0,r.jsx)(n.code,{children:"..."})," para indicar o in\xedcio da lista vari\xe1vel. Os argumentos s\xe3o acessados pelas fun\xe7\xf5es ",(0,r.jsx)(n.code,{children:"numargs"}),", ",(0,r.jsx)(n.code,{children:"getarg"}),", ",(0,r.jsx)(n.code,{children:"setarg"})," (p\xe1gina 124)."]}),"\n",(0,r.jsx)(n.p,{children:"O exemplo a seguir calcula a soma de todos os par\xe2metros:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nsum(...)\n{\n    new result = 0\n    for (new i = 0; i < numargs(); ++i)\n        result += getarg(i)\n    return result\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"This function could be used in:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: sum function usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnew v = sum(1, 2, 3, 4, 5)\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Podemos usar uma tag antes das retic\xeancias para obrigar que todos os argumentos seguintes tenham a mesma tag. Fora isso, n\xe3o h\xe1 checagem nessa lista \u2014use com cuidado."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getarg"})," e ",(0,r.jsx)(n.code,{children:"setarg"})," assumem que o argumento foi passado por refer\xeancia. Ao us\xe1-las em par\xe2metros \u201Cnormais\u201D (fora da lista vari\xe1vel), tenha cautela, pois nem o compilador nem a VM verificam isso. Os par\xe2metros reais passados como parte da lista vari\xe1vel s\xe3o sempre por refer\xeancia."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Tag names: 68"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-regras-de-coer\xe7\xe3o",children:"\u2022 Regras de coer\xe7\xe3o"}),"\n",(0,r.jsx)(n.p,{children:"Quando um par\xe2metro \xe9 declarado como valor, o chamador pode passar:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"um valor (passado por valor);"}),"\n",(0,r.jsx)(n.li,{children:"uma refer\xeancia (o conte\xfado referenciado \xe9 passado);"}),"\n",(0,r.jsx)(n.li,{children:"um elemento de array indexado (tratado como valor)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Quando o par\xe2metro \xe9 refer\xeancia, o chamador pode fornecer:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"um valor (o endere\xe7o \xe9 passado);"}),"\n",(0,r.jsx)(n.li,{children:"uma refer\xeancia (passada por valor, pois j\xe1 \xe9 o tipo esperado);"}),"\n",(0,r.jsx)(n.li,{children:"um elemento de array."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Para par\xe2metros array, o chamador pode passar:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"um array com mesmas dimens\xf5es (passa-se o endere\xe7o inicial);"}),"\n",(0,r.jsx)(n.li,{children:"um elemento indexado (passa-se o endere\xe7o daquele elemento)."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-recurs\xe3o",children:"\u2022 Recurs\xe3o"}),"\n",(0,r.jsx)(n.p,{children:"Os exemplos de fatorial e Fibonacci vieram na forma de la\xe7os, talvez sugerindo que pawn n\xe3o suporta recurs\xe3o. Mas suporta \u2014a quest\xe3o \xe9 que esses casos s\xe3o ruins para ilustr\xe1-la (fatorial \xe9 mais claro com loop; Fibonacci recursivo recalcula muitas vezes o mesmo valor)."}),"\n",(0,r.jsx)(n.p,{children:"Um exemplo cl\xe1ssico de recurs\xe3o \xe9 o problema das Torres de Han\xf3i:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: hanoi.p"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\n/* The Towers of Hanoi, a game solved through recursion */\n\nmain()\n{\n    print "How many disks: "\n    new disks = getvalue()\n    move 1, 3, 2, disks\n}\n\nmove(from, to, spare, numdisks)\n{\n    if (numdisks > 1)\n        move from, spare, to, numdisks-1\n    printf "Move disk from pillar %d to pillar %d\\n", from, to\n    if (numdisks > 1)\n        move spare, to, from, numdisks-1\n}\n\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201Cfaculty\u201D: 71"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201Cfibonacci\u201D: 11"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"There exists an intriguing iterative solution to the Towers of Hanoi."})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-declara\xe7\xf5es-antecipadas",children:"\u2022 Declara\xe7\xf5es antecipadas"}),"\n",(0,r.jsx)(n.p,{children:"Na implementa\xe7\xe3o de refer\xeancia, fun\xe7\xf5es comuns n\xe3o precisam ser declaradas antes do uso\u2217. Operadores definidos pelo usu\xe1rio, por outro lado, devem ser declarados previamente."}),"\n",(0,r.jsxs)(n.p,{children:["O uso t\xedpico \xe9 coloc\xe1-los em arquivos ",(0,r.jsx)(n.code,{children:".inc"}),", mas \xe0s vezes \xe9 necess\xe1rio (ou conveniente) declarar primeiro e implementar depois \u2014especialmente para operadores \u201Cproibidos\u201D."]}),"\n",(0,r.jsxs)(n.p,{children:["Para criar uma declara\xe7\xe3o antecipada, coloque ",(0,r.jsx)(n.code,{children:"forward"})," antes do cabe\xe7alho. Por compatibilidade (e semelhan\xe7a com C/C++), tamb\xe9m \xe9 aceit\xe1vel escrever o cabe\xe7alho seguido de ",(0,r.jsx)(n.code,{children:";"}),". A implementa\xe7\xe3o completa vem posteriormente. Classificadores de estado s\xe3o ignorados em declara\xe7\xf5es antecipadas."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h6,{id:"-other-implementations-of-the-pawn-language-if-they-exist-may-use-single-pass-parsers-requiring-functions-to-be-defined-before-use",children:"\u2217 Other implementations of the Pawn language (if they exist) may use \u201Csingle pass\u201D parsers, requiring functions to be defined before use."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Forbidden userdefined operators: 92"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-classificadores-de-estado",children:"\u2022 Classificadores de estado"}),"\n",(0,r.jsxs)(n.p,{children:["Todas as fun\xe7\xf5es (exceto nativas) podem ter um atributo de estado: uma lista entre ",(0,r.jsx)(n.code,{children:"< >"})," ap\xf3s o cabe\xe7alho. Quando o estado pertence a um aut\xf4mato n\xe3o padr\xe3o, prefixe com ",(0,r.jsx)(n.code,{children:"automato:estado"})," (ex.: ",(0,r.jsx)(n.code,{children:"parser:slash"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"Se houver estados diferentes, precisamos fornecer implementa\xe7\xf5es separadas para cada conjunto, todas com o mesmo cabe\xe7alho (sem contar o classificador)."}),"\n",(0,r.jsxs)(n.p,{children:["Uma sintaxe especial permite usar ",(0,r.jsx)(n.code,{children:"<>"})," vazio para definir a fun\xe7\xe3o \u201Cfallback\u201D, que atende a todos os estados n\xe3o cobertos nas demais varia\xe7\xf5es."]}),"\n",(0,r.jsxs)(n.h3,{id:"-fun\xe7\xf5es-public-e-main",children:["\u2022 Fun\xe7\xf5es ",(0,r.jsx)(n.code,{children:"public"})," e ",(0,r.jsx)(n.code,{children:"main"})]}),"\n",(0,r.jsxs)(n.p,{children:["Programas standalone precisam ter ",(0,r.jsx)(n.code,{children:"main"})," (sem par\xe2metros), ponto de partida da execu\xe7\xe3o."]}),"\n",(0,r.jsxs)(n.p,{children:["Bibliotecas n\xe3o exigem ",(0,r.jsx)(n.code,{children:"main"}),", mas devem possuir pelo menos uma fun\xe7\xe3o p\xfablica. ",(0,r.jsx)(n.code,{children:"main"})," \xe9 o entry point prim\xe1rio; fun\xe7\xf5es ",(0,r.jsx)(n.code,{children:"public"})," fornecem pontos alternativos. A VM pode iniciar por uma fun\xe7\xe3o p\xfablica e, em bibliotecas, ",(0,r.jsx)(n.code,{children:"main"})," pode servir para inicializa\xe7\xf5es."]}),"\n",(0,r.jsxs)(n.p,{children:["Para declarar uma fun\xe7\xe3o p\xfablica, prefixe o nome com ",(0,r.jsx)(n.code,{children:"public"}),". Exemplo: um editor de texto poderia chamar ",(0,r.jsx)(n.code,{children:"onkey"})," a cada tecla digitada para que o script modifique/rejeite caracteres. A fun\xe7\xe3o\nonkey abaixo substituiria cada caractere \u201C~\u201D (c\xf3digo 126 no conjunto\nde caracteres ISO Latin\u20111) pelo c\xf3digo de \u201Cespa\xe7o duro\u201D na tabela ANSI:"]}),"\n",(0,r.jsx)(n.p,{children:"Listing: onkey function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\npublic onkey(keycode)\n{\n    if (key==\u2019~\u2019)\n        return 160 /* replace ~ by hard space (code 160 in Latin-1) */\n    else\n        return key /* leave other keys unaltered */\n}\n\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Example: 40"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Functions whose name starts with the \u201C@\u201D symbol are also public. So\nan alternative way to write the public function onkey function is:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: @onkey function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\n@onkey(keycode)\n    return key==\u2019~\u2019 ? 160 : key\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The \u201C@\u201D character, when used, becomes part of the function name; that is, in\nthe last example, the function is called \u201C@onkey\u201D. The host application decides\non the names of the public functions that a script may implement."}),"\n",(0,r.jsx)(n.p,{children:"Arguments of a public function may not have default values. A public func-\ntion interfaces the host application to the pawn script. Hence, the arguments\npassed to the public function originate from the host application, and the host\napplication cannot know what \u201Cdefault values\u201D the script writer plugged for\nfunction arguments \u2014which is why the pawn parser flags the use of default\nvalues for arguments of public functions as an error. The issue of default\nvalues in public function arguments only pops up in the case that you wish to call public functions from the script itself."}),"\n",(0,r.jsx)(n.h3,{id:"-static-functions",children:"\u2022 Static functions"}),"\n",(0,r.jsx)(n.p,{children:"When the function name is prefixed with the keyword static, the scope of the\nfunction is restricted to the file that the function resides in."}),"\n",(0,r.jsx)(n.p,{children:"The static attribute can be combined with the \u201Cstock\u201D attribute."}),"\n",(0,r.jsx)(n.h3,{id:"-stock-functions",children:"\u2022 Stock functions"}),"\n",(0,r.jsx)(n.p,{children:"A \u201Cstock\u201D function is a function that the pawn parser must \u201Cplug into\u201D the\nprogram when it is used, and that it may simply \u201Cremove\u201D from the program\n(without warning) when it is not used. Stock functions allow a compiler or\ninterpreter to optimize the memory footprint and the file size of a (compiled)\npawn program: any stock function that is not referred to, is completely skipped\n\u2014as if it were lacking from the source file."}),"\n",(0,r.jsxs)(n.p,{children:["A typical use of stock functions, hence, is in the creation of a set of\n\u201Clibrary\u201D functions. A collection of general purpose functions, all marked as \u201Cstock\u201D may\nbe put in a separate include file, which is then included in any pawn",(0,r.jsx)(n.br,{}),"\n","script. Only the library functions that are actually used get \u201Clinked\u201D in."]}),"\n",(0,r.jsx)(n.p,{children:"To declare a stock function, prefix the function name with the keyword stock.\nPublic functions and native functions cannot be declared \u201Cstock\u201D."}),"\n",(0,r.jsxs)(n.p,{children:["When a stock function calls other functions, it is usually a good practice to\ndeclare those other functions as \u201Cstock\u201D too \u2014with the exception of",(0,r.jsx)(n.br,{}),"\n","native functions. Similarly, any global variables that are used by a stock\nfunction should in most cases also be defined \u201Cstock\u201D. The removal of unused (stock)\nfunctions can cause a chain reaction in which other functions and global vari-\nables are not longer accessed either. Those functions are then removed as well,\nthereby continuing the chain reaction until only the functions that are used,\ndirectly or indirectly, remain."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Default values of function arguments: 75"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Public variables can be declared \u201Cstock\u201D"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Stock variables: 63"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-native-functions",children:"\u2022 Native functions"}),"\n",(0,r.jsx)(n.p,{children:"A pawn program can call application-specific functions through a \u201Cnative function\u201D.\nThe native function must be declared in the pawn program by means\nof a function prototype. The function name must be preceded by the keyword native."}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnative getparam(a[], b[], size)\n\nnative multiply_matrix(a[], b[], size)\n\nnative openfile(const name[])\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The names \u201Cgetparam\u201D, \u201Cmultiply_matrix\u201D and \u201Copenfile\u201D are the internal\nnames of the native functions; these are the names by which the",(0,r.jsx)(n.br,{}),"\n","functions are known in the pawn program. Optionally, you may also set an external\nname for the native function, which is the name of the function as the \u201Chost application\u201D knows it.\nTo do so, affix an equal sign to the function prototype followed by the external name. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnative getparam(a[], b[], size) = host_getparam\n\nnative multiply_matrix(a[], b[], size) = mtx_mul\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When a native function returns an array, the dimensions and size of the ar-\nray must be explicitly declared. The array specification occurs between",(0,r.jsx)(n.br,{}),"\n","the function name and the parameter list. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nenum rect { left, top, right, bottom }\nnative intersect[rect](src1[rect], src2[rect])\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Unless specified explicitly, the external name is equal to the internal name of\na native function. One typical use for explicit external names is to set a\nsymbolic name for a user-defined operator that is implemented as a native function."}),"\n",(0,r.jsx)(n.p,{children:"See the \u201CImplementor\u2019s Guide\u201D for implementing native functions in C/C++(on the \u201Chost application\u201D side)."}),"\n",(0,r.jsx)(n.p,{children:"Native functions may not have state specifiers."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"An example of a native user-defined operator is on page 89"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-user-defined-operators",children:"\u2022 User-defined operators"}),"\n",(0,r.jsx)(n.p,{children:"The only data type of pawn is a \u201Ccell\u201D, typically a 32-bit number or bit\npattern."}),"\n",(0,r.jsx)(n.p,{children:"Tags: 68 The meaning of a value in a cell depends on the particular application \u2014it need\nnot always be a signed integer value. pawn allows to attach a \u201Cmeaning\u201D to a cell with its \u201Ctag\u201D mechanism."}),"\n",(0,r.jsxs)(n.p,{children:["Based on tags, pawn also allows you to redefine operators for cells",(0,r.jsx)(n.br,{}),"\n","with a specific purpose. The example below defines a tag \u201Cones\u201D and an",(0,r.jsx)(n.br,{}),"\n","operator to add two \u201Cones\u201D values together (the example also implements",(0,r.jsx)(n.br,{}),"\n","operators for subtraction and negation). The example was inspired by the checksum\nalgorithm of several protocols in the TCP/IP protocol suite: it simulates one\u2019s\ncomplement arithmetic by adding the carry bit of an arithmetic overflow back\nto the least significant bit of the value."]}),"\n",(0,r.jsx)(n.p,{children:"Listing: ones.p"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'\nforward ones: operator+(ones: a, ones: b)\nforward ones: operator-(ones: a, ones: b)\nforward ones: operator-(ones: a)\n\nmain()\n{\n    new ones: chksum = ones: 0xffffffff\n    print "Input values in hexadecimal, zero to exit\\n"\n\n    new ones: value\n    do\n    {\n        print ">> "\n        value = ones: getvalue(.base=16)\n        chksum = chksum + value\n        printf "Checksum = %x\\n", chksum\n    }\n    while (value)\n}\n\nstock ones: operator+(ones: a, ones: b)\n{\n    const ones: mask = ones: 0xffff                 /* word mask */\n    const ones: shift = ones: 16                    /* word shift */\n\n    /* add low words and high words separately */\n    new ones: r1 = (a & mask) + (b & mask)\n    new ones: r2 = (a >>> shift) + (b >>> shift)\n\n    new ones: carry\n    restart:                                        /* code label (goto target) */\n\n    \\* add carry of the new low word to the high word, then\n    * strip it from the low word */\n\n    carry = (r1 >>> shift)\n    r2 += carry\n    r1 &= mask\n\n    \\* add the carry from the new high word back to the low\n    * word, then strip it from the high word */\n\n    carry = (r2 >>> shift)\n    r1 += carry\n    r2 &= mask\n\n    \\* a carry from the high word injected back into the low\n    * word may cause the new low to overflow, so restart in that case */\n\n    if (carry)\n        goto restart\n    return (r2 << shift) | r1\n}\n\nstock ones: operator-(ones: a)\n    return (a == ones: 0xffffffff) ? a : ~a\n\nstock ones: operator-(ones: a, ones: b)\n    return a + -b\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The notable line in the example is the line \u201Cchksum = chksum + value\u201D in\nthe loop in function main. Since both the variables chksum and value have\nthe tag ones, the \u201C+\u201D operator refers to the user-defined operator",(0,r.jsx)(n.br,{}),"\n","(instead of the default \u201C+\u201D operator). User-defined operators are merely a notational\nconvenience. The same effect is achieved by calling functions explicitly."]}),"\n",(0,r.jsxs)(n.p,{children:["The definition of an operator is similar to the definition of a function, with\nthe difference that the name of the operator is composed by the keyword \u201Copera-\ntor\u201D and the character of the operator itself. In the above example, both the\nunary \u201C-\u201D and the binary \u201C-\u201D operators are redefined. An operator function\nfor a binary operator must have two arguments, one for an unary",(0,r.jsx)(n.br,{}),"\n","operator must have one argument. Note that the binary \u201C-\u201D operator adds the two val-\nues together after inverting the sign of the second operand. The subtraction"]}),"\n",(0,r.jsx)(n.p,{children:"operator thereby refers to both the user-defined \u201Cnegation\u201D (unary \u201C-\u201D) and addition operators."}),"\n",(0,r.jsx)(n.p,{children:"A redefined operator must adhere to the following restrictions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A user-defined operator must be declared before use (this is in contrast to \u201Cnormal\u201D functions): either put the implementation of the user-defined operator above the functions that use it, or add a forward declaration near the top of the file."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Only the following operators may be redefined: +, -, *, /, %, ++, --, ==, !=, <, > , <=, >=, ! and =. That is, the sets of arithmetic and relational operators can be overloaded, but the bitwise operators and the logical operators cannot. The = and ! operators are a special case."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"You cannot invent new operators; you cannot define operator \u201C#\u201D for example."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The precedence level and associativity of the operators, as well as their \u201Carity\u201D remain as defined. You cannot make an unary \u201C+\u201D operator, for example."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The return tag of the relational operators and of the \u201C!\u201D operator must be \u201Cbool:\u201D."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The return tag of the arithmetic operators is at your choosing, but you cannot redefine an operator that is identical to another operator except for its return tag. For example, you cannot make both ",(0,r.jsx)(n.code,{children:"alpha: operator+(alpha: a, alpha: b)"})," and ",(0,r.jsx)(n.code,{children:"beta: operator+(alpha: a, alpha: b)"})," (The assignment operator is an exception to this rule.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"PAWN already defines operators to work on untagged cells, you cannot redefine the operators with only arguments without tags."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The arguments of the operator function must be non-arrays passed by value. You cannot make an operator work on arrays."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In the example given above, both arguments of the binary operators have the\nsame tag. This is not required; you may, for example, define a",(0,r.jsx)(n.br,{}),"\n","binary \u201C+\u201D operator that adds an integer value to a \u201Cones:\u201D number."]}),"\n",(0,r.jsx)(n.p,{children:"Au fond, the operation of the pawn parser is to look up the tag(s)\nof the operand(s) that the operator works on and to look up whether a user-defined\noperator exists for the combination of the operator and the tag(s). However,\nthe parser recognizes special situations and provides the following features:"}),"\n",(0,r.jsxs)(n.p,{children:["The parser recognizes operators like \u201C+=\u201D as a sequence of \u201C+\u201D and",(0,r.jsx)(n.br,{}),"\n","\u201C=\u201D and it will call a user-defined operator \u201C+\u201D if available and/or a user-defined\noperator \u201C=\u201D. In the example program, the line \u201Cchksum = chksum + value\u201D\nmight have been abbreviated to \u201Cchksum += value\u201D."]}),"\n",(0,r.jsx)(n.p,{children:"The parser recognizes commutative operators (\u201C+\u201D, \u201C*\u201D, \u201C==\u201D, and \u201C!=\u201D)\nand it will swap the operands of a commutative operator if that produces\na fit with a user-defined operator. For example, there is usually no need to implement both"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"ones:operator+(ones:a, b)"})}),"\n",(0,r.jsx)(n.p,{children:"and"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"ones:operator+(a, ones:b)"})}),"\n",(0,r.jsx)(n.p,{children:"(implementing both functions is valid, and it is useful in case the user-defined\noperator should not be commutative)."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Prefix and postfix operators are handled automatically. You only need to define one user operator for the \u201C++\u201D and \u201C--\u201D operators for a tag."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The parser calls the \u201C!\u201D operator implicitly in case of a test without explicit comparison. For example, in the statement \u201Cif (var) ...\u201D when \u201Cvar\u201D has tag \u201Cones:\u201D, the user-defined operator \u201C!\u201D will be called for var. The \u201C!\u201D operator thus doubles as a \u201Ctest for zero\u201D operator. (In one\u2019s complement arithmetic, both the \u201Call-ones\u201D and the \u201Call-zeros\u201D bit patterns represent zero.)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The user-defined assignment operator is implicitly called for a function argument that is passed \u201Cby value\u201D when the tag names of the formal and the actual arguments match the tag names of the left and right hand sides of the operator. In other words, the pawn parser simulates that \u201Cpass by value\u201D happens through assignment. The user-defined operator is not called for function arguments that are passed \u201Cby reference\u201D."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If you wish to forbid an operation, you can \u201Cforward declare\u201D the operator without ever defining it (see page 82). This will flag an error when the user-defined operator is invoked. For example, to forbid the \u201C%\u201D operator (remainder after division) on floating point values, you can add the line: ",(0,r.jsx)(n.code,{children:"forward Float: operator%(Float: a, Float: b)"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"User-defined operators can optionally be declared \u201Cstock\u201D or \u201Cnative\u201D. In the case of a native operator function, the definition should include an external name. For example (when, on the host\u2019s side, the native function is called float_add):"}),"\n",(0,r.jsx)(n.p,{children:"Listing: native operator+ function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnative Float: operator+(Float: val, Float: val) = float_add\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The user-defined assignment operator is a special case, because it is an\noperator that has a side effect. Although the operator has the appearance of a binary\noperator, its \u201Cexpression result\u201D is the value at the right hand \u2014the assignment\noperator would be a \u201Cnull\u201D-operator if it weren\u2019t for its side-effect. In pawn\na user-defined assignment operator is declared as:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: operator= function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nones: operator=(a)\n\nreturn ones: ( (a >= 0) ? a : ~(-a) )\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The user-defined \u201C=\u201D operator looks like a unary operator in this\ndefinition, but it is a special case nevertheless. In contrast to the other\noperators, the tag of the return value for the user-defined operator is important: the pawn\nparser uses the tags of the argument and the return value to find a matching user-defined operator."}),"\n",(0,r.jsxs)(n.p,{children:["The example function above is a typical application for a user-defined assign-\nment operator: to automatically coerce/convert an untagged value to a tagged\nvalue, and to optionally change the memory representation of the value in the\nprocess. Specifically, the statement \u201Cnew ones",":A"," = -5\u201D causes the user-defined\noperator to run, and for the constant -5 the operator will return \u201C~(- -5)\u201D, or ~5, or \u22126.\u2217"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Tags: 68"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Forward declaration: 82"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"\u201CCall by value\u201D versus \u201Ccall by reference\u201D: 71"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Native functions: 85"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"Rational literals: 98"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"#pragma rational: 121"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-floating-point-and-fixed-point-arithmetic",children:"\u2022 Floating point and fixed point arithmetic"}),"\n",(0,r.jsx)(n.p,{children:"pawn only has intrinsic support for integer arithmetic (the -domain: \u201Cwhole\nnumbers\u201D, both positive and negative). Support for floating point arithmetic\nor fixed point arithmetic must be implemented through (native) functions.\nUser operators, then, allow a more natural notation of expressions with fixed or floating point numbers."}),"\n",(0,r.jsx)(n.p,{children:"The pawn parser has support for literal values with a fractional part, which it\ncalls \u201Crational numbers\u201D. Support for rational literals must be enabled explic-\nitly with a #pragma. The #pragma indicates how the rational numbers must\nbe stored \u2014floating point or fixed point. For fixed point rational values, the\n#pragma also specifies the precision in decimals. Two examples for the #pragma are:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\n#pragma rational Float /* floating point format */\n#pragma rational Fixed(3) /* fixed point, with 3 decimals */\n\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h6,{id:"-modern-cpus-use-twos-complement-integer-arithmetic-for-positive-values-the-bitwise-representation-of-a-value-is-the-same-in-ones-complement-and-twos-complement-but-the-representations-differ-for-negative-values-for-instance-the-same-bit-pattern-that-means--5-in-ones-complement-stands-for--6-in-twos-complement",children:"\u2217 Modern CPUs use two\u2019s complement integer arithmetic. For positive values, the bitwise representation of a value is the same in one\u2019s complement and two\u2019s complement, but the representations differ for negative values. For instance, the same bit pattern that means -5 in one\u2019s complement stands for -6 in two\u2019s complement."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Since a fixed point value must still fit in a cell, the number of decimals\nhas a direct influence of the range of a fixed point value. For a fixed point value\nwith 3 decimals, the range would be \u22122, 147, 482 . . . + 2, 147, 482."}),"\n",(0,r.jsxs)(n.p,{children:["The format for a rational number may only be specified once for the entire\npawn program. In an implementation one typically chooses either",(0,r.jsx)(n.br,{}),"\n","floating point support or fixed point support. As stated above, for the actual imple-\nmentation of the floating point or fixed point arithmetic, pawn requires the\nhelp of (native) functions and user-defined operators. A good place to put\nthe #pragma for rational number support would be in the include file that",(0,r.jsx)(n.br,{}),"\n","also defines the functions and operators."]}),"\n",(0,r.jsx)(n.p,{children:"The include file \u2020 for fixed point arithmetic contains definitions like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnative Fixed: operator\\*(Fixed: val1, Fixed: val2) = fmul\nnative Fixed: operator/(Fixed: val1, Fixed: val2) = fdiv\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The user-defined operators for multiplication and division of two fixed\npoint numbers are aliased directly to the native functions fmul and fdiv. The host\napplication must, then, provide these native functions."}),"\n",(0,r.jsx)(n.p,{children:"Another native user-defined operator is convenient to transform an integer to\nfixed point automatically, if it is assigned to a variable tagged as \u201CFixed:\u201D:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nnative Fixed: operator=(oper) = fixed\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"With this definition, you can say \u201Cnew Fixed: fract = 3\u201D and the value\nwill be transformed to 3.000 when it is stored in variable fract. As explained\nin the section on user-defined operators, the assignment operator also runs for\nfunction arguments that are passed by value. In the expression \u201Cnew Fixed:\nroot = sqroot(16)\u201D (see the implementation of function sqroot on page 79),\nthe user-defined assignment operator is called on the argument 16."}),"\n",(0,r.jsx)(n.p,{children:"For adding two fixed point values together, the default \u201C+\u201D operator is suffi-\ncient, and the same goes for subtraction. Adding a normal (integer) number\nto a fixed point number is different: the normal value must be scaled before\nadding it. Hence, the include file implements operators for that purpose too:"}),"\n",(0,r.jsx)(n.h6,{id:"-see-the-application-note-fixed-point-support-library-for-where-to-obtain-the-include-file",children:"\u2020 See the application note \u201CFixed Point Support Library\u201D for where to obtain the include file."}),"\n",(0,r.jsx)(n.p,{children:"Listing: additive operators, commutative and non-commutative"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nstock Fixed: operator+(Fixed: val1, val2)\n    return val1 + fixed(val2)\n\nstock Fixed: operator-(Fixed: val1, val2)\n    return val1 - fixed(val2)\n\nstock Fixed: operator-(val1, Fixed: val2)\n    return fixed(val1) - val2\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The \u201C+\u201D operator is commutative, so one implementation handles both cases.\nFor the \u201C-\u201D operator, both cases must be implemented separately."}),"\n",(0,r.jsx)(n.p,{children:"Finally, the include file forbids the use of the modulus operator (\u201C%\u201D) on fixed\npoint values: the modulus is only applicable to integer values:"}),"\n",(0,r.jsx)(n.p,{children:"Listing: forbidden operators on fixed point values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"\nforward Fixed: operator%(Fixed: val1, Fixed: val2)\nforward Fixed: operator%(Fixed: val1, val2)\nforward Fixed: operator%(val1, Fixed: val2)\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Because of the presence of the (forward) declaration of the operator, the pawn\nparser will attempt to use the user-defined operator rather than the default\n\u201C%\u201D operator. By not implementing the operator, the parser will subsequently issue an error message.\n",(0,r.jsx)(n.code,{children:"User-defined operators: 86"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-call-by-value-and-call-by-reference",children:"\u2022 Call by Value and Call by Reference"}),"\n",(0,r.jsx)(n.p,{children:"In Pawn, function arguments can be passed in two ways: by value and by reference."}),"\n",(0,r.jsx)(n.h4,{id:"call-by-value",children:"Call by value"}),"\n",(0,r.jsx)(n.p,{children:"In this method, the value of the variable is passed to the function. A copy of the variable is created and the function operates on the copy, not the original variable. Any changes made to the variable inside the function do not affect the original variable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"swap(a, b){\n	new c = a;\n	a = b;\n	b = c;\n}\n\nmain(){\n	new x = 10, y = 20;\n	printf(\"The value of x is %d and value of y is %d, before calling 'swap'.\", x, y);\n	swap(x, y);\n	printf(\"The value of x is %d and value of y is %d, after calling 'swap'.\", x, y);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Output"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"The value of x is 10 and value of y is 20, before calling 'swap'.\nThe value of x is 10 and value of y is 20, after calling 'swap'.\n"})}),"\n",(0,r.jsx)(n.h4,{id:"call-by-reference",children:"Call by reference"}),"\n",(0,r.jsx)(n.p,{children:"In this method, the address of the variable is passed to the function. The function operates on the original variable and any changes made to the variable inside the function are reflected in the original variable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"swap(&a, &b){\n	new c = a;\n	a = b;\n	b = c;\n}\n\nmain(){\n	new x = 10, y = 20;\n	printf(\"The value of x is %d and value of y is %d, before calling 'swap'.\", x, y);\n	swap(x, y);\n	printf(\"The value of x is %d and value of y is %d, after calling 'swap'.\", x, y);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Output"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"The value of x is 10 and value of y is 20, before calling 'swap'.\nThe value of x is 20 and value of y is 10, after calling 'swap'.\n"})}),"\n",(0,r.jsx)(n.h3,{id:"-recursion--function-recursion",children:"\u2022 Recursion / Function Recursion"}),"\n",(0,r.jsx)(n.p,{children:"Recursion in programming refers to the process of a function calling itself in order to solve a problem. It's a fundamental concept used to solve problems that can be broken down into smaller instances of the same problem. Recursion consists of two main components: base cases and recursive cases."}),"\n",(0,r.jsx)(n.h5,{id:"base-case",children:"Base Case:"}),"\n",(0,r.jsx)(n.p,{children:"Every recursive function should have one or more base cases. A base case is a condition under which the function stops calling itself and returns a result directly. Without base cases, the recursion would continue indefinitely, causing a stack overflow. Read Stack/Heap section to know more about it."}),"\n",(0,r.jsx)(n.h5,{id:"recursive-case",children:"Recursive Case:"}),"\n",(0,r.jsx)(n.p,{children:"The recursive case is where the function calls itself to solve a smaller instance of the problem. Each recursive call should bring the problem closer to a base case."}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'stock factorial(n) {\n    // Base case: factorial of 0 is 1\n    if (n == 0) {\n        return 1;\n    }\n    // Recursive case: n! = n * (n - 1)!\n    else {\n        return n * factorial(n - 1);\n    }\n}\nmain() {\n    new num = 3;\n    new result = factorial(num);\n    printf("Factorial of %d is %d", num, result); // Output: Factorial of 3 is 6\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"demonstrate-the-output",children:"Demonstrate the Output"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"main() \\\\ main function from where execution of program starts\nnew num = 3; \\\\ creates a num variable\nnew result = factorial(num); \\\\ create a result variable and calls the factorial() with passing value of num, factorial(5)\nfactorial(3) \\\\ factorial initiate\n   if(3 == 0) \\\\ checks the condition which is false\n   else{ 3 * factorial(3-1) } \\\\ 3 * and calls the factorial(2)\n      factorial(2) \\\\ factorial initiate again\n         if(2 == 0) \\\\ checks the condition which is false\n         else{ 2 * factorial(2-1) } \\\\ 3 * 2 * and calls the factorial(1)\n            factorial(1) \\\\ factorial initiate again\n            if(1 == 0) \\\\ checks the condition which is false\n            else{ 1 * factorial(1-1) } \\\\ 3 * 2 * 1 and calls the factorial(0)\n 	       factorial(0) \\\\ factorial initiate again\n               if(0 == 0) return 1 \\\\ checks the conition which is true and return 1\n		\\\\ at the final call 3 * 2 * 1 * 1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"stack-memory",children:"Stack Memory"}),"\n",(0,r.jsx)(n.p,{children:"The stack is a region of memory used for storing local variables, function call information, and control flow data. It operates in a Last-In-First-Out (LIFO) manner, which means that the last item pushed onto the stack is the first one to be popped off."}),"\n",(0,r.jsx)(n.h4,{id:"example-stack-overflow",children:"Example (Stack Overflow)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'#pragma dynamic 35 // (35 * 4 bytes, a cell size) #pragma dynamic [cells] helps to modify the size of stack, read docs/scripting/language/Directives to know more about #pragma\nmain(){\n	grow_stack(1);\n}\ngrow_stacK(n){ // recursive function\n	printf("N: %d", n);\n	grow_stacK(n+1);\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"output",children:"Output"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"N: 1\nN: 2\nN: 3\n.. .\nStack/heap collision (insufficient stack size)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://i.imgur.com/ZaIVUkJ.png",alt:"Stack"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"00-Contents",children:"Go Back to Contents"})})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},50065:function(e,n,a){a.d(n,{Z:()=>t,a:()=>s});var o=a(67294);let r={},i=o.createContext(r);function s(e){let n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);