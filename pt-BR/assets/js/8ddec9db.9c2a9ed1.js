"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["84791"],{1042:function(e,a,o){o.r(a),o.d(a,{frontMatter:()=>i,toc:()=>d,default:()=>c,metadata:()=>r,assets:()=>m,contentTitle:()=>t});var r=JSON.parse('{"id":"tutorials/AdvancedStructures","title":"Estruturas Avan\xe7adas","description":"Manipula\xe7\xe3o de Arrays","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/tutorials/AdvancedStructures.md","sourceDirName":"tutorials","slug":"/tutorials/AdvancedStructures","permalink":"/pt-BR/docs/tutorials/AdvancedStructures","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/i18n/pt-BR/docusaurus-plugin-content-docs/current/tutorials/AdvancedStructures.md","tags":[],"version":"current","frontMatter":{"title":"Estruturas Avan\xe7adas","sidebar_label":"Estruturas Avan\xe7adas"},"sidebar":"docsSidebar","previous":{"title":"samp.cfg","permalink":"/pt-BR/docs/client/sa-mp.cfg"},"next":{"title":"Bin\xe1rio","permalink":"/pt-BR/docs/tutorials/Binary"}}'),n=o(85893),s=o(50065);let i={title:"Estruturas Avan\xe7adas",sidebar_label:"Estruturas Avan\xe7adas"},t=void 0,m={},d=[{value:"Manipula\xe7\xe3o de Arrays",id:"manipula\xe7\xe3o-de-arrays",level:2},{value:"Encontrando um slot vazio corretamente",id:"encontrando-um-slot-vazio-corretamente",level:3},{value:"Lista",id:"lista",level:3},{value:"Introdu\xe7\xe3o",id:"introdu\xe7\xe3o",level:4},{value:"Tipos",id:"tipos",level:4},{value:"Listas Mistas",id:"listas-mistas",level:4},{value:"C\xf3digo",id:"c\xf3digo",level:4},{value:"\xc1rvores Bin\xe1rias",id:"\xe1rvores-bin\xe1rias",level:3},{value:"Introdu\xe7\xe3o",id:"introdu\xe7\xe3o-1",level:4},{value:"Balanceadas e desbalanceadas",id:"balanceadas-e-desbalanceadas",level:4},{value:"Adi\xe7\xe3o",id:"adi\xe7\xe3o",level:4},{value:"Exclus\xe3o",id:"exclus\xe3o",level:4}];function l(e){let a={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h2,{id:"manipula\xe7\xe3o-de-arrays",children:"Manipula\xe7\xe3o de Arrays"}),"\n",(0,n.jsx)(a.h3,{id:"encontrando-um-slot-vazio-corretamente",children:"Encontrando um slot vazio corretamente"}),"\n",(0,n.jsx)(a.p,{children:"Este exemplo mostra como encontrar um slot vazio em um array usando pr\xe1ticas padr\xe3o de codifica\xe7\xe3o."}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"new\n    gMyArray[10];\n\nstock FindEmptySlot()\n{\n    new\n        i = 0;\n    while (i < sizeof (gMyArray) && gMyArray[i])\n    {\n        i++;\n    }\n    if (i == sizeof (gMyArray)) return -1;\n    return i;\n}\n"})}),"\n",(0,n.jsx)(a.p,{children:"Este exemplo b\xe1sico assume que um slot do array est\xe1 vazio se seu valor for 0. O loop percorre todos os valores do array (tamb\xe9m pode ser feito com uma constante) enquanto os valores n\xe3o forem 0. Quando atinge um que \xe9 0, a condi\xe7\xe3o while falhar\xe1 e o loop termina sem usar um break, como \xe9 pr\xe1tica comum, mas desencorajado em situa\xe7\xf5es como esta. Esta fun\xe7\xe3o tamb\xe9m retorna -1 se um slot livre n\xe3o for encontrado, o que precisaria ser verificado na outra extremidade. Mais comumente, voc\xea usaria o id encontrado diretamente:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:'MyFunction()\n{\n    new\n        i = 0;\n    while (i < sizeof (gMyArray) && gMyArray[i])\n    {\n        i++;\n    }\n    if (i == sizeof (gMyArray))\n    {\n        printf("No free slot found");\n        return 0;\n    }\n    printf("Slot %d is empty", i);\n    // Use the found slot in your code for whatever\n    return 1;\n}\n'})}),"\n",(0,n.jsx)(a.p,{children:'Obviamente, voc\xea substituiria a express\xe3o "gMyArray[i]" pela sua pr\xf3pria indica\xe7\xe3o de um slot em uso.'}),"\n",(0,n.jsx)(a.h3,{id:"lista",children:"Lista"}),"\n",(0,n.jsx)(a.h4,{id:"introdu\xe7\xe3o",children:"Introdu\xe7\xe3o"}),"\n",(0,n.jsx)(a.p,{children:"Listas s\xe3o um tipo muito \xfatil de estrutura, basicamente s\xe3o um array onde o pr\xf3ximo peda\xe7o de dados relevantes \xe9 apontado pelo \xfaltimo peda\xe7o."}),"\n",(0,n.jsx)(a.p,{children:"Exemplo:"}),"\n",(0,n.jsx)(a.p,{children:"Digamos que voc\xea tenha o seguinte array:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"3, 1, 64, 2, 4, 786, 2, 9\n"})}),"\n",(0,n.jsx)(a.p,{children:"Se voc\xea quisesse ordenar o array, voc\xea acabaria com:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"1, 2, 2, 3, 4, 9, 64, 786\n"})}),"\n",(0,n.jsx)(a.p,{children:"No entanto, se voc\xea quisesse deixar os dados na ordem original, mas ainda assim saber os n\xfameros em ordem por algum motivo (\xe9 apenas um exemplo), voc\xea tem um problema: como voc\xea pode ter n\xfameros em duas ordens ao mesmo tempo? Este seria um bom uso de listas. Para construir uma lista a partir desses dados, voc\xea precisaria transformar o array em um array 2D, onde a segunda dimens\xe3o tem 2 c\xe9lulas de tamanho, a primeira dimens\xe3o contendo o n\xfamero original, a outra contendo o \xedndice do pr\xf3ximo n\xfamero maior. Voc\xea tamb\xe9m precisaria de uma vari\xe1vel separada para armazenar o \xedndice do menor n\xfamero, ent\xe3o seu novo array ficaria assim:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"start = 1\n3, 1, 64, 2, 4, 786, 2, 9\n4, 3, 5,  6, 7, -1,  0, 2\n"})}),"\n",(0,n.jsx)(a.p,{children:"O pr\xf3ximo \xedndice associado a 786 \xe9 -1, este \xe9 um \xedndice de array inv\xe1lido e indica o fim da lista, ou seja, n\xe3o h\xe1 mais n\xfameros. Os dois 2's obviamente poderiam estar em qualquer ordem, o primeiro no array \xe9 o primeiro na lista tamb\xe9m, pois \xe9 mais prov\xe1vel ser encontrado primeiro."}),"\n",(0,n.jsx)(a.p,{children:"A outra vantagem deste m\xe9todo de ordenar os n\xfameros \xe9 que adicionar mais n\xfameros \xe9 muito mais r\xe1pido. Se voc\xea quisesse adicionar outro n\xfamero 3 ao array ordenado, precisaria primeiro deslocar pelo menos 4 n\xfameros um slot para a direita para abrir espa\xe7o, n\xe3o \xe9 terr\xedvel aqui, mas muito lento em arrays maiores. Com a vers\xe3o de lista, voc\xea poderia simplesmente anexar o 3 ao final do array e modificar um \xfanico valor na lista;"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"start = 1\n3, 1, 64, 2, 4, 786, 2, 9, 3\n8, 3, 5,  6, 7, -1,  0, 2, 4\n^ modify this value        ^ next highest slot\n"})}),"\n",(0,n.jsx)(a.p,{children:"Nenhum dos outros n\xfameros foi movido, ent\xe3o nenhum dos outros \xedndices precisa ser atualizado, apenas fa\xe7a o pr\xf3ximo n\xfamero menor apontar para o novo n\xfamero e fa\xe7a o novo n\xfamero apontar para o n\xfamero que o pr\xf3ximo menor costumava apontar. Remover um valor \xe9 ainda mais f\xe1cil:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"start = 1\n3, 1, 64, X, 4, 786, 2, 9, 3\n8, 6, 5,  6, 7, -1,  0, 2, 4\n   ^ Alterado para pular o valor removido\n"})}),"\n",(0,n.jsx)(a.p,{children:"Aqui o primeiro 2 foi removido e o n\xfamero que apontava para esse n\xfamero (o 1) foi atualizado para apontar para o n\xfamero que o n\xfamero removido estava apontando. Neste exemplo, nem o ponteiro do n\xfamero removido nem o n\xfamero foram removidos, mas voc\xea n\xe3o pode possivelmente chegar a esse slot seguindo a lista, ent\xe3o n\xe3o importa, ele est\xe1 efetivamente removido."}),"\n",(0,n.jsx)(a.h4,{id:"tipos",children:"Tipos"}),"\n",(0,n.jsx)(a.p,{children:"As listas nos exemplos acima eram apenas listas simples b\xe1sicas, voc\xea tamb\xe9m pode ter listas duplas onde cada valor aponta para o pr\xf3ximo valor e o \xfaltimo valor, estas tendem a ter um ponteiro para o final da lista tamb\xe9m para ir para tr\xe1s (por exemplo, para obter os n\xfameros em ordem decrescente):"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"start = 1\nend = 5\nvalue: 3, 1,  64, 2, 4, 786, 2, 9, 3\nnext:  8, 3,  5,  6, 7, -1,  0, 2, 4\nlast:  6, -1, 7,  1, 8, 2,   3, 4, 0\n"})}),"\n",(0,n.jsx)(a.p,{children:"Voc\xea tem que ter cuidado com estas, especialmente quando voc\xea tem mais de um de qualquer valor, que o \xfaltimo ponteiro aponte para o n\xfamero cujo pr\xf3ximo ponteiro volta direto novamente, por exemplo, isso est\xe1 errado:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"2,  3, 3\n1,  2, -1\n-1, 2, 0\n"})}),"\n",(0,n.jsx)(a.p,{children:"O pr\xf3ximo ponteiro do 2 aponta para o 3 no slot um, mas o \xfaltimo ponteiro desse 3 n\xe3o volta para o dois, ambas as listas est\xe3o em ordem por conta pr\xf3pria (j\xe1 que os dois tr\xeas podem estar em qualquer ordem), mas juntas est\xe3o erradas, a vers\xe3o correta seria:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"2,  3, 3\n1,  2, -1\n-1, 0, 2\n"})}),"\n",(0,n.jsx)(a.p,{children:"Ambas as listas come\xe7am e terminam nos dois n\xfameros finais, a lista traseira no exemplo errado come\xe7ou no n\xfamero do meio."}),"\n",(0,n.jsx)(a.p,{children:"O outro tipo de lista \xe9 a circular onde o \xfaltimo valor aponta de volta para o primeiro. A vantagem \xf3bvia disso \xe9 que voc\xea pode chegar a qualquer valor a partir de qualquer outro valor sem saber antecipadamente se o alvo est\xe1 antes ou depois do ponto de partida, voc\xea s\xf3 precisa ter cuidado para n\xe3o entrar em um loop infinito, pois n\xe3o h\xe1 ponto final expl\xedcito -1. Essas listas ainda t\xeam pontos de partida. Voc\xea tamb\xe9m pode fazer listas circulares duplas onde voc\xea tem uma lista de pr\xf3ximo e \xfaltima, ambas circulares:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"start = 1\nend = 5\n3, 1,  64, 2, 4, 786, 2, 9, 3\n8, 3,  5,  6, 7, 1,   0, 2, 4\n6, 5,  7,  1, 8, 2,   3, 4, 0\n"})}),"\n",(0,n.jsx)(a.h4,{id:"listas-mistas",children:"Listas Mistas"}),"\n",(0,n.jsx)(a.p,{children:"Listas mistas s\xe3o arrays contendo m\xfaltiplas listas ao mesmo tempo. Um exemplo poderia ser um array de valores, ordenado por uma lista, com outra lista ligando todos os slots n\xe3o utilizados para que voc\xea saiba onde pode adicionar um novo valor. Exemplo (X significa slot n\xe3o utilizado (livre)):"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"sortedStart = 3\nunusedStart = 1\nvalue: 34, X, X, 6, 34, 46, X,  54, 23, 25, X,  75, X, 45\nsort:  4,        8, 13, 7,      11, 9,  0,      -1,    5\nfree:      2, 6,            10,             12,     -1\n"})}),"\n",(0,n.jsx)(a.p,{children:"Obviamente as duas listas nunca interagem, ent\xe3o ambas podem usar o mesmo slot para o seu pr\xf3ximo valor:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"sortedStart = 3\nunusedStart = 1\nvalue: 34, X, X, 6, 34, 46, X,  54, 23, 25, X,  75, X,  45\nnext:  4,  2, 6, 8, 13, 7,  10, 11, 9,  0,  12, -1, -1, 5\n"})}),"\n",(0,n.jsx)(a.h4,{id:"c\xf3digo",children:"C\xf3digo"}),"\n",(0,n.jsx)(a.p,{children:"Antes de come\xe7ar o c\xf3digo, voc\xea precisa decidir que tipo de lista \xe9 mais adequada para sua aplica\xe7\xe3o, isso \xe9 inteiramente baseado na aplica\xe7\xe3o e n\xe3o pode ser facilmente coberto aqui. Todos esses exemplos s\xe3o listas mistas, uma lista para os valores necess\xe1rios, uma para slots n\xe3o utilizados."}),"\n",(0,n.jsx)(a.p,{children:"Este exemplo mostra como escrever c\xf3digo para uma lista ordenada numericamente em ordem crescente."}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"#define NUMBER_OF_VALUES (10)\n\nenum E_DATA_LIST\n{\n    E_DATA_LIST_VALUE,\n    E_DATA_LIST_NEXT\n}\n\nnew\n    gListData[NUMBER_OF_VALUES][E_DATA_LIST],\n    gUnusedStart = 0,\n    gListStart = -1; // Come\xe7a sem lista\n\n// Esta fun\xe7\xe3o inicializa a lista\nList_Setup()\n{\n    new\n        i,\n        size = NUMBER_OF_VALUES;\n    size--;\n    for (i = 0; i < size; i++)\n    {\n        // Para come\xe7ar, todos os slots est\xe3o n\xe3o utilizados\n        gListData[i][E_DATA_LIST_NEXT] = i + 1;\n    }\n    // Finaliza a lista\n    gListData[size][E_DATA_LIST_NEXT] = -1;\n}\n\n// Esta fun\xe7\xe3o adiciona um valor \xe0 lista (usando ordena\xe7\xe3o b\xe1sica)\nList_Add(value)\n{\n    // Verifica se h\xe1 slots livres no array\n    if (gUnusedStart == -1) return -1;\n    new\n        pointer = gListStart,\n        last = -1,\n        slot = gUnusedStart;\n    // Adiciona o valor ao array\n    gListData[slot][E_DATA_LIST_VALUE] = value;\n    // Atualiza a lista vazia\n    gUnusedStart = gListData[slot][E_DATA_LIST_NEXT];\n    // Percorre a lista at\xe9 chegar a um n\xfamero maior/do mesmo tamanho\n    while (pointer != -1 && gListData[pointer][E_DATA_LIST_VALUE] < value)\n    {\n        // Salva a posi\xe7\xe3o do \xfaltimo valor\n        last = pointer;\n        // Move para o pr\xf3ximo slot\n        pointer = gListData[pointer][E_DATA_LIST_NEXT];\n    }\n    // Se chegamos aqui, acabaram os valores ou alcan\xe7amos um maior\n    // Verifica se checamos algum n\xfamero\n    if (last == -1)\n    {\n        // O primeiro n\xfamero era maior ou n\xe3o h\xe1 lista\n        // De qualquer forma, adiciona o novo valor ao in\xedcio da lista\n        gListData[slot][E_DATA_LIST_NEXT] = gListStart;\n        gListStart = slot;\n    }\n    else\n    {\n        // Coloca o novo valor na lista\n        gListData[slot][E_DATA_LIST_NEXT] = pointer;\n        gListData[last][E_DATA_LIST_NEXT] = slot;\n    }\n    return slot;\n}\n\n// Esta fun\xe7\xe3o remove um valor de um determinado slot no array (retornado por List_Add)\nList_Remove(slot)\n{\n    // Este \xe9 um slot v\xe1lido\n    if (slot < 0 || slot >= NUMBER_OF_VALUES) return 0;\n    // Primeiro encontra o slot anterior\n    new\n        pointer = gListStart,\n        last = -1;\n    while (pointer != -1 && pointer != slot)\n    {\n        last = pointer;\n        pointer = gListData[pointer][E_DATA_LIST_NEXT];\n    }\n    // Encontramos o slot na lista\n    if (pointer == -1) return 0;\n    if (last == -1)\n    {\n        // O valor \xe9 o primeiro na lista\n        // Pula este slot na lista\n        gListStart = gListData[slot][E_DATA_LIST_NEXT];\n    }\n    else\n    {\n        // O valor est\xe1 na lista\n        // Pula este slot na lista\n        gListData[last][E_DATA_LIST_NEXT] = gListData[slot][E_DATA_LIST_NEXT];\n    }\n    // Adiciona este slot \xe0 lista de n\xe3o utilizados\n    // A lista de n\xe3o utilizados n\xe3o est\xe1 em nenhuma ordem, ent\xe3o isso n\xe3o importa\n    gListData[slot][E_DATA_LIST_NEXT] = gUnusedStart;\n    gUnusedStart = slot;\n    return 1;\n}\n"})}),"\n",(0,n.jsx)(a.h3,{id:"\xe1rvores-bin\xe1rias",children:"\xc1rvores Bin\xe1rias"}),"\n",(0,n.jsx)(a.h4,{id:"introdu\xe7\xe3o-1",children:"Introdu\xe7\xe3o"}),"\n",(0,n.jsx)(a.p,{children:"\xc1rvores bin\xe1rias s\xe3o um m\xe9todo muito r\xe1pido de pesquisar dados em um array usando um sistema de lista muito especial. A \xe1rvore bin\xe1ria mais conhecida \xe9 provavelmente o jogo das 20 perguntas, com apenas 20 perguntas sim/n\xe3o voc\xea pode ter mais de 1048576 itens. Uma \xe1rvore bin\xe1ria, como o nome indica, \xe9 um tipo de \xe1rvore, semelhante a uma \xe1rvore geneal\xf3gica, onde cada item tem 0, 1 ou 2 filhos. Elas n\xe3o s\xe3o usadas para ordenar dados como uma lista, mas para classificar dados para uma pesquisa muito eficiente. Basicamente, voc\xea come\xe7a com um item em algum lugar pr\xf3ximo ao meio da lista ordenada de objetos (por exemplo, o n\xfamero do meio em um array ordenado) e compara isso com o valor que deseja encontrar. Se for o mesmo, voc\xea encontrou seu item, se for maior, voc\xea move para o item \xe0 direita (n\xe3o imediatamente \xe0 direita, o item \xe0 direita do item do meio seria o item na marca de tr\xeas quartos), se for menor, voc\xea move para a esquerda, ent\xe3o repete o processo."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Exemplo"})}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-pawn",children:"1 2 5 6 7 9 12 14 17 19 23 25 28 33 38\n"})}),"\n",(0,n.jsx)(a.p,{children:"Voc\xea tem o array ordenado anterior e deseja encontrar em qual slot o n\xfamero 7 est\xe1 (se estiver), neste exemplo provavelmente \xe9 mais eficiente apenas percorrer diretamente o array para encontr\xe1-lo, mas esse n\xe3o \xe9 o ponto, esse m\xe9todo aumenta em tempo linearmente com o tamanho do array, o tempo de pesquisa bin\xe1ria aumenta linearmente \xe0 medida que o array aumenta exponencialmente em tamanho. Ou seja, um array de tamanho 128 levar\xe1 o dobro do tempo para pesquisar diretamente do que um array de tamanho 64, mas uma pesquisa bin\xe1ria 128 levar\xe1 apenas uma verifica\xe7\xe3o a mais do que uma pesquisa bin\xe1ria 64, nada demais."}),"\n",(0,n.jsxs)(a.p,{children:["Se construirmos uma \xe1rvore bin\xe1ria a partir dos dados acima, obtemos: ",(0,n.jsx)(a.img,{src:"https://sampwiki.blast.hk/wiki/Image:Binarytree.GIF",alt:"Binarytree"})]}),"\n",(0,n.jsx)(a.p,{children:"Se voc\xea ler da esquerda para a direita, ignorando o aspecto vertical, voc\xea pode ver que os n\xfameros est\xe3o em ordem. Agora podemos tentar encontrar o 7."}),"\n",(0,n.jsx)(a.p,{children:"O n\xfamero inicial \xe9 14, 7 \xe9 menor que 14, ent\xe3o vamos para o slot apontado pelo ramo esquerdo do 14. Isso nos leva ao 6, 7 \xe9 maior que 6, ent\xe3o vamos para a direita at\xe9 o 9, depois para a esquerda novamente at\xe9 o 7. Este m\xe9todo levou 4 compara\xe7\xf5es para encontrar o n\xfamero (incluindo a verifica\xe7\xe3o final para confirmar que estamos no 7), usando uma pesquisa direta teria levado 5."}),"\n",(0,n.jsxs)(a.p,{children:["Vamos dizer que n\xe3o h\xe1 7, acabar\xedamos com esta \xe1rvore bin\xe1ria: ",(0,n.jsx)(a.img,{src:"https://sampwiki.blast.hk/wiki/Image:Binarytree-7-less.GIF",alt:"Binarytree-7-less"})]}),"\n",(0,n.jsx)(a.p,{children:"Esta, ao contr\xe1rio do exemplo acima, tem um \xfanico n\xfamero filho (o 9), bem como n\xfameros filhos 2 e 0. Voc\xea s\xf3 obt\xe9m uma \xe1rvore perfeita quando h\xe1 (2^n)-1 n\xfameros (0, 1, 3, 7, 15, 31 ...), quaisquer outros n\xfameros dar\xe3o uma \xe1rvore n\xe3o completamente cheia. Neste caso, quando chegamos ao 9, onde o 7 estaria, encontraremos que n\xe3o h\xe1 ramo esquerdo, significando que o 7 n\xe3o existe (ele n\xe3o pode estar em nenhum outro lugar na \xe1rvore, pense nisso), ent\xe3o retornamos -1 para slot inv\xe1lido."}),"\n",(0,n.jsx)(a.h4,{id:"balanceadas-e-desbalanceadas",children:"Balanceadas e desbalanceadas"}),"\n",(0,n.jsxs)(a.p,{children:["As \xe1rvores nos exemplos acima s\xe3o chamadas de \xe1rvores bin\xe1rias balanceadas, isso significa que, o mais pr\xf3ximo poss\xedvel, todos os ramos t\xeam o mesmo comprimento (obviamente no segundo n\xe3o h\xe1 n\xfameros suficientes para que este seja o caso, mas \xe9 o mais pr\xf3ximo poss\xedvel). Construir \xe1rvores balanceadas n\xe3o \xe9 f\xe1cil, o m\xe9todo geralmente aceito de construir \xe1rvores quase balanceadas \xe9 colocar os n\xfameros em ordem aleat\xf3ria, isso pode significar que voc\xea acaba com algo assim: ",(0,n.jsx)(a.img,{src:"https://sampwiki.blast.hk/wiki/Image:Binarytree-uneven.GIF",alt:"Binarytree-uneven"})]}),"\n",(0,n.jsx)(a.p,{children:"Obviamente esta \xe1rvore ainda \xe9 v\xe1lida, mas o lado direito \xe9 muito maior que o esquerdo, no entanto, encontrar 25 ainda leva apenas 7 compara\xe7\xf5es nesta em compara\xe7\xe3o com 12 na lista direta. Al\xe9m disso, contanto que voc\xea comece com um n\xfamero razoavelmente do meio, o m\xe9todo de inser\xe7\xe3o aleat\xf3ria deve produzir uma \xe1rvore razoavelmente balanceada. A pior coisa poss\xedvel que voc\xea pode fazer \xe9 colocar os n\xfameros em ordem, pois ent\xe3o n\xe3o haver\xe1 ramos esquerdos (ou ramos direitos se feito ao contr\xe1rio), no entanto, mesmo neste pior caso, a \xe1rvore bin\xe1ria n\xe3o levar\xe1 mais tempo para pesquisar do que a lista direta."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Modifica\xe7\xe3o"})}),"\n",(0,n.jsx)(a.h4,{id:"adi\xe7\xe3o",children:"Adi\xe7\xe3o"}),"\n",(0,n.jsx)(a.p,{children:"Adicionar um valor a uma \xe1rvore bin\xe1ria \xe9 relativamente f\xe1cil, voc\xea apenas segue a \xe1rvore, usando o valor que deseja adicionar como refer\xeancia at\xe9 atingir um ramo vazio e adicionar o n\xfamero l\xe1. Por exemplo, se voc\xea quisesse adicionar o n\xfamero 15 \xe0 nossa \xe1rvore balanceada original, ele acabaria no ramo esquerdo do 17. Se quis\xe9ssemos adicionar o n\xfamero 8 \xe0 segunda \xe1rvore balanceada (a sem o 7), ele acabaria no antigo slot do 7 \xe0 esquerda do 9."}),"\n",(0,n.jsx)(a.h4,{id:"exclus\xe3o",children:"Exclus\xe3o"}),"\n",(0,n.jsx)(a.p,{children:"Excluir um n\xfamero de uma \xe1rvore bin\xe1ria pode ser dif\xedcil ou pode ser f\xe1cil. Se o n\xfamero est\xe1 no final de um ramo (por exemplo, 1, 5, 7, 12 etc na \xe1rvore original), voc\xea simplesmente os remove. Se um n\xfamero tem apenas um filho (por exemplo, o 9 no segundo exemplo), voc\xea simplesmente move esse filho (por exemplo, o 12) para cima em sua posi\xe7\xe3o (ent\xe3o os filhos do 6 seriam 2 e 12 no novo segundo exemplo com 9 removido). A exclus\xe3o s\xf3 fica interessante quando um n\xf3 tem dois filhos. Existem pelo menos quatro maneiras de fazer isso:"}),"\n",(0,n.jsx)(a.p,{children:"O primeiro m\xe9todo \xe9 o mais simples computacionalmente. Basicamente, voc\xea escolhe um dos ramos (esquerdo ou direito, assuma direito para esta explica\xe7\xe3o) e substitui o n\xf3 que voc\xea removeu pelo primeiro n\xf3 desse ramo (ou seja, o filho direito do n\xf3 que voc\xea removeu). Voc\xea ent\xe3o vai para a esquerda atrav\xe9s do novo ramo at\xe9 chegar ao final e coloca o ramo esquerdo l\xe1. Por exemplo, se voc\xea removesse o 14 do exemplo original, voc\xea acabaria com o 25 tomando seu lugar no topo da \xe1rvore e o 6 anexado ao ramo esquerdo do 17. Este m\xe9todo \xe9 r\xe1pido, mas acaba com \xe1rvores muito desbalanceadas muito rapidamente."}),"\n",(0,n.jsx)(a.p,{children:"O segundo m\xe9todo \xe9 obter todos os n\xfameros que s\xe3o filhos do n\xf3 que voc\xea acabou de remover e reconstruir uma nova \xe1rvore bin\xe1ria a partir deles, depois colocar o topo dessa \xe1rvore no n\xf3 que voc\xea acabou de remover. Isso mant\xe9m a \xe1rvore razoavelmente bem balanceada, mas \xe9 obviamente mais lento."}),"\n",(0,n.jsx)(a.p,{children:"O terceiro m\xe9todo \xe9 combinar os dois m\xe9todos acima e reconstruir a \xe1rvore inline, isso \xe9 mais complexo de codificar, mas mant\xe9m a \xe1rvore balanceada e \xe9 mais r\xe1pido que o segundo m\xe9todo (embora n\xe3o t\xe3o r\xe1pido quanto o primeiro)."}),"\n",(0,n.jsx)(a.p,{children:"O m\xe9todo final listado aqui \xe9 simplesmente definir uma flag em um valor dizendo que n\xe3o \xe9 mais usado, isso \xe9 ainda mais r\xe1pido que o primeiro m\xe9todo e mant\xe9m a estrutura, mas significa que voc\xea n\xe3o pode reutilizar slots a menos que possa encontrar um valor para substitu\xed-lo mais tarde."})]})}function c(e={}){let{wrapper:a}={...(0,s.a)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},50065:function(e,a,o){o.d(a,{Z:()=>t,a:()=>i});var r=o(67294);let n={},s=r.createContext(n);function i(e){let a=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function t(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(s.Provider,{value:a},e.children)}}}]);