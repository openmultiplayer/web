"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["99403"],{14675:function(e,a,o){o.r(a),o.d(a,{frontMatter:()=>i,toc:()=>d,default:()=>m,metadata:()=>r,assets:()=>t,contentTitle:()=>c});var r=JSON.parse('{"id":"scripting/language/Tags","title":"Scripting: Tags","description":"Um guia sobre Tags, o recurso semelhante a tipos da linguagem Pawn que oferece seguran\xe7a ao trabalhar com valores de diferentes prop\xf3sitos.","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/scripting/language/Tags.md","sourceDirName":"scripting/language","slug":"/scripting/language/Tags","permalink":"/pt-BR/docs/scripting/language/Tags","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/i18n/pt-BR/docusaurus-plugin-content-docs/current/scripting/language/Tags.md","tags":[],"version":"current","frontMatter":{"title":"Scripting: Tags","sidebar_label":"Scripting: Tags","description":"Um guia sobre Tags, o recurso semelhante a tipos da linguagem Pawn que oferece seguran\xe7a ao trabalhar com valores de diferentes prop\xf3sitos."},"sidebar":"docsSidebar","previous":{"title":"Guia de estilo Pawn","permalink":"/pt-BR/docs/scripting/language/Style"},"next":{"title":"No\xe7\xf5es b\xe1sicas: Vari\xe1veis","permalink":"/pt-BR/docs/scripting/language/Variables"}}'),s=o(85893),n=o(50065);let i={title:"Scripting: Tags",sidebar_label:"Scripting: Tags",description:"Um guia sobre Tags, o recurso semelhante a tipos da linguagem Pawn que oferece seguran\xe7a ao trabalhar com valores de diferentes prop\xf3sitos."},c=void 0,t={},d=[{value:"Introdu\xe7\xe3o",id:"introdu\xe7\xe3o",level:2},{value:"Tags fortes",id:"tags-fortes",level:3},{value:"Tags fracas",id:"tags-fracas",level:3},{value:"Uso",id:"uso",level:2},{value:"Declara\xe7\xe3o",id:"declara\xe7\xe3o",level:3},{value:"Fun\xe7\xf5es",id:"fun\xe7\xf5es",level:3},{value:"Operadores",id:"operadores",level:3},{value:"Sobrescrita",id:"sobrescrita",level:3}];function l(e){let a={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h2,{id:"introdu\xe7\xe3o",children:"Introdu\xe7\xe3o"}),"\n",(0,s.jsx)(a.p,{children:"Uma tag \xe9 um prefixo aplicado a uma vari\xe1vel para indicar ao compilador que ela deve ser tratada de forma especial em determinadas situa\xe7\xf5es. Por exemplo, voc\xea pode usar tags para determinar onde uma vari\xe1vel pode ou n\xe3o ser usada, ou ainda definir uma forma espec\xedfica de somar duas vari\xe1veis."}),"\n",(0,s.jsx)(a.p,{children:"Existem dois tipos de tags: tags fortes (usam letra mai\xfascula) e tags fracas (usam letra min\xfascula). Em geral elas funcionam igual, mas em algumas situa\xe7\xf5es as tags fracas podem ser convertidas silenciosamente para \u201Csem tag\u201D pelo compilador (ou seja, voc\xea n\xe3o ver\xe1 um aviso). Na maioria das vezes, com tags fracas, e sempre com tags fortes, mudar a tag implicitamente gera um aviso indicando que os dados podem estar sendo usados de forma incorreta."}),"\n",(0,s.jsx)(a.p,{children:"Um exemplo simples:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:'new\n    File:myfile = fopen("file.txt", io_read);\nmyFile += 4;\n'})}),"\n",(0,s.jsxs)(a.p,{children:["A fun\xe7\xe3o ",(0,s.jsx)(a.code,{children:"fopen"})," retorna um valor com tag ",(0,s.jsx)(a.code,{children:"File:"}),"; n\xe3o h\xe1 problema porque esse valor \xe9 armazenado em uma vari\xe1vel tamb\xe9m marcada com ",(0,s.jsx)(a.code,{children:"File:"})," (observe que as letras mai\xfasculas/min\xfasculas s\xe3o id\xeanticas). Contudo, na linha seguinte o valor ",(0,s.jsx)(a.code,{children:"4"})," \xe9 somado ao handle do arquivo. O ",(0,s.jsx)(a.code,{children:"4"})," n\xe3o possui tag (na verdade tem o tipo ",(0,s.jsx)(a.code,{children:"_:"})," por padr\xe3o, mas n\xe3o \xe9 algo com que voc\xea precise se preocupar normalmente) e ",(0,s.jsx)(a.code,{children:"myFile"})," tem a tag ",(0,s.jsx)(a.code,{children:"File:"}),". Como nada e algo n\xe3o podem ser iguais, o compilador emitir\xe1 um aviso; isso \xe9 bom, pois um handle de arquivo n\xe3o faz sentido em termos de valor num\xe9rico, ent\xe3o modific\xe1-lo apenas corromperia o handle e impediria o fechamento do arquivo, j\xe1 que n\xe3o haveria mais um handle v\xe1lido para passar ao fechamento."]}),"\n",(0,s.jsx)(a.h3,{id:"tags-fortes",children:"Tags fortes"}),"\n",(0,s.jsx)(a.p,{children:"Como dito, uma tag forte come\xe7a com letra mai\xfascula. Exemplos em SA:MP:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"Float:\nFile:\nText:\n"})}),"\n",(0,s.jsx)(a.p,{children:"Elas n\xe3o podem ser misturadas com outros tipos e sempre geram aviso quando voc\xea tenta fazer isso:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:'new\n    Float:myFloat,\n    File:myFile,\n    myBlank;\n\nmyFile = fopen("file.txt", io_read); // File: = File:, sem aviso\n\nmyFloat = myFile; // Float: = File:, aviso "tag mismatch"\n\nmyFloat = 4; // Float: = _: (nenhuma), aviso "tag mismatch"\n\nmyBlank = myFloat; // _: (nenhuma) = Float:, aviso "tag mismatch"\n'})}),"\n",(0,s.jsx)(a.h3,{id:"tags-fracas",children:"Tags fracas"}),"\n",(0,s.jsx)(a.p,{children:"Uma tag fraca se comporta quase como uma tag forte, mas o compilador n\xe3o gera aviso quando o destino n\xe3o tem tag e a origem \xe9 uma tag fraca. Compare o c\xf3digo com tag forte e com tag fraca: o primeiro gera aviso, o segundo n\xe3o."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"new\n    Strong:myStrong,\n    weak:myWeak,\n    myNone;\n\nmyNone = myStrong; // Aviso\nmyNone = myWeak; // Sem aviso\n"})}),"\n",(0,s.jsx)(a.p,{children:"O inverso n\xe3o \xe9 verdadeiro:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"myWeak = myNone; // Aviso\n"})}),"\n",(0,s.jsx)(a.p,{children:"Isso tamb\xe9m vale para fun\xe7\xf5es: chamar uma fun\xe7\xe3o cujo par\xe2metro \xe9 sem tag passando uma vari\xe1vel com tag fraca n\xe3o gera aviso:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"new\n    weak:myWeak;\nMyFunction(myWeak);\n\n\n\nMyFunction(myVar)\n{\n    ...\n}\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Mas chamar uma fun\xe7\xe3o que espera um par\xe2metro etiquetado (fraco ou forte) com um valor sem tag gera aviso. Exemplos de tags fracas usados em SA",":MP",", ainda que pouco conhecidos, incluem:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"bool:\nfilemode:\nfloatround_method:\n"})}),"\n",(0,s.jsx)(a.h2,{id:"uso",children:"Uso"}),"\n",(0,s.jsx)(a.h3,{id:"declara\xe7\xe3o",children:"Declara\xe7\xe3o"}),"\n",(0,s.jsx)(a.p,{children:"Declarar uma vari\xe1vel com tag \xe9 simples: basta escrever a tag; n\xe3o \xe9 necess\xe1rio defini-la antes, embora isso seja poss\xedvel e \xfatil em alguns casos (veremos mais \xe0 frente):"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"new\n    Mytag:myVariable;\n"})}),"\n",(0,s.jsx)(a.p,{children:"Declarar com uma tag existente permite usar essa vari\xe1vel com as fun\xe7\xf5es e operadores j\xe1 definidos para o tipo."}),"\n",(0,s.jsx)(a.h3,{id:"fun\xe7\xf5es",children:"Fun\xe7\xf5es"}),"\n",(0,s.jsx)(a.p,{children:"Criar uma fun\xe7\xe3o que recebe ou retorna uma tag tamb\xe9m \xe9 simples: prefixe a parte relevante com o tipo desejado, por exemplo:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"Float:GetValue(File:fHnd, const name[])\n{\n    ...\n}\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Essa fun\xe7\xe3o recebe o handle de um arquivo e retorna um float (presumivelmente um valor lido desse arquivo e correspondente ao nome informado em ",(0,s.jsx)(a.code,{children:"name[]"}),"). Ela provavelmente usar\xe1 ",(0,s.jsx)(a.code,{children:"floatstr"}),", que tamb\xe9m retorna um ",(0,s.jsx)(a.code,{children:"Float:"})," (\xe9 poss\xedvel conferir na barra de status do Pawno ao clicar na fun\xe7\xe3o). A implementa\xe7\xe3o em si n\xe3o importa, mas ela converte a string em um float IEEE, armazenado como um cell (na pr\xe1tica \xe9 um inteiro com o mesmo padr\xe3o de bits do n\xfamero IEEE, j\xe1 que Pawn n\xe3o tem tipagem; tags existem justamente para amenizar isso)."]}),"\n",(0,s.jsx)(a.h3,{id:"operadores",children:"Operadores"}),"\n",(0,s.jsxs)(a.p,{children:["Operadores como ",(0,s.jsx)(a.code,{children:"+"}),", ",(0,s.jsx)(a.code,{children:"=="}),", ",(0,s.jsx)(a.code,{children:">"})," etc. podem ser sobrecarregados para tags diferentes, ou seja, fazer ",(0,s.jsx)(a.code,{children:"+"})," em dois ",(0,s.jsx)(a.code,{children:"Float:"})," executa algo distinto de somar duas vari\xe1veis sem tag. Isso \xe9 especialmente \xfatil para floats porque, como mencionado, eles s\xe3o apenas inteiros com um padr\xe3o de bits espec\xedfico; se os operadores n\xe3o fossem sobrecarregados, as opera\xe7\xf5es ocorreriam sobre os inteiros e o resultado, interpretado como float, seria lixo. Por isso a tag ",(0,s.jsx)(a.code,{children:"Float:"})," tem vers\xf5es sobrecarregadas da maioria dos operadores para chamar fun\xe7\xf5es especiais no servidor em vez de confiar em Pawn."]}),"\n",(0,s.jsxs)(a.p,{children:["Um operador \xe9 igual a uma fun\xe7\xe3o normal, mas com o nome ",(0,s.jsx)(a.code,{children:"operator(**s\xedmbolo**)"}),", onde (",(0,s.jsx)(a.strong,{children:"s\xedmbolo"}),") \xe9 o operador que voc\xea quer sobrescrever. Os operadores v\xe1lidos s\xe3o:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"+\n-\n=\n++\n--\n==\n*\n/\n!=\n>\n<\n>=\n<=\n!\n%\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Operadores como ",(0,s.jsx)(a.code,{children:"\\"}),", ",(0,s.jsx)(a.code,{children:"*"}),", ",(0,s.jsx)(a.code,{children:"="})," etc. j\xe1 s\xe3o tratados automaticamente. Operadores como ",(0,s.jsx)(a.code,{children:"&"})," n\xe3o podem ser sobrecarregados. Voc\xea tamb\xe9m pode sobrescrever o mesmo operador v\xe1rias vezes com combina\xe7\xf5es diferentes de tags. Exemplo:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"stock Float:operator=(Mytag:oper)\n{\n    return float(_:oper);\n}\n"})}),"\n",(0,s.jsx)(a.p,{children:"Se adicionar isso ao c\xf3digo e fizer:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"new\n    Float:myFloat,\n    Mytag:myTag;\n\nmyFloat = myTag;\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Voc\xea n\xe3o ver\xe1 mais o aviso do compilador porque agora o operador ",(0,s.jsx)(a.code,{children:"="})," para o caso ",(0,s.jsx)(a.code,{children:"Float: = Mytag:"})," est\xe1 implementado e o compilador sabe como tratar a convers\xe3o."]}),"\n",(0,s.jsx)(a.h3,{id:"sobrescrita",children:"Sobrescrita"}),"\n",(0,s.jsx)(a.p,{children:"No exemplo de sobrecarga acima, a linha funcional foi:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"return float(_:oper);\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Esse \xe9 um exemplo de sobrescrita de tag: o ",(0,s.jsx)(a.code,{children:"_:"})," antes de ",(0,s.jsx)(a.code,{children:"oper"})," indica ao compilador que ignore o fato de a vari\xe1vel ter tag ",(0,s.jsx)(a.code,{children:"Mytag:"})," e a trate como ",(0,s.jsx)(a.code,{children:"_:"})," (sem tag). A fun\xe7\xe3o ",(0,s.jsx)(a.code,{children:"float()"})," aplica a tag a um n\xfamero comum, ent\xe3o precisa receber um n\xfamero sem tag. No exemplo consideramos que ",(0,s.jsx)(a.code,{children:"Mytag"})," armazena um inteiro comum, mas \xe9 necess\xe1rio cuidado com a sobrescrita; o c\xf3digo a seguir gera resultados estranhos:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-c",children:"new\n    Float:f1,\n    Float:f2 = 4.0;\nf1 = float(_:f2);\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Seria l\xf3gico imaginar que ",(0,s.jsx)(a.code,{children:"f1"})," viraria ",(0,s.jsx)(a.code,{children:"4.0"}),", mas isso n\xe3o acontece. Como mencionado, ",(0,s.jsx)(a.code,{children:"f2"})," guarda a representa\xe7\xe3o de ",(0,s.jsx)(a.code,{children:"4.0"}),", e n\xe3o apenas o valor inteiro ",(0,s.jsx)(a.code,{children:"4"}),"; isso significa que o valor bruto contido na vari\xe1vel \xe9 um n\xfamero bem incomum. Ao mandar o compilador trat\xe1-la como inteiro, ele simplesmente interpreta o padr\xe3o de bits como um inteiro, sem converter o float, ent\xe3o o resultado ser\xe1 praticamente aleat\xf3rio (h\xe1 um padr\xe3o nos floats IEEE, mas certamente n\xe3o se parecer\xe1 com ",(0,s.jsx)(a.code,{children:"4.0"}),")."]})]})}function m(e={}){let{wrapper:a}={...(0,n.a)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},50065:function(e,a,o){o.d(a,{Z:()=>c,a:()=>i});var r=o(67294);let s={},n=r.createContext(s);function i(e){let a=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(n.Provider,{value:a},e.children)}}}]);