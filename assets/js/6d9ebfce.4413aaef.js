"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["39513"],{17985:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>s,toc:()=>c,default:()=>d,metadata:()=>a,assets:()=>l,contentTitle:()=>o});var a=JSON.parse('{"id":"scripting/language/reference/Functions","title":"Functions","description":"---","source":"@site/docs/scripting/language/reference/04-Functions.md","sourceDirName":"scripting/language/reference","slug":"/scripting/language/reference/Functions","permalink":"/docs/scripting/language/reference/Functions","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/docs/scripting/language/reference/04-Functions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Data-and-declarations","permalink":"/docs/scripting/language/reference/Data-and-declarations"},"next":{"title":"The-preprocessor","permalink":"/docs/scripting/language/reference/The-preprocessor"}}'),i=t(85893),r=t(50065);let s={},o="Functions",l={},c=[{value:"\u2022 Calling functions",id:"-calling-functions",level:3},{value:"\u2022 Named parameters versus positional parameters",id:"-named-parameters-versus-positional-parameters",level:3},{value:"\u2022 Default values of function arguments",id:"-default-values-of-function-arguments",level:3},{value:"\u2022 sizeof operator &amp; default function arguments",id:"-sizeof-operator--default-function-arguments",level:3},{value:"\u2022 Arguments with tag names",id:"-arguments-with-tag-names",level:3},{value:"\u2022 Variable arguments",id:"-variable-arguments",level:3},{value:"\u2022 Coercion rules",id:"-coercion-rules",level:3},{value:"\u2022 Recursion",id:"-recursion",level:3},{value:"\u2022 Forward declarations",id:"-forward-declarations",level:3},{value:"\u2217 Other implementations of the Pawn language (if they exist) may use \u201Csingle pass\u201D parsers, requiring functions to be defined before use.",id:"-other-implementations-of-the-pawn-language-if-they-exist-may-use-single-pass-parsers-requiring-functions-to-be-defined-before-use",level:6},{value:"\u2022 State classifiers",id:"-state-classifiers",level:3},{value:"\u2022 Public functions, function main",id:"-public-functions-function-main",level:3},{value:"\u2022 Static functions",id:"-static-functions",level:3},{value:"\u2022 Stock functions",id:"-stock-functions",level:3},{value:"\u2022 Native functions",id:"-native-functions",level:3},{value:"\u2022 User-defined operators",id:"-user-defined-operators",level:3},{value:"\u2022 Floating point and fixed point arithmetic",id:"-floating-point-and-fixed-point-arithmetic",level:3},{value:"\u2217 Modern CPUs use two\u2019s complement integer arithmetic. For positive values, the bitwise representation of a value is the same in one\u2019s complement and two\u2019s complement, but the representations differ for negative values. For instance, the same bit pattern that means -5 in one\u2019s complement stands for -6 in two\u2019s complement.",id:"-modern-cpus-use-twos-complement-integer-arithmetic-for-positive-values-the-bitwise-representation-of-a-value-is-the-same-in-ones-complement-and-twos-complement-but-the-representations-differ-for-negative-values-for-instance-the-same-bit-pattern-that-means--5-in-ones-complement-stands-for--6-in-twos-complement",level:6},{value:"\u2020 See the application note \u201CFixed Point Support Library\u201D for where to obtain the include file.",id:"-see-the-application-note-fixed-point-support-library-for-where-to-obtain-the-include-file",level:6},{value:"\u2022 Call by Value and Call by Reference",id:"-call-by-value-and-call-by-reference",level:3},{value:"Call by value",id:"call-by-value",level:4},{value:"Call by reference",id:"call-by-reference",level:4},{value:"\u2022 Recursion / Function Recursion",id:"-recursion--function-recursion",level:3},{value:"Base Case:",id:"base-case",level:5},{value:"Recursive Case:",id:"recursive-case",level:5},{value:"Example",id:"example",level:4},{value:"Demonstrate the Output",id:"demonstrate-the-output",level:4},{value:"Stack Memory",id:"stack-memory",level:3},{value:"Example (Stack Overflow)",id:"example-stack-overflow",level:4},{value:"Output",id:"output",level:4}];function h(e){let n={a:"a",br:"br",code:"code",h1:"h1",h3:"h3",h4:"h4",h5:"h5",h6:"h6",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"functions",children:"Functions"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"A function declaration specifies the name of the function and, between paren-\ntheses, its formal parameters. A function may also return a value. A function\ndeclaration must appear on a global level (i.e. outside any other functions) and\nis globally accessible."}),"\n",(0,i.jsx)(n.p,{children:"If a semicolon follows the function declaration (rather than a statement), the\ndeclaration denotes a forward declaration of the function."}),"\n",(0,i.jsx)(n.p,{children:"The return statement sets the function result. For example, function sum (see below)\nhas as its result the value of both its arguments added together. The\nreturn expression is optional for a function, but one cannot use the value of\na function that does not return a value."}),"\n",(0,i.jsx)(n.p,{children:"Listing: sum function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nsum(a, b)\nreturn a + b\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arguments of a function are (implicitly declared) local variables for that function.\nThe function call determines the values of the arguments."}),"\n",(0,i.jsx)(n.p,{children:"Another example of a complete definition of the function leapyear\n(which returns true for a leap year and false for a non-leap year):"}),"\n",(0,i.jsx)(n.p,{children:"Listing: leapyear function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nleapyear(y)\nreturn y % 4 == 0 && y % 100 != 0 || y % 400 == 0\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The logical and arithmetic operators used in the leapyear example are covered\non pages 108 and 104 respectively."}),"\n",(0,i.jsx)(n.p,{children:"Usually a function contains local variable declarations and consists of a com-\npound statement. In the following example, note the assert statement to\nguard against negative values for the exponent."}),"\n",(0,i.jsx)(n.p,{children:"Listing: power function (raise to a power)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\npower(x, y)\n{\n    /* returns x raised to the power of y */\n    assert y >= 0\n    new r = 1\n    for (new i = 0; i < y; i++)\n        r *= x\n    return r\n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A function may contain multiple return statements \u2014one usually does this\nto quickly exit a function on a parameter error or when it turns",(0,i.jsx)(n.br,{}),"\n","out that the function has nothing to do. If a function returns an array,",(0,i.jsx)(n.br,{}),"\n","all return statements must specify an array with the same size and the same dimensions."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"The preferred way to declare forward functions is at page 82"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201Cassert\u201D statement: 112"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"\u2022 Function arguments (call-by-value versus call-by-reference)"}),"\n",(0,i.jsx)(n.p,{children:"The \u201Cfaculty\u201D function in the next program has one parameter which it uses\nin a loop to calculate the faculty of that number. What deserves attention is\nthat the function modifies its argument."}),"\n",(0,i.jsx)(n.p,{children:"Listing: faculty.p"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\n/* Calculation of the faculty of a value */\n\nmain()\n{\n    print "Enter a value: "\n    new v = getvalue()\n    new f = faculty(v)\n    printf "The faculty of %d is %d\\n", v, f\n}\n\nfaculty(n)\n{\n    assert n >= 0\n\n    new result = 1\n    while (n > 0)\n        result *= n--\n\n    return result\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"Whatever (positive) value that \u201Cn\u201D had at the entry of the while\nloop in function faculty, \u201Cn\u201D will be zero at the end of the loop. In the case of the\nfaculty function, the parameter is passed \u201Cby value\u201D, so the change of \u201Cn\u201D\nis local to the faculty function. In other words, function main passes \u201Cv\u201D as\ninput to function faculty, but upon return of faculty, \u201Cv\u201D still has the same\nvalue as before the function call."}),"\n",(0,i.jsx)(n.p,{children:"Arguments that occupy a single cell can be passed by value or by reference.\nThe default is \u201Cpass by value\u201D. To create a function argument that is passed\nby reference, prefix the argument name with the character &."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: swap function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nswap(&a, &b)\n{\n    new temp = b\n    b = a\n    a = temp\n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To pass an array to a function, append a pair of brackets to the",(0,i.jsx)(n.br,{}),"\n","argument name. You may optionally indicate the size of the array; doing so improves\nerror checking of the parser."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: addvector function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\naddvector(a[], const b[], size)\n{\n    for (new i = 0; i < size; i++)\n        a[i] += b[i]\n}\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arrays are always passed by reference. As a side note, array b in the above\nexample does not change in the body of the function. The function argument\nhas been declared as const to make this explicit. In addition to improving\nerror checking, it also allows the pawn parser to generate more efficient code."}),"\n",(0,i.jsxs)(n.p,{children:["To pass an array of literals to a function, use the same syntax as for",(0,i.jsx)(n.br,{}),"\n","array initiallers: a literal string or the series of array indices enclosed in braces\n(see page 99; the ellipsis for progressive initiallers cannot be used). Literal\narrays can only have a single dimension."]}),"\n",(0,i.jsx)(n.p,{children:"The following snippet calls addvector to add five to every element of the array \u201Cvect\u201D:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: addvector usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnew vect[3] = { 1, 2, 3 }\n\naddvector(vect, {5, 5, 5}, 3)\n\n/* vect[] now holds the values 6, 7 and 8 */\n\n"})}),"\n",(0,i.jsx)(n.p,{children:'The invocation of function printf with the string "Hello world\\n" in the first\nubiquitous program is another example of passing a literal array to a function.'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Another example is function JulianToDate at page 13"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Constant variables: 64"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201CHello world\u201D program: 5"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-calling-functions",children:"\u2022 Calling functions"}),"\n",(0,i.jsxs)(n.p,{children:["When inserting a function name with its parameters in a statement or",(0,i.jsx)(n.br,{}),"\n","expression, the function will get executed in that statement/expression.",(0,i.jsx)(n.br,{}),"\n","The statement that refers to the function is the \u201Ccaller\u201D and the function itself,\nat that point, is the \u201Ccallee\u201D: the one being called."]}),"\n",(0,i.jsxs)(n.p,{children:["The standard syntax for calling a function is to write the",(0,i.jsx)(n.br,{}),"\n","function\u2019s name, followed by a list with all explicitly passed parameters between parentheses.\nIf no parameters are passed, or if the function does not have any, the pair of\nparentheses behind the function name are still present. For example, to try\nout the power function, the following program calls it thus:"]}),"\n",(0,i.jsx)(n.p,{children:"Listing: example program for the power function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\nmain()\n{\n    print "Please give the base value and the power to raise it to:"\n    new base = getvalue()\n    new power = getvalue()\n\n    new result = power(base, power)\n    printf "%d raised to the power %d is %d", base, power, result\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"A function may optionally return a value. The sum, leapyear and power\nfunctions all return a value, but the swap function does not. Even if a\nfunction returns a value, the caller may ignore it."}),"\n",(0,i.jsx)(n.p,{children:"For the situation that the caller ignores the function\u2019s return value, there is\nan alternative syntax to call the function, which is also illustrated\nby the preceding example program calls the power function. The parentheses around\nall function arguments are optional if the caller does not use the return value."}),"\n",(0,i.jsx)(n.p,{children:"In the last statement, the example program reads"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'printf "%d raised to the power %d is %d", base, power, result'})}),"\n",(0,i.jsx)(n.p,{children:"rather than"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'printf("%d raised to the power %d is %d", base, power, result)'})}),"\n",(0,i.jsx)(n.p,{children:"which does the same thing."}),"\n",(0,i.jsx)(n.p,{children:"The syntax without parentheses around the parameter list is called the \u201Cpro-\ncedure call\u201D syntax. You can use it only if:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"the caller does not assign the function\u2019s result to a variable and does not use it in an expression, or as the \u201Ctest expression\u201D of an if statement for example;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"the first parameter does not start with an opening paranthesis;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"the first parameter is on the same line as the function name, unless you use named parameters (see the next section)."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"As you may observe, the procedure call syntax applies to cases where a function\ncall behaves rather as a statement, like in the calls to print and printf in the\npreceding example. The syntax is aimed at making such statements appear less\ncryptic and friendlier to read, but not that the use of the syntax is optional."}),"\n",(0,i.jsxs)(n.p,{children:["As a side note, all parentheses in the example program presented in this section\nare required: the return values of the calls to getvalue are stored",(0,i.jsx)(n.br,{}),"\n","in two variables, and therefore an empty pair of parentheses must follow the function\nname. Function getvalue has optional parameters, but none are passed in this example program."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Function power: 70"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Functions sum & leapyear: 70"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Function swap: 71"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-named-parameters-versus-positional-parameters",children:"\u2022 Named parameters versus positional parameters"}),"\n",(0,i.jsxs)(n.p,{children:["In the previous examples, the order of parameters of a function call was im-\nportant, because each parameter is copied to the function argument with the\nsame sequential position. For example, with the function weekday (which\nuses Zeller\u2019s congruence algorithm) defined as below, you would call",(0,i.jsx)(n.br,{}),"\n","weekday(12,31,1999) to get the week day of the last day of the preceding century."]}),"\n",(0,i.jsx)(n.p,{children:"Listing: weekday function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nweekday(month, day, year)\n{\n    /* returns the day of the week: 0=Saturday, 1=Sunday, etc. */\n    if (month <= 2)\n        month += 12, --year\n    new j = year % 100\n    new e = year / 100\n    return (day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7\n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Date formats vary according to culture and nation. While the format month/\nday/year is common in the United States of America, European",(0,i.jsx)(n.br,{}),"\n","countries often use the day/month/year format, and technical publications sometimes\nstandardize on the year/month/day format (ISO/IEC 8824). In other words,\nno order of arguments in the weekday function is \u201Clogical\u201D or \u201Cconventional\u201D.\nThat being the case, the alternative way to pass parameters to a function is\nto use \u201Cnamed parameters\u201D, as in the next examples (the three function calls are equivalent):"]}),"\n",(0,i.jsx)(n.p,{children:"Listing: weekday usage \u2014positional parameters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnew wkday1 = weekday( .month = 12, .day = 31, .year = 1999)\n\nnew wkday2 = weekday( .day = 31, .month = 12, .year = 1999)\n\nnew wkday3 = weekday( .year = 1999, .month = 12, .day = 31)\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With named parameters, a period (\u201C.\u201D) precedes the name of the",(0,i.jsx)(n.br,{}),"\n","function argument. The function argument can be set to any expression that is valid\nfor the argument. The equal sign (\u201C=\u201D) does in the case of a named\nparameter not indicate an assignment; rather it links the expression that follows the\nequal sign to one of the function arguments."]}),"\n",(0,i.jsx)(n.p,{children:"One may mix positional parameters and named parameters in a function call\nwith the restriction that all positional parameters must precede any named\nparameters."}),"\n",(0,i.jsx)(n.h3,{id:"-default-values-of-function-arguments",children:"\u2022 Default values of function arguments"}),"\n",(0,i.jsx)(n.p,{children:"A function argument may have a default value. The default value for a function\nargument must be a constant. To specify a default value, append the equal\nsign (\u201C=\u201D) and the value to the argument name."}),"\n",(0,i.jsx)(n.p,{children:"When the function call specifies an argument placeholder instead of a valid ar-\ngument, the default value applies. The argument placeholder is the underscore\ncharacter (\u201C_\u201D). The argument placeholder is only valid for function arguments\nthat have a default value."}),"\n",(0,i.jsx)(n.p,{children:"The rightmost argument placeholders may simply be stripped from the function\nargument list. For example, if function increment is defined as:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: increment function \u2014default values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nincrement(&value, incr=1) value += incr\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"the following function calls are all equivalent:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: increment usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nincrement(a)\nincrement(a, \\_)\nincrement(a, 1)\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"Default argument values for passed-by-reference arguments are useful to make\nthe input argument optional. For example, if the function divmod is designed\nto return both the quotient and the remainder of a division operation through\nits arguments, default values make these arguments optional:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: divmod function \u2014default values for reference parameters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\ndivmod(a, b, &quotient=0, &remainder=0)\n{\n    quotient = a / b\n    remainder = a % b\n}\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"With the preceding definition of function divmod, the following function calls\nare now all valid:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: divmod usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnew p, q\n\ndivmod(10, 3, p, q)\ndivmod(10, 3, p, \\_)\ndivmod(10, 3, \\_, q)\ndivmod(10, 3, p)\ndivmod 10, 3, p, q\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"Default arguments for array arguments are often convenient to set a default\nstring or prompt to a function that receives a string argument. For example:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: print error function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\nprint_error(const message[], const title[] = "Error: ")\n{\n    print title\n    print message\n    print "\\n"\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"The next example adds the fields of one array to another array, and by default\nincrements the first three elements of the destination array by one:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: addvector function, revised"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\naddvector(a[], const b[] = {1, 1, 1}, size = 3)\n{\n    for (new i = 0; i < size; i++)\n    a[i] += b[i]\n}\n\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Public functions do not support default argument values; see page 83"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-sizeof-operator--default-function-arguments",children:"\u2022 sizeof operator & default function arguments"}),"\n",(0,i.jsxs)(n.p,{children:["A default value of a function argument must be a constant, and its value is\ndetermined at the point of the function\u2019s declaration. Using the",(0,i.jsx)(n.br,{}),"\n","\u201Csizeof\u201D operator to set the default value of a function argument is a special case: the\ncalculation of the value of the sizeof expression is delayed to the point of the\nfunction call and it takes the size of the actual argument rather than that of\nthe formal argument. When the function is used several times in a program,\nwith different arguments, the outcome of the \u201Csizeof\u201D expression is potentially\ndifferent at every call \u2014which means that the \u201Cdefault value\u201D of the function\nargument may change."]}),"\n",(0,i.jsx)(n.p,{children:"Below is an example program that draws ten random numbers in the range of\n0\u201351 without duplicates. An example for an application for drawing random\nnumbers without duplicates is in card games \u2014those ten numbers could repre-\nsent the cards for two \u201Chands\u201D in a poker game. The virtues of the algorithm\nused in this program, invented by Robert W. Floyd, are that it is efficient and\nunbiased \u2014provided that the pseudo-random number generator is unbiased as well."}),"\n",(0,i.jsx)(n.p,{children:"Listing: randlist.p"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\nmain()\n{\n    new HandOfCards[10]\n    FillRandom(HandOfCards, 52)\n\n    print "A draw of 10 numbers from a range of 0 to 51 \\\n        (inclusive) without duplicates:\\n"\n    for (new i = 0; i < sizeof HandOfCards; i++)\n        printf "%d ", HandOfCards[i]\n}\n\nFillRandom(Series[], Range, Number = sizeof Series)\n{\n    assert Range >= Number          /* cannot select 50 values\n                                     * without duplicates in the\n                                     * range 0..40, for example */\n    new Index = 0\n    for (new Seq = Range - Number; Seq < Range; Seq++)\n    {\n        new Val = random(Seq + 1)\n        new Pos = InSeries(Series, Val, Index)\n        if (Pos >= 0)\n        {\n            Series[Index] = Series[Pos]\n            Series[Pos] = Seq\n        }\n        else\n            Series[Index] = Val\n        Index++\n    }\n}\n\nInSeries(Series[], Value, Top = sizeof Series)\n{\n    for (new i = 0; i < Top; i++)\n        if (Series[i] == Value)\n            return i\n    return -1\n}\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Function main declares the array HandOfCards with a size of ten cells and then\ncalls function FillRandom with the purpose that it draws ten positive random\nnumbers below 52. Observe, however, that the only two parameters that main\npasses into the call to FillRandom are the array HandsOfCards, where",(0,i.jsx)(n.br,{}),"\n","the random numbers should be stored, and the upper bound \u201C52\u201D. The number of\nrandom numbers to draw (\u201C10\u201D) is passed implicitly to FillRandom."]}),"\n",(0,i.jsx)(n.p,{children:"The definition of function FillRandom below main specifies for its third param-\neter \u201CNumber = sizeof Series\u201D, where \u201CSeries\u201D refers to the first parameter\nof the function. Due to the special case of a \u201Csizeof default value\u201D, the\ndefault value of the Number argument is not the size of the formal argument Series,\nbut that of the actual argument at the point of the function call: HandOfCards."}),"\n",(0,i.jsxs)(n.p,{children:["Note that inside function FillRandom, asking the \u201Csizeof\u201D the function ar-\ngument Series would (still) evaluate in zero, because the Series array",(0,i.jsx)(n.br,{}),"\n","is declared with unspecified length (see page 109 for the behaviour of sizeof).\nUsing sizeof as a default value for a function argument is a specific case. If\nthe formal parameter Series were declared with an explicit size, as in\nSeries[10], it would be redundant to add a Number argument with the array\nsize of the actual argument, because the parser would then enforce that both\nformal and actual arguments have the size and dimensions."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201Csizeof \u201D operator 109"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201Crandom\u201D is a proposed core function, see page 124"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Array declarations: 64"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Tag names: 68"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-arguments-with-tag-names",children:"\u2022 Arguments with tag names"}),"\n",(0,i.jsxs)(n.p,{children:["A tag optionally precedes a function argument. Using tags improves",(0,i.jsx)(n.br,{}),"\n","the compile-time error checking of the script and it\nserves as \u201Cimplicit documenta-\ntion\u201D of the function. For example, a function that computes the square root"]}),"\n",(0,i.jsx)(n.p,{children:"of an input value in fixed point precision may require that the input parameter\nis a fixed point value and that the result is fixed point as well. The function\nbelow uses the fixed point extension module, and an approximation algorithm\nknown as \u201Cbisection\u201D to calculate the square root. Note the use of tag overrides\non numeric literals and expression results."}),"\n",(0,i.jsx)(n.p,{children:"Listing: sqroot function \u2014strong tags"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nFixed: sqroot(Fixed: value)\n{\n    new Fixed: low = 0.0\n    new Fixed: high = value\n    while (high - low > Fixed: 1)\n    {\n        new Fixed: mid = (low + high) >> 1\n        if (fmul(mid, mid) < value)\n            low = mid\n        else\n            high = mid\n    }\n    return low\n}\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"With the above definition, the pawn parser issues a diagnostic if one calls the\nsqroot function with a parameter with a tag different from \u201CFixed:\u201D, or when\nit tries to store the function result in a variable with a \u201Cnon-Fixed:\u201D tag."}),"\n",(0,i.jsx)(n.p,{children:"The bisection algorithm is related to binary search, in the sense that it\ncontinuously halves the interval in which the result must lie. A \u201Csuccessive substi-\ntution\u201D algorithm like Newton-Raphson, that takes the slope of the function\u2019s\ncurve into account, achieves precise results more quickly, but at the cost that\na stopping criterion is more difficult to state. State of the art algorithms\nfor computing square roots combine bisection and Newton-Raphson algorithms."}),"\n",(0,i.jsx)(n.p,{children:"In the case of an array, the array indices can be tagged as well. For example,\na function that creates the intersection of two rectangles may be written as:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: intersection function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\nintersection(dest[rectangle], const src1[rectangle], const src2[rectangle])\n{\n    if (src1[right] > src2[left] && src1[left] < src2[right]\n    && src1[bottom] > src2[top] && src1[top] < src2[bottom])\n    {\n        \\* there is an intersection, calculate it using the "min" and\n         *"max" functions from the "core" library, see page 124. */\n\n        dest[left] = max(src1[left], src2[left])\n        dest[right] = min(src1[right], src2[right])\n        dest[top] = max(src1[top], src2[top])\n        dest[bottom] = min(src1[bottom], src2[bottom])\n        return true\n    }\n    else\n    {\n        /* "src1" and "src2" do not intersect */\n        dest = { 0, 0, 0, 0 }\n        return false\n    }\n}\n\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Fixed point arithmetic: 90; see also the application note \u201CFixed Point Support Library\u201D"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"For the \u201Crectangle\u201D tag, see page 68"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-variable-arguments",children:"\u2022 Variable arguments"}),"\n",(0,i.jsx)(n.p,{children:"A function that takes a variable number of arguments, uses the \u201Cellipsis\u201D oper-\nator (\u201C...\u201D) in the function header to denote the position of the first variable\nargument. The function can access the arguments with the predefined func-\ntions numargs, getarg and setarg (see page 124)."}),"\n",(0,i.jsx)(n.p,{children:"Function sum returns the summation of all of its parameters.\nIt uses a variable length parameter list."}),"\n",(0,i.jsx)(n.p,{children:"Listing: sum function, revised"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nsum(...)\n{\n    new result = 0\n    for (new i = 0; i < numargs(); ++i)\n        result += getarg(i)\n    return result\n}\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"This function could be used in:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: sum function usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnew v = sum(1, 2, 3, 4, 5)\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"A tag may precede the ellipsis to enforce that all subsequent parameters have the same tag, but otherwise there is no error\nchecking with a variable argument list and this feature should therefore be used with caution."}),"\n",(0,i.jsx)(n.p,{children:"The functions getarg and setarg assume that the argument is passed \u201Cby\nreference\u201D. When using getarg on normal function parameters (instead of\nvariable arguments) one should be cautious of this, as neither the compiler nor\nthe abstract machine can check this. Actual parameters that are passed\nas part of a \u201Cvariable argument list\u201D are always passed by reference."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Tag names: 68"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-coercion-rules",children:"\u2022 Coercion rules"}),"\n",(0,i.jsx)(n.p,{children:"If the function argument, as per the function definition (or its declaration),\nis a \u201Cvalue parameter\u201D, the caller can pass as a parameter to the function:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"a value, which is passed by value;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"a reference, whose dereferenced value is passed;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"an (indexed) array element, which is a value."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the function argument is a reference, the caller can pass to the function:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"a value, whose address is passed;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"a reference, which is passed by value because it has the type that the function expects;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"an (indexed) array element, which is a value."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the function argument is an array, the caller can pass to the function:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"an array with the same dimensions, whose starting address is passed;"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"an (indexed) array element, in which case the address of the element is passed."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"-recursion",children:"\u2022 Recursion"}),"\n",(0,i.jsxs)(n.p,{children:["A faculty example function earlier in this chapter used a simple loop. An\nexample function that calculated a number from the Fibonacci series also used\na loop and an extra variable to do the trick. These two functions are the most\npopular routines to illustrate recursive functions, so by implementing",(0,i.jsx)(n.br,{}),"\n","these as iterative procedures, you might be inclined to think that pawn does not support recursion."]}),"\n",(0,i.jsxs)(n.p,{children:["Well, pawn does support recursion, but the calculation of faculties and of Fi-\nbonacci numbers happen to be good examples of when not to use recursion.\nFaculty is easier to understand with a loop than it is with recursion.",(0,i.jsx)(n.br,{}),"\n","Solving Fibonacci numbers by recursion indeed simplifies the problem, but at the\ncost of being extremely inefficient: the recursive Fibonacci calculates the same\nvalues over and over again."]}),"\n",(0,i.jsx)(n.p,{children:"The program below is an implementation of the famous \u201CTowers of Hanoi\u201D game in a recursive function:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: hanoi.p"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\n/* The Towers of Hanoi, a game solved through recursion */\n\nmain()\n{\n    print "How many disks: "\n    new disks = getvalue()\n    move 1, 3, 2, disks\n}\n\nmove(from, to, spare, numdisks)\n{\n    if (numdisks > 1)\n        move from, spare, to, numdisks-1\n    printf "Move disk from pillar %d to pillar %d\\n", from, to\n    if (numdisks > 1)\n        move spare, to, from, numdisks-1\n}\n\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201Cfaculty\u201D: 71"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201Cfibonacci\u201D: 11"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"There exists an intriguing iterative solution to the Towers of Hanoi."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-forward-declarations",children:"\u2022 Forward declarations"}),"\n",(0,i.jsxs)(n.p,{children:["For standard functions, the current \u201Creference implementation\u201D of the pawn\ncompiler does not require functions to be declared before their first use.\u2217",(0,i.jsx)(n.br,{}),"\n","Userdefined operators are special functions, and unlike standard functions",(0,i.jsx)(n.br,{}),"\n","theymust be declared before use. In many cases it is convenient to put the\nimplementation of a user-defined operator in an include file, so that the implementation and declaration precedes any\ncall/invocation. Sometimes, it may however be required (or convenient) to declare a user- defined operator first\nand implement it elsewhere. A particular use of this technique is to implement\n\u201Cforbidden\u201D user-defined operators."]}),"\n",(0,i.jsx)(n.p,{children:"To create a forward declaration, precede the function name and its parame-\nter list with the keyword forward. For compatibility with early versions of\npawn, and for similarity with C/C\u207A\u207A, an alternative way to forwardly declare\na function is by typing the function header and terminating it with a semicolon\n(which follows the closing parenthesis of the parameter list)."}),"\n",(0,i.jsx)(n.p,{children:"The full definition of the function, with a non-empty body, is\nimplemented elsewhere in the source file (except for forbidden user-defined operators)."}),"\n",(0,i.jsx)(n.p,{children:"State classifiers are ignored on forward declarations."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h6,{id:"-other-implementations-of-the-pawn-language-if-they-exist-may-use-single-pass-parsers-requiring-functions-to-be-defined-before-use",children:"\u2217 Other implementations of the Pawn language (if they exist) may use \u201Csingle pass\u201D parsers, requiring functions to be defined before use."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Forbidden userdefined operators: 92"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-state-classifiers",children:"\u2022 State classifiers"}),"\n",(0,i.jsxs)(n.p,{children:["All functions except native functions may optionally have a state attribute.\nThis consists of a list of state (and automata) names between angle brackets\nbehind the function header. The names are separated by commas. When the\nstate is part of a non-default automaton, the name of the automaton and a\ncolon separator must precede the state; for example, \u201Cparser",":slash","\u201D stands\nfor the state slash of the automaton parser."]}),"\n",(0,i.jsx)(n.p,{children:"If a function has states, there must be several \u201Cimplementations\u201D of the function in the source code.\nAll functions must have the same function header (excluding the state classifier list)."}),"\n",(0,i.jsx)(n.p,{children:"As a special syntax, when there are no names between the angle brackets, the\nfunction is linked to all states that are not attributed to other\nimplementations of the function. The function that handles \u201Call states not handled elsewhere\u201D\nis the so-called fall-back function."}),"\n",(0,i.jsx)(n.h3,{id:"-public-functions-function-main",children:"\u2022 Public functions, function main"}),"\n",(0,i.jsxs)(n.p,{children:["A stand-alone program must have the function main. This function is",(0,i.jsx)(n.br,{}),"\n","the starting point of the program. The function main may not have arguments."]}),"\n",(0,i.jsxs)(n.p,{children:["A function library need not to have a main function, but it must have it either\na main function, or at least one public function. Function main is the primary\nentry point into the compiled program; the public functions are",(0,i.jsx)(n.br,{}),"\n","alternative entry points to the program. The virtual machine can start execution with\none of the public functions. A function library may have a main function to\nperform one-time initialization at startup."]}),"\n",(0,i.jsx)(n.p,{children:"To make a function public, prefix the function name with the keyword public.\nFor example, a text editor may call the public function \u201Conkey\u201D for every key\nthat the user typed in, so that the user can change (or reject) keystrokes. The\nonkey function below would replace every \u201C~\u201D character (code 126 in the ISO\nLatin-1 character set) by the \u201Chard space\u201D code in the ANSI character table:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: onkey function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\npublic onkey(keycode)\n{\n    if (key==\u2019~\u2019)\n        return 160 /* replace ~ by hard space (code 160 in Latin-1) */\n    else\n        return key /* leave other keys unaltered */\n}\n\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Example: 40"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Functions whose name starts with the \u201C@\u201D symbol are also public. So\nan alternative way to write the public function onkey function is:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: @onkey function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\n@onkey(keycode)\n    return key==\u2019~\u2019 ? 160 : key\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The \u201C@\u201D character, when used, becomes part of the function name; that is, in\nthe last example, the function is called \u201C@onkey\u201D. The host application decides\non the names of the public functions that a script may implement."}),"\n",(0,i.jsx)(n.p,{children:"Arguments of a public function may not have default values. A public func-\ntion interfaces the host application to the pawn script. Hence, the arguments\npassed to the public function originate from the host application, and the host\napplication cannot know what \u201Cdefault values\u201D the script writer plugged for\nfunction arguments \u2014which is why the pawn parser flags the use of default\nvalues for arguments of public functions as an error. The issue of default\nvalues in public function arguments only pops up in the case that you wish to call public functions from the script itself."}),"\n",(0,i.jsx)(n.h3,{id:"-static-functions",children:"\u2022 Static functions"}),"\n",(0,i.jsx)(n.p,{children:"When the function name is prefixed with the keyword static, the scope of the\nfunction is restricted to the file that the function resides in."}),"\n",(0,i.jsx)(n.p,{children:"The static attribute can be combined with the \u201Cstock\u201D attribute."}),"\n",(0,i.jsx)(n.h3,{id:"-stock-functions",children:"\u2022 Stock functions"}),"\n",(0,i.jsx)(n.p,{children:"A \u201Cstock\u201D function is a function that the pawn parser must \u201Cplug into\u201D the\nprogram when it is used, and that it may simply \u201Cremove\u201D from the program\n(without warning) when it is not used. Stock functions allow a compiler or\ninterpreter to optimize the memory footprint and the file size of a (compiled)\npawn program: any stock function that is not referred to, is completely skipped\n\u2014as if it were lacking from the source file."}),"\n",(0,i.jsxs)(n.p,{children:["A typical use of stock functions, hence, is in the creation of a set of\n\u201Clibrary\u201D functions. A collection of general purpose functions, all marked as \u201Cstock\u201D may\nbe put in a separate include file, which is then included in any pawn",(0,i.jsx)(n.br,{}),"\n","script. Only the library functions that are actually used get \u201Clinked\u201D in."]}),"\n",(0,i.jsx)(n.p,{children:"To declare a stock function, prefix the function name with the keyword stock.\nPublic functions and native functions cannot be declared \u201Cstock\u201D."}),"\n",(0,i.jsxs)(n.p,{children:["When a stock function calls other functions, it is usually a good practice to\ndeclare those other functions as \u201Cstock\u201D too \u2014with the exception of",(0,i.jsx)(n.br,{}),"\n","native functions. Similarly, any global variables that are used by a stock\nfunction should in most cases also be defined \u201Cstock\u201D. The removal of unused (stock)\nfunctions can cause a chain reaction in which other functions and global vari-\nables are not longer accessed either. Those functions are then removed as well,\nthereby continuing the chain reaction until only the functions that are used,\ndirectly or indirectly, remain."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Default values of function arguments: 75"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Public variables can be declared \u201Cstock\u201D"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Stock variables: 63"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-native-functions",children:"\u2022 Native functions"}),"\n",(0,i.jsx)(n.p,{children:"A pawn program can call application-specific functions through a \u201Cnative function\u201D.\nThe native function must be declared in the pawn program by means\nof a function prototype. The function name must be preceded by the keyword native."}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnative getparam(a[], b[], size)\n\nnative multiply_matrix(a[], b[], size)\n\nnative openfile(const name[])\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The names \u201Cgetparam\u201D, \u201Cmultiply_matrix\u201D and \u201Copenfile\u201D are the internal\nnames of the native functions; these are the names by which the",(0,i.jsx)(n.br,{}),"\n","functions are known in the pawn program. Optionally, you may also set an external\nname for the native function, which is the name of the function as the \u201Chost application\u201D knows it.\nTo do so, affix an equal sign to the function prototype followed by the external name. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnative getparam(a[], b[], size) = host_getparam\n\nnative multiply_matrix(a[], b[], size) = mtx_mul\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When a native function returns an array, the dimensions and size of the ar-\nray must be explicitly declared. The array specification occurs between",(0,i.jsx)(n.br,{}),"\n","the function name and the parameter list. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nenum rect { left, top, right, bottom }\nnative intersect[rect](src1[rect], src2[rect])\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"Unless specified explicitly, the external name is equal to the internal name of\na native function. One typical use for explicit external names is to set a\nsymbolic name for a user-defined operator that is implemented as a native function."}),"\n",(0,i.jsx)(n.p,{children:"See the \u201CImplementor\u2019s Guide\u201D for implementing native functions in C/C++(on the \u201Chost application\u201D side)."}),"\n",(0,i.jsx)(n.p,{children:"Native functions may not have state specifiers."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"An example of a native user-defined operator is on page 89"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-user-defined-operators",children:"\u2022 User-defined operators"}),"\n",(0,i.jsx)(n.p,{children:"The only data type of pawn is a \u201Ccell\u201D, typically a 32-bit number or bit\npattern."}),"\n",(0,i.jsx)(n.p,{children:"Tags: 68 The meaning of a value in a cell depends on the particular application \u2014it need\nnot always be a signed integer value. pawn allows to attach a \u201Cmeaning\u201D to a cell with its \u201Ctag\u201D mechanism."}),"\n",(0,i.jsxs)(n.p,{children:["Based on tags, pawn also allows you to redefine operators for cells",(0,i.jsx)(n.br,{}),"\n","with a specific purpose. The example below defines a tag \u201Cones\u201D and an",(0,i.jsx)(n.br,{}),"\n","operator to add two \u201Cones\u201D values together (the example also implements",(0,i.jsx)(n.br,{}),"\n","operators for subtraction and negation). The example was inspired by the checksum\nalgorithm of several protocols in the TCP/IP protocol suite: it simulates one\u2019s\ncomplement arithmetic by adding the carry bit of an arithmetic overflow back\nto the least significant bit of the value."]}),"\n",(0,i.jsx)(n.p,{children:"Listing: ones.p"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\nforward ones: operator+(ones: a, ones: b)\nforward ones: operator-(ones: a, ones: b)\nforward ones: operator-(ones: a)\n\nmain()\n{\n    new ones: chksum = ones: 0xffffffff\n    print "Input values in hexadecimal, zero to exit\\n"\n\n    new ones: value\n    do\n    {\n        print ">> "\n        value = ones: getvalue(.base=16)\n        chksum = chksum + value\n        printf "Checksum = %x\\n", chksum\n    }\n    while (value)\n}\n\nstock ones: operator+(ones: a, ones: b)\n{\n    const ones: mask = ones: 0xffff                 /* word mask */\n    const ones: shift = ones: 16                    /* word shift */\n\n    /* add low words and high words separately */\n    new ones: r1 = (a & mask) + (b & mask)\n    new ones: r2 = (a >>> shift) + (b >>> shift)\n\n    new ones: carry\n    restart:                                        /* code label (goto target) */\n\n    \\* add carry of the new low word to the high word, then\n    * strip it from the low word */\n\n    carry = (r1 >>> shift)\n    r2 += carry\n    r1 &= mask\n\n    \\* add the carry from the new high word back to the low\n    * word, then strip it from the high word */\n\n    carry = (r2 >>> shift)\n    r1 += carry\n    r2 &= mask\n\n    \\* a carry from the high word injected back into the low\n    * word may cause the new low to overflow, so restart in that case */\n\n    if (carry)\n        goto restart\n    return (r2 << shift) | r1\n}\n\nstock ones: operator-(ones: a)\n    return (a == ones: 0xffffffff) ? a : ~a\n\nstock ones: operator-(ones: a, ones: b)\n    return a + -b\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The notable line in the example is the line \u201Cchksum = chksum + value\u201D in\nthe loop in function main. Since both the variables chksum and value have\nthe tag ones, the \u201C+\u201D operator refers to the user-defined operator",(0,i.jsx)(n.br,{}),"\n","(instead of the default \u201C+\u201D operator). User-defined operators are merely a notational\nconvenience. The same effect is achieved by calling functions explicitly."]}),"\n",(0,i.jsxs)(n.p,{children:["The definition of an operator is similar to the definition of a function, with\nthe difference that the name of the operator is composed by the keyword \u201Copera-\ntor\u201D and the character of the operator itself. In the above example, both the\nunary \u201C-\u201D and the binary \u201C-\u201D operators are redefined. An operator function\nfor a binary operator must have two arguments, one for an unary",(0,i.jsx)(n.br,{}),"\n","operator must have one argument. Note that the binary \u201C-\u201D operator adds the two val-\nues together after inverting the sign of the second operand. The subtraction"]}),"\n",(0,i.jsx)(n.p,{children:"operator thereby refers to both the user-defined \u201Cnegation\u201D (unary \u201C-\u201D) and addition operators."}),"\n",(0,i.jsx)(n.p,{children:"A redefined operator must adhere to the following restrictions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"A user-defined operator must be declared before use (this is in contrast to \u201Cnormal\u201D functions): either put the implementation of the user-defined operator above the functions that use it, or add a forward declaration near the top of the file."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Only the following operators may be redefined: +, -, *, /, %, ++, --, ==, !=, <, > , <=, >=, ! and =. That is, the sets of arithmetic and relational operators can be overloaded, but the bitwise operators and the logical operators cannot. The = and ! operators are a special case."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"You cannot invent new operators; you cannot define operator \u201C#\u201D for example."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The precedence level and associativity of the operators, as well as their \u201Carity\u201D remain as defined. You cannot make an unary \u201C+\u201D operator, for example."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The return tag of the relational operators and of the \u201C!\u201D operator must be \u201Cbool:\u201D."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The return tag of the arithmetic operators is at your choosing, but you cannot redefine an operator that is identical to another operator except for its return tag. For example, you cannot make both ",(0,i.jsx)(n.code,{children:"alpha: operator+(alpha: a, alpha: b)"})," and ",(0,i.jsx)(n.code,{children:"beta: operator+(alpha: a, alpha: b)"})," (The assignment operator is an exception to this rule.)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"PAWN already defines operators to work on untagged cells, you cannot redefine the operators with only arguments without tags."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The arguments of the operator function must be non-arrays passed by value. You cannot make an operator work on arrays."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the example given above, both arguments of the binary operators have the\nsame tag. This is not required; you may, for example, define a",(0,i.jsx)(n.br,{}),"\n","binary \u201C+\u201D operator that adds an integer value to a \u201Cones:\u201D number."]}),"\n",(0,i.jsx)(n.p,{children:"Au fond, the operation of the pawn parser is to look up the tag(s)\nof the operand(s) that the operator works on and to look up whether a user-defined\noperator exists for the combination of the operator and the tag(s). However,\nthe parser recognizes special situations and provides the following features:"}),"\n",(0,i.jsxs)(n.p,{children:["The parser recognizes operators like \u201C+=\u201D as a sequence of \u201C+\u201D and",(0,i.jsx)(n.br,{}),"\n","\u201C=\u201D and it will call a user-defined operator \u201C+\u201D if available and/or a user-defined\noperator \u201C=\u201D. In the example program, the line \u201Cchksum = chksum + value\u201D\nmight have been abbreviated to \u201Cchksum += value\u201D."]}),"\n",(0,i.jsx)(n.p,{children:"The parser recognizes commutative operators (\u201C+\u201D, \u201C*\u201D, \u201C==\u201D, and \u201C!=\u201D)\nand it will swap the operands of a commutative operator if that produces\na fit with a user-defined operator. For example, there is usually no need to implement both"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"ones:operator+(ones:a, b)"})}),"\n",(0,i.jsx)(n.p,{children:"and"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"ones:operator+(a, ones:b)"})}),"\n",(0,i.jsx)(n.p,{children:"(implementing both functions is valid, and it is useful in case the user-defined\noperator should not be commutative)."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Prefix and postfix operators are handled automatically. You only need to define one user operator for the \u201C++\u201D and \u201C--\u201D operators for a tag."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The parser calls the \u201C!\u201D operator implicitly in case of a test without explicit comparison. For example, in the statement \u201Cif (var) ...\u201D when \u201Cvar\u201D has tag \u201Cones:\u201D, the user-defined operator \u201C!\u201D will be called for var. The \u201C!\u201D operator thus doubles as a \u201Ctest for zero\u201D operator. (In one\u2019s complement arithmetic, both the \u201Call-ones\u201D and the \u201Call-zeros\u201D bit patterns represent zero.)"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The user-defined assignment operator is implicitly called for a function argument that is passed \u201Cby value\u201D when the tag names of the formal and the actual arguments match the tag names of the left and right hand sides of the operator. In other words, the pawn parser simulates that \u201Cpass by value\u201D happens through assignment. The user-defined operator is not called for function arguments that are passed \u201Cby reference\u201D."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If you wish to forbid an operation, you can \u201Cforward declare\u201D the operator without ever defining it (see page 82). This will flag an error when the user-defined operator is invoked. For example, to forbid the \u201C%\u201D operator (remainder after division) on floating point values, you can add the line: ",(0,i.jsx)(n.code,{children:"forward Float: operator%(Float: a, Float: b)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"User-defined operators can optionally be declared \u201Cstock\u201D or \u201Cnative\u201D. In the case of a native operator function, the definition should include an external name. For example (when, on the host\u2019s side, the native function is called float_add):"}),"\n",(0,i.jsx)(n.p,{children:"Listing: native operator+ function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnative Float: operator+(Float: val, Float: val) = float_add\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The user-defined assignment operator is a special case, because it is an\noperator that has a side effect. Although the operator has the appearance of a binary\noperator, its \u201Cexpression result\u201D is the value at the right hand \u2014the assignment\noperator would be a \u201Cnull\u201D-operator if it weren\u2019t for its side-effect. In pawn\na user-defined assignment operator is declared as:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: operator= function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nones: operator=(a)\n\nreturn ones: ( (a >= 0) ? a : ~(-a) )\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The user-defined \u201C=\u201D operator looks like a unary operator in this\ndefinition, but it is a special case nevertheless. In contrast to the other\noperators, the tag of the return value for the user-defined operator is important: the pawn\nparser uses the tags of the argument and the return value to find a matching user-defined operator."}),"\n",(0,i.jsxs)(n.p,{children:["The example function above is a typical application for a user-defined assign-\nment operator: to automatically coerce/convert an untagged value to a tagged\nvalue, and to optionally change the memory representation of the value in the\nprocess. Specifically, the statement \u201Cnew ones",":A"," = -5\u201D causes the user-defined\noperator to run, and for the constant -5 the operator will return \u201C~(- -5)\u201D, or ~5, or \u22126.\u2217"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Tags: 68"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Forward declaration: 82"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"\u201CCall by value\u201D versus \u201Ccall by reference\u201D: 71"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Native functions: 85"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Rational literals: 98"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"#pragma rational: 121"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-floating-point-and-fixed-point-arithmetic",children:"\u2022 Floating point and fixed point arithmetic"}),"\n",(0,i.jsx)(n.p,{children:"pawn only has intrinsic support for integer arithmetic (the -domain: \u201Cwhole\nnumbers\u201D, both positive and negative). Support for floating point arithmetic\nor fixed point arithmetic must be implemented through (native) functions.\nUser operators, then, allow a more natural notation of expressions with fixed or floating point numbers."}),"\n",(0,i.jsx)(n.p,{children:"The pawn parser has support for literal values with a fractional part, which it\ncalls \u201Crational numbers\u201D. Support for rational literals must be enabled explic-\nitly with a #pragma. The #pragma indicates how the rational numbers must\nbe stored \u2014floating point or fixed point. For fixed point rational values, the\n#pragma also specifies the precision in decimals. Two examples for the #pragma are:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\n#pragma rational Float /* floating point format */\n#pragma rational Fixed(3) /* fixed point, with 3 decimals */\n\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h6,{id:"-modern-cpus-use-twos-complement-integer-arithmetic-for-positive-values-the-bitwise-representation-of-a-value-is-the-same-in-ones-complement-and-twos-complement-but-the-representations-differ-for-negative-values-for-instance-the-same-bit-pattern-that-means--5-in-ones-complement-stands-for--6-in-twos-complement",children:"\u2217 Modern CPUs use two\u2019s complement integer arithmetic. For positive values, the bitwise representation of a value is the same in one\u2019s complement and two\u2019s complement, but the representations differ for negative values. For instance, the same bit pattern that means -5 in one\u2019s complement stands for -6 in two\u2019s complement."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Since a fixed point value must still fit in a cell, the number of decimals\nhas a direct influence of the range of a fixed point value. For a fixed point value\nwith 3 decimals, the range would be \u22122, 147, 482 . . . + 2, 147, 482."}),"\n",(0,i.jsxs)(n.p,{children:["The format for a rational number may only be specified once for the entire\npawn program. In an implementation one typically chooses either",(0,i.jsx)(n.br,{}),"\n","floating point support or fixed point support. As stated above, for the actual imple-\nmentation of the floating point or fixed point arithmetic, pawn requires the\nhelp of (native) functions and user-defined operators. A good place to put\nthe #pragma for rational number support would be in the include file that",(0,i.jsx)(n.br,{}),"\n","also defines the functions and operators."]}),"\n",(0,i.jsx)(n.p,{children:"The include file \u2020 for fixed point arithmetic contains definitions like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnative Fixed: operator\\*(Fixed: val1, Fixed: val2) = fmul\nnative Fixed: operator/(Fixed: val1, Fixed: val2) = fdiv\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The user-defined operators for multiplication and division of two fixed\npoint numbers are aliased directly to the native functions fmul and fdiv. The host\napplication must, then, provide these native functions."}),"\n",(0,i.jsx)(n.p,{children:"Another native user-defined operator is convenient to transform an integer to\nfixed point automatically, if it is assigned to a variable tagged as \u201CFixed:\u201D:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nnative Fixed: operator=(oper) = fixed\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"With this definition, you can say \u201Cnew Fixed: fract = 3\u201D and the value\nwill be transformed to 3.000 when it is stored in variable fract. As explained\nin the section on user-defined operators, the assignment operator also runs for\nfunction arguments that are passed by value. In the expression \u201Cnew Fixed:\nroot = sqroot(16)\u201D (see the implementation of function sqroot on page 79),\nthe user-defined assignment operator is called on the argument 16."}),"\n",(0,i.jsx)(n.p,{children:"For adding two fixed point values together, the default \u201C+\u201D operator is suffi-\ncient, and the same goes for subtraction. Adding a normal (integer) number\nto a fixed point number is different: the normal value must be scaled before\nadding it. Hence, the include file implements operators for that purpose too:"}),"\n",(0,i.jsx)(n.h6,{id:"-see-the-application-note-fixed-point-support-library-for-where-to-obtain-the-include-file",children:"\u2020 See the application note \u201CFixed Point Support Library\u201D for where to obtain the include file."}),"\n",(0,i.jsx)(n.p,{children:"Listing: additive operators, commutative and non-commutative"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nstock Fixed: operator+(Fixed: val1, val2)\n    return val1 + fixed(val2)\n\nstock Fixed: operator-(Fixed: val1, val2)\n    return val1 - fixed(val2)\n\nstock Fixed: operator-(val1, Fixed: val2)\n    return fixed(val1) - val2\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The \u201C+\u201D operator is commutative, so one implementation handles both cases.\nFor the \u201C-\u201D operator, both cases must be implemented separately."}),"\n",(0,i.jsx)(n.p,{children:"Finally, the include file forbids the use of the modulus operator (\u201C%\u201D) on fixed\npoint values: the modulus is only applicable to integer values:"}),"\n",(0,i.jsx)(n.p,{children:"Listing: forbidden operators on fixed point values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"\nforward Fixed: operator%(Fixed: val1, Fixed: val2)\nforward Fixed: operator%(Fixed: val1, val2)\nforward Fixed: operator%(val1, Fixed: val2)\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Because of the presence of the (forward) declaration of the operator, the pawn\nparser will attempt to use the user-defined operator rather than the default\n\u201C%\u201D operator. By not implementing the operator, the parser will subsequently issue an error message.\n",(0,i.jsx)(n.code,{children:"User-defined operators: 86"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-call-by-value-and-call-by-reference",children:"\u2022 Call by Value and Call by Reference"}),"\n",(0,i.jsx)(n.p,{children:"In Pawn, function arguments can be passed in two ways: by value and by reference."}),"\n",(0,i.jsx)(n.h4,{id:"call-by-value",children:"Call by value"}),"\n",(0,i.jsx)(n.p,{children:"In this method, the value of the variable is passed to the function. A copy of the variable is created and the function operates on the copy, not the original variable. Any changes made to the variable inside the function do not affect the original variable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"swap(a, b){\n	new c = a;\n	a = b;\n	b = c;\n}\n\nmain(){\n	new x = 10, y = 20;\n	printf(\"The value of x is %d and value of y is %d, before calling 'swap'.\", x, y);\n	swap(x, y);\n	printf(\"The value of x is %d and value of y is %d, after calling 'swap'.\", x, y);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"The value of x is 10 and value of y is 20, before calling 'swap'.\nThe value of x is 10 and value of y is 20, after calling 'swap'.\n"})}),"\n",(0,i.jsx)(n.h4,{id:"call-by-reference",children:"Call by reference"}),"\n",(0,i.jsx)(n.p,{children:"In this method, the address of the variable is passed to the function. The function operates on the original variable and any changes made to the variable inside the function are reflected in the original variable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"swap(&a, &b){\n	new c = a;\n	a = b;\n	b = c;\n}\n\nmain(){\n	new x = 10, y = 20;\n	printf(\"The value of x is %d and value of y is %d, before calling 'swap'.\", x, y);\n	swap(x, y);\n	printf(\"The value of x is %d and value of y is %d, after calling 'swap'.\", x, y);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"The value of x is 10 and value of y is 20, before calling 'swap'.\nThe value of x is 20 and value of y is 10, after calling 'swap'.\n"})}),"\n",(0,i.jsx)(n.h3,{id:"-recursion--function-recursion",children:"\u2022 Recursion / Function Recursion"}),"\n",(0,i.jsx)(n.p,{children:"Recursion in programming refers to the process of a function calling itself in order to solve a problem. It's a fundamental concept used to solve problems that can be broken down into smaller instances of the same problem. Recursion consists of two main components: base cases and recursive cases."}),"\n",(0,i.jsx)(n.h5,{id:"base-case",children:"Base Case:"}),"\n",(0,i.jsx)(n.p,{children:"Every recursive function should have one or more base cases. A base case is a condition under which the function stops calling itself and returns a result directly. Without base cases, the recursion would continue indefinitely, causing a stack overflow. Read Stack/Heap section to know more about it."}),"\n",(0,i.jsx)(n.h5,{id:"recursive-case",children:"Recursive Case:"}),"\n",(0,i.jsx)(n.p,{children:"The recursive case is where the function calls itself to solve a smaller instance of the problem. Each recursive call should bring the problem closer to a base case."}),"\n",(0,i.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'stock factorial(n) {\n    // Base case: factorial of 0 is 1\n    if (n == 0) {\n        return 1;\n    }\n    // Recursive case: n! = n * (n - 1)!\n    else {\n        return n * factorial(n - 1);\n    }\n}\nmain() {\n    new num = 3;\n    new result = factorial(num);\n    printf("Factorial of %d is %d", num, result); // Output: Factorial of 3 is 6\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"demonstrate-the-output",children:"Demonstrate the Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"main() \\\\ main function from where execution of program starts\nnew num = 3; \\\\ creates a num variable\nnew result = factorial(num); \\\\ create a result variable and calls the factorial() with passing value of num, factorial(5)\nfactorial(3) \\\\ factorial initiate\n   if(3 == 0) \\\\ checks the condition which is false\n   else{ 3 * factorial(3-1) } \\\\ 3 * and calls the factorial(2)\n      factorial(2) \\\\ factorial initiate again\n         if(2 == 0) \\\\ checks the condition which is false\n         else{ 2 * factorial(2-1) } \\\\ 3 * 2 * and calls the factorial(1)\n            factorial(1) \\\\ factorial initiate again\n            if(1 == 0) \\\\ checks the condition which is false\n            else{ 1 * factorial(1-1) } \\\\ 3 * 2 * 1 and calls the factorial(0)\n 	       factorial(0) \\\\ factorial initiate again\n               if(0 == 0) return 1 \\\\ checks the conition which is true and return 1\n		\\\\ at the final call 3 * 2 * 1 * 1 \n"})}),"\n",(0,i.jsx)(n.h3,{id:"stack-memory",children:"Stack Memory"}),"\n",(0,i.jsx)(n.p,{children:"The stack is a region of memory used for storing local variables, function call information, and control flow data. It operates in a Last-In-First-Out (LIFO) manner, which means that the last item pushed onto the stack is the first one to be popped off."}),"\n",(0,i.jsx)(n.h4,{id:"example-stack-overflow",children:"Example (Stack Overflow)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#pragma dynamic 35 // (35 * 4 bytes, a cell size) #pragma dynamic [cells] helps to modify the size of stack, read docs/scripting/language/Directives to know more about #pragma\nmain(){\n	grow_stack(1);\n}\ngrow_stacK(n){ // recursive function\n	printf("N: %d", n);\n	grow_stacK(n+1);\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"output",children:"Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"N: 1\nN: 2\nN: 3\n.. .\nStack/heap collision (insufficient stack size)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://i.imgur.com/ZaIVUkJ.png",alt:"Stack"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/scripting/language/reference/Contents",children:"Go Back to Contents"})})]})}function d(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},50065:function(e,n,t){t.d(n,{Z:()=>o,a:()=>s});var a=t(67294);let i={},r=a.createContext(i);function s(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);