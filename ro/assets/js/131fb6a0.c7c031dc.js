"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["84972"],{24882:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>l,toc:()=>u,default:()=>o,metadata:()=>i,assets:()=>s,contentTitle:()=>t});var i=JSON.parse('{"id":"scripting/language/Initialisers","title":"Cuvant: Initializare","description":"const","source":"@site/i18n/ro/docusaurus-plugin-content-docs/current/scripting/language/Initialisers.md","sourceDirName":"scripting/language","slug":"/scripting/language/Initialisers","permalink":"/ro/docs/scripting/language/Initialisers","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/i18n/ro/docusaurus-plugin-content-docs/current/scripting/language/Initialisers.md","tags":[],"version":"current","frontMatter":{"title":"Cuvant: Initializare","sidebar_label":"Cuvant: Initializare"},"sidebar":"docsSidebar","previous":{"title":"Keywords: Directives","permalink":"/ro/docs/scripting/language/Directives"},"next":{"title":"Cuvant: Operatori","permalink":"/ro/docs/scripting/language/Operators"}}'),r=a(85893),c=a(50065);let l={title:"Cuvant: Initializare",sidebar_label:"Cuvant: Initializare"},t=void 0,s={},u=[{value:"<code>const</code>",id:"const",level:2},{value:"<code>enum</code>",id:"enum",level:2},{value:"<code>forward</code>",id:"forward",level:2},{value:"<code>native</code>",id:"native",level:2},{value:"<code>new</code>",id:"new",level:2},{value:"<code>operator</code>",id:"operator",level:2},{value:"<code>public</code>",id:"public",level:2},{value:"<code>static</code>",id:"static",level:2},{value:"<code>stock</code>",id:"stock",level:2}];function d(e){let n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"const",children:(0,r.jsx)(n.code,{children:"const"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"new const\n    MY_CONSTANT[] =  {1, 2, 3};\n"})}),"\n",(0,r.jsx)(n.p,{children:"const nu este utilizat pe scar\u0103 larg\u0103, \xeens\u0103 declar\u0103 o variabil\u0103 care nu poate fi modificat\u0103 prin cod. Exist\u0103 c\xe2teva utiliz\u0103ri pentru aceasta - func\u021Biile cu parametrii matricei const pot fi uneori compilate mai eficient sau este posibil s\u0103 dori\u021Bi ceva de genul a defini, dar care este o matrice. const este un modificator, trebuie s\u0103 mearg\u0103 cu un declarator de variabile nou sau altul. Dac\u0103 \xeencerca\u021Bi s\u0103 modifica\u021Bi o variabil\u0103 const, compilatorul se va pl\xe2nge."}),"\n",(0,r.jsx)(n.h2,{id:"enum",children:(0,r.jsx)(n.code,{children:"enum"})}),"\n",(0,r.jsx)(n.p,{children:"Enumer\u0103rile sunt un sistem foarte util pentru reprezentarea unor grupuri mari de date \u0219i modificarea rapid\u0103 a constantelor. Exist\u0103 c\xe2teva utiliz\u0103ri principale - \xeenlocuirea seturilor mari de instruc\u021Biuni de definire, reprezentarea simbolic\u0103 a sloturilor matrice (acestea sunt de fapt acela\u0219i lucru, dar arat\u0103 diferit) \u0219i crearea de noi etichete."}),"\n",(0,r.jsx)(n.p,{children:"De departe cea mai obi\u0219nuit\u0103 utilizare este definirea matricei:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_MY_ARRAY\n{\n    E_MY_ARRAY_MONEY,\n    E_MY_ARRAY_GUN\n}\n\nnew\n    gPlayerData[MAX_PLAYERS][E_MY_ARRAY];\n\npublic OnPlayerConnect(playerid)\n{\n    gPlayerData[playerid][E_MY_ARRAY_MONEY] = 0;\n    gPlayerData[playerid][E_MY_ARRAY_GUN] = 5;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Aceasta va crea o matrice cu dou\u0103 sloturi pentru fiecare juc\u0103tor. \xcen cel la care face referire E_MY_ARRAY_MONEY va pune 0 atunci c\xe2nd un juc\u0103tor se conecteaz\u0103 \u0219i 5 \xeen E_MY_ARRAY_GUN. F\u0103r\u0103 o enumere ar ar\u0103ta astfel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"new\n    gPlayerData[MAX_PLAYERS][2];\n\npublic OnPlayerConnect(playerid)\n{\n    gPlayerData[playerid][0] = 0;\n    gPlayerData[playerid][1] = 5;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u0218i a\u0219a compileaz\u0103 primul. Acest lucru este OK, cu toate acestea este mai pu\u021Bin lizibil - pentru ce este slotul 0 \u0219i pentru ce este slotul 1? \u0218i este mai pu\u021Bin flexibil, ce se \xeent\xe2mpl\u0103 dac\u0103 dori\u021Bi s\u0103 ad\u0103uga\u021Bi un alt spa\u021Biu \xeentre 0 \u0219i 1, trebuie s\u0103 redenumi\u021Bi toate 1s-urile \xeen 2s, ad\u0103uga\u021Bi-l pe cel nou \u0219i s\u0103 spera\u021Bi c\u0103 nu a\u021Bi pierdut nimic, atunci c\xe2nd ve\u021Bi face doar un enum:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_MY_ARRAY\n{\n    E_MY_ARRAY_MONEY,\n    E_MY_ARRAY_AMMO,\n    E_MY_ARRAY_GUN\n}\n\nnew\n    gPlayerData[MAX_PLAYERS][E_MY_ARRAY];\n\npublic OnPlayerConnect(playerid)\n{\n    gPlayerData[playerid][E_MY_ARRAY_MONEY] = 0;\n    gPlayerData[playerid][E_MY_ARRAY_AMMO] = 100;\n    gPlayerData[playerid][E_MY_ARRAY_GUN] = 5;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Recompila\u021Bi \u0219i totul va fi actualizat pentru dvs."}),"\n",(0,r.jsx)(n.p,{children:"Deci, de unde \u0219tie o enumere ce valori s\u0103 dea lucrurilor? Formatul complet al unei enum este:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum NAME (modifier)\n{\n    NAME_ENTRY_1 = value,\n    NAME_ENTRY_2 = value,\n    ...\n    NAME_ENTRY_N = value\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Oric\xe2t de mult este implicat acest lucru. \xcen mod implicit, dac\u0103 nu specifica\u021Bi un modificator, acesta devine (+ = 1), aceasta \xeenseamn\u0103 c\u0103 fiecare valoare din enum este ultima valoare din enum + 1, deci pentru:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE\n{\n    E_EXAMPLE_0,\n    E_EXAMPLE_1,\n    E_EXAMPLE_2\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Prima valoare (E_EXAMPLE_0) este 0 (implicit dac\u0103 nu este specificat\u0103 nicio alt\u0103 valoare), deci a doua valoare (E_EXAMPLE_1) este 1 (0 + 1) \u0219i a treia valoare (E_EXAMPLE_2) este 2 (1 + 1). Aceasta face ca valoarea E_EXAMPLE 3 (2 + 1), numele enumului s\u0103 fie \u0219i ultima valoare din enum. Dac\u0103 schimb\u0103m modificatorul ob\u021Binem valori diferite:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE (+= 5)\n{\n    E_EXAMPLE_0,\n    E_EXAMPLE_1,\n    E_EXAMPLE_2\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"In that example every value is the last value + 5 so, starting from 0 again, we get: E_EXAMPLE_0 = 0, E_EXAMPLE_1 = 5, E_EXAMPLE_2 = 10, E_EXAMPLE = 15. If you were to declare an array of:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"new\n    gEnumArray[E_EXAMPLE];\n"})}),"\n",(0,r.jsx)(n.p,{children:"You would get an array 15 cells big however you would only be able to access cells 0, 5 and 10 using the enum values (you could however still use normal numbers). Lets look at another example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE (*= 2)\n{\n    E_EXAMPLE_0,\n    E_EXAMPLE_1,\n    E_EXAMPLE_2\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\xcen aceasta toate valorile sunt 0. De ce? Ei bine, prima valoare implicit\u0103 este 0, apoi 0 _ 2 = 0, apoi 0 _ 2 = 0 \u0219i 0 \\ * 2 = 0. Deci, cum putem corecta acest lucru? Pentru aceasta sunt utilizate valorile personalizate:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE (*= 2)\n{\n    E_EXAMPLE_0 = 1,\n    E_EXAMPLE_1,\n    E_EXAMPLE_2\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Aceasta seteaz\u0103 prima valoare la 1, deci ajunge\u021Bi la 1, 2, 4 \u0219i 8. Crearea unui tablou cu care v\u0103 va oferi un tablou de 8 celule cu acces numit la celulele 1, 2 \u0219i 4. Pute\u021Bi seta oricare dintre valorile dvs. \u0219i c\xe2t de multe valori dori\u021Bi:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE (*= 2)\n{\n    E_EXAMPLE_0,\n    E_EXAMPLE_1 = 1,\n    E_EXAMPLE_2\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rezultand:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"0, 1, 2, 4\n"})}),"\n",(0,r.jsx)(n.p,{children:"Cat timp:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE (*= 2)\n{\n    E_EXAMPLE_0 = 1,\n    E_EXAMPLE_1 = 1,\n    E_EXAMPLE_2 = 1\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rezulta:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"1, 1, 1, 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"Nu este recomandat s\u0103 folosi\u021Bi altceva dec\xe2t + = 1 pentru tablouri."}),"\n",(0,r.jsx)(n.p,{children:"De asemenea, pute\u021Bi utiliza tablouri \xeen enumer\u0103ri:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_EXAMPLE\n{\n    E_EXAMPLE_0[10],\n    E_EXAMPLE_1,\n    E_EXAMPLE_2\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Acest lucru ar face E_EXAMPLE_0 = 0, E_EXAMPLE_1 = 10, E_EXAMPLE_2 = 11 \u0219i E_EXAMPLE = 12, contrar credin\u021Bei populare de 0, 1, 2 \u0219i 3."}),"\n",(0,r.jsx)(n.p,{children:"articolele enumere pot avea, de asemenea, etichete, deci pentru un exemplu original:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_MY_ARRAY\n{\n    E_MY_ARRAY_MONEY,\n    E_MY_ARRAY_AMMO,\n    Float:E_MY_ARRAY_HEALTH,\n    E_MY_ARRAY_GUN\n}\n\nnew\n    gPlayerData[MAX_PLAYERS][E_MY_ARRAY];\n\npublic OnPlayerConnect(playerid)\n{\n    gPlayerData[playerid][E_MY_ARRAY_MONEY] = 0;\n    gPlayerData[playerid][E_MY_ARRAY_AMMO] = 100;\n    gPlayerData[playerid][E_MY_ARRAY_GUN] = 5;\n    gPlayerData[playerid][E_MY_ARRAY_HEALTH] = 50.0;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Acest lucru nu va da o nepotrivire a etichetei."}),"\n",(0,r.jsx)(n.p,{children:"Enumurile pot fi folosite \u0219i ca etichete:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_MY_TAG (<<= 1)\n{\n    E_MY_TAG_NONE,\n    E_MY_TAG_VAL_1 = 1,\n    E_MY_TAG_VAL_2,\n    E_MY_TAG_VAL_3,\n    E_MY_TAG_VAL_4\n}\n\nnew\n    E_MY_TAG:gMyTagVar = E_MY_TAG_VAL_2 | E_MY_TAG_VAL_3;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Aceasta va crea o nou\u0103 variabil\u0103 \u0219i \xeei va atribui valoarea 6 (4 | 2) \u0219i va avea o etichet\u0103 personalizat\u0103 astfel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"gMyTagVar = 7;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Va genera un avertisment de nepotrivire a etichetelor, de\u0219i pute\u021Bi utiliza suprascrierea etichetelor pentru a o ocoli:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"gMyTagVar = E_MY_TAG:7;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Acest lucru poate fi foarte util pentru datele de semnalizare (adic\u0103 un bit pentru unele date) sau chiar pentru date combinate:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum E_MY_TAG (<<= 1)\n{\n    E_MY_TAG_NONE,\n    E_MY_TAG_MASK = 0xFF,\n    E_MY_TAG_VAL_1 = 0x100,\n    E_MY_TAG_VAL_2,\n    E_MY_TAG_VAL_3,\n    E_MY_TAG_VAL_4\n}\n\nnew\n    E_MY_TAG:gMyTagVar = E_MY_TAG_VAL_2 | E_MY_TAG_VAL_3 | (E_MY_TAG:7 & E_MY_TAG_MASK);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Care va produce o valoare de 1543 (0x0607)."}),"\n",(0,r.jsx)(n.p,{children:"\xcen cele din urm\u0103, dup\u0103 cum sa men\u021Bionat ini\u021Bial, enumurile pot fi folosite pentru a \xeenlocui defini\u021Biile prin angajarea numelui:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#define TEAM_NONE   0\n#define TEAM_COP    1\n#define TEAM_ROBBER 2\n#define TEAM_CIV    3\n#define TEAM_CLERK  4\n#define TEAM_DRIVER 5\n"})}),"\n",(0,r.jsx)(n.p,{children:"Sunt sigur c\u0103 mul\u021Bi dintre voi au v\u0103zut o mul\u021Bime de lucruri de genul acesta pentru a defini echipe. Totul este bine, dar este foarte static. Acest lucru poate fi u\u0219or \xeenlocuit cu un enum pentru a gestiona automat aloc\u0103rile numerice:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum\n{\n    TEAM_NONE,\n    TEAM_COP,\n    TEAM_ROBBER,\n    TEAM_CIV,\n    TEAM_CLERK,\n    TEAM_DRIVER\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Toate au acelea\u0219i valori ca \u0219i \xeenainte \u0219i pot fi utilizate exact \xeen acela\u0219i mod:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"new\n    gPlayerTeam[MAX_PLAYERS] = {TEAM_NONE, ...};\n\npublic OnPlayerConnect(playerid)\n{\n    gPlayerTeam[playerid] = TEAM_NONE;\n}\n\npublic OnPlayerRequestSpawn(playerid)\n{\n    if (gPlayerSkin[playerid] == gCopSkin)\n    {\n        gPlayerTeam[playerid] = TEAM_COP;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\xcen timp ce ne referim la subiect, exist\u0103 o modalitate mult mai bun\u0103 de a defini echipele pe baza acestei metode:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum (<<= 1)\n{\n    TEAM_NONE,\n    TEAM_COP = 1,\n    TEAM_ROBBER,\n    TEAM_CIV,\n    TEAM_CLERK,\n    TEAM_DRIVER\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Acum TEAM_COP este 1, TEAM_ROBBER este 2, TEAM_CIV este 4 etc, care \xeen binar este 0b00000001, 0b00000010 \u0219i 0b00000100. Aceasta \xeenseamn\u0103 c\u0103, dac\u0103 echipa unui juc\u0103tor este de 3, atunci se afl\u0103 at\xe2t \xeen \u200B\u200Bechipa de poli\u021Bi\u0219ti, c\xe2t \u0219i \xeen echipa de t\xe2lhari. Poate suna inutil, dar deschide posibilit\u0103\u021Bi:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum (<<= 1)\n{\n    TEAM_NONE,\n    TEAM_COP = 1,\n    TEAM_ROBBER,\n    TEAM_CIV,\n    TEAM_CLERK,\n    TEAM_DRIVER,\n    TEAM_ADMIN\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Folosind acest lucru, pute\u021Bi fi at\xe2t \xeentr-o echip\u0103 normal\u0103, c\xe2t \u0219i \xeen echipa de administratori, utiliz\xe2nd doar o singur\u0103 variabil\u0103. Evident, este necesar\u0103 o mic\u0103 modificare a codului, dar este u\u0219or:"}),"\n",(0,r.jsx)(n.p,{children:"Pentru a ad\u0103uga un juc\u0103tor la o echip\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"gPlayerTeam[playerid] |= TEAM_COP;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Pentru a elimina un juc\u0103tor dintr-o echip\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"gPlayerTeam[playerid] &= ~TEAM_COP;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Pentru a verifica dac\u0103 un juc\u0103tor face parte dintr-o echip\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"if (gPlayerTeam[playerid] & TEAM_COP)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Foarte simplu \u0219i foarte util."}),"\n",(0,r.jsx)(n.h2,{id:"forward",children:(0,r.jsx)(n.code,{children:"forward"})}),"\n",(0,r.jsx)(n.p,{children:"forward \xeei spune compilatorului c\u0103 o func\u021Bie vine mai t\xe2rziu. Este necesar pentru toate func\u021Biile publice, totu\u0219i poate fi utilizat \xeen alte locuri. Utilizarea sa este \u201Eforward\u201D urmat\u0103 de numele complet \u0219i parametrii func\u021Biei pe care dori\u021Bi s\u0103 o redirec\u021Biona\u021Bi, urmat\u0103 de un punct \u0219i virgul\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"forward MyPublicFunction(playerid, const string[]);\n\npublic MyPublicFunction(playerid, const string[])\n{\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Pe l\xe2ng\u0103 faptul c\u0103 este necesar pentru toate publicurile \xeenainte, poate fi folosit pentru a remedia un avertisment rar atunci c\xe2nd o func\u021Bie care returneaz\u0103 un rezultat de etichet\u0103 (de exemplu, un float) este utilizat\u0103 \xeenainte de a fi declarat\u0103."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"main()\n{\n    new\n        Float:myVar = MyFloatFunction();\n}\n\nFloat:MyFloatFunction()\n{\n    return 5.0;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Acest lucru va da un avertisment de reparare deoarece compilatorul nu \u0219tie cum s\u0103 converteasc\u0103 returnarea func\u021Biei \xeentr-un float, deoarece nu \u0219tie dac\u0103 func\u021Bia returneaz\u0103 un num\u0103r normal sau un float. \xcen mod clar, \xeen acest exemplu, returneaz\u0103 un float. Acest lucru poate fi rezolvat fie prin plasarea func\u021Biei \xeentr-un punct din cod \xeenainte de a fi utilizat\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Float:MyFloatFunction()\n{\n    return 5.0;\n}\n\nmain()\n{\n    new\n        Float:myVar = MyFloatFunction();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Sau prin redirec\u021Bionarea func\u021Biei, astfel \xeenc\xe2t compilatorul s\u0103 \u0219tie ce s\u0103 fac\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"forward Float:MyFloatFunction();\n\nmain()\n{\n    new\n        Float:myVar = MyFloatFunction();\n}\n\nFloat:MyFloatFunction()\n{\n    return 5.0;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Nota ca forward include si tagul pentru returnare."}),"\n",(0,r.jsx)(n.h2,{id:"native",children:(0,r.jsx)(n.code,{children:"native"})}),"\n",(0,r.jsx)(n.p,{children:"O func\u021Bie nativ\u0103 este una definit\u0103 \xeen ma\u0219ina virtual\u0103 (adic\u0103 lucrul care ruleaz\u0103 scriptul), nu \xeen scriptul \xeen sine. Pute\u021Bi defini func\u021Bii native numai dac\u0103 sunt codificate \xeen SA: MP sau \xeentr-un plugin, totu\u0219i pute\u021Bi crea nativi fal\u0219i. Deoarece func\u021Biile native din fi\u0219ierele .inc sunt detectate de pawno \u0219i listate \xeen caseta din partea dreapt\u0103 a pawno, poate fi util s\u0103 folosi\u021Bi native pentru a ob\u021Bine propriile func\u021Bii personalizate listate acolo. O declara\u021Bie nativ\u0103 normal\u0103 ar putea ar\u0103ta astfel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"native printf(const format[], \\{Float, _}:...);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Dac\u0103 dori\u021Bi ca propriile func\u021Bii s\u0103 apar\u0103 f\u0103r\u0103 a fi declarate native, pute\u021Bi face:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/*\nnative MyFunction(playerid);\n*/\n"})}),"\n",(0,r.jsx)(n.p,{children:"PAWNO nu recunoa\u0219te astfel de comentarii, a\u0219a c\u0103 va ad\u0103uga func\u021Bia la list\u0103, dar compilatorul recunoa\u0219te astfel de comentarii, a\u0219a c\u0103 va ignora declara\u021Bia."}),"\n",(0,r.jsx)(n.p,{children:"Cel\u0103lalt lucru interesant pe care \xeel po\u021Bi face cu nativ este func\u021Biile de redenumire / suprasarcin\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"native my_print(const string[]) = print;\n"})}),"\n",(0,r.jsx)(n.p,{children:'Acum func\u021Bia de tip\u0103rire nu exist\u0103 de fapt. Se afl\u0103 \xeenc\u0103 \xeen SA: MP, iar compilatorul \u0219tie c\u0103 este numele real datorit\u0103 p\u0103r\u021Bii "= print", dar dac\u0103 \xeencerca\u021Bi s\u0103 o apela\u021Bi \xeen PAWN, ve\u021Bi primi o eroare, deoarece a\u021Bi redenumit printul intern la my_print. Deoarece imprimarea nu exist\u0103 acum, o pute\u021Bi defini la fel ca orice alt\u0103 func\u021Bie:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'print(const string[])\n{\n    my_print("Someone called print()");\n    my_print(string);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Acum, de fiecare dat\u0103 c\xe2nd print () este utilizat \xeentr-un script, func\u021Bia dvs. va fi apelat\u0103 \xeen locul originalului \u0219i pute\u021Bi face ceea ce dori\u021Bi. \xcen acest caz este imprimat mai \xeent\xe2i un alt mesaj, apoi mesajul original."}),"\n",(0,r.jsx)(n.h2,{id:"new",children:(0,r.jsx)(n.code,{children:"new"})}),"\n",(0,r.jsx)(n.p,{children:"Acesta este nucleul variabilelor, unul dintre cele mai importante cuvinte cheie despre. new declar\u0103 o nou\u0103 variabil\u0103:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"new\n    myVar = 5;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Aceasta va crea o variabil\u0103, o va numi myVar \u0219i \xeei va atribui valoarea 5. \xcen mod implicit, toate variabilele sunt 0 dac\u0103 nu este specificat nimic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'new\n    myVar;\n\nprintf("%d", myVar);\n'})}),"\n",(0,r.jsx)(n.p,{children:"Va da \u201E0\u201D."}),"\n",(0,r.jsxs)(n.p,{children:["Domeniul de aplicare al unei variabile este locul \xeen care poate fi utilizat\u0103. Domeniul de aplicare este restric\u021Bionat de paranteze (parantezele curlate - ","), orice variabil\u0103 declarat\u0103 \xeen interiorul unui set de paranteze poate fi utilizat\u0103 numai \xeen acele paranteze."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'if (a == 1)\n{\n    // Braces start the line above this one\n    new\n        myVar = 5;\n\n    // This printf is in the same braces so can use myVar.\n    printf("%d", myVar);\n\n    // This if statement is also within the braces, so it and everything in it can use myVar\n    if (myVar == 1)\n    {\n        printf("%d", myVar);\n    }\n    // The braces end the line below this\n}\n// This is outside the braces so will give an error\nprintf("%d", myVar);\n'})}),"\n",(0,r.jsx)(n.p,{children:"Exemplul de mai sus arat\u0103, de asemenea, de ce este at\xe2t de important\u0103 indentarea corect\u0103."}),"\n",(0,r.jsx)(n.p,{children:"Dac\u0103 o variabil\u0103 global\u0103 (adic\u0103 una declarat\u0103 \xeen afara unei func\u021Bii) este declarat\u0103 nou\u0103, ea poate fi utilizat\u0103 peste tot dup\u0103 declara\u021Bie:"}),"\n",(0,r.jsx)(n.p,{children:"File1.pwn:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'MyFunc1()\n{\n    // Error, gMyVar doesn\'t exist yet\n    printf("%d", gMyVar);\n}\n\n// gMyVar is declared here\nnew\n    gMyVar = 10;\n\nMuFunc2()\n{\n    // Fine as gMyVar now exists\n    printf("%d", gMyVar);\n}\n\n// Include another file here\n#include "file2.pwn"\n'})}),"\n",(0,r.jsx)(n.p,{children:"file2.pwn:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'MyFunc3()\n{\n    // This is also fine as this file is included in the first file after the declaration and new is not file restricted\n    printf("%d", gMyVar);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"operator",children:(0,r.jsx)(n.code,{children:"operator"})}),"\n",(0,r.jsx)(n.p,{children:"Acest lucru v\u0103 permite s\u0103 supra\xeenc\u0103rca\u021Bi operatorii pentru etichete personalizate. De exemplu:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'stock BigEndian:operator=(b)\n{\n    return BigEndian:(((b >>> 24) & 0x000000FF) | ((b >>> 8) & 0x0000FF00) | ((b << 8) & 0x00FF0000) | ((b << 24) & 0xFF000000));\n}\n\nmain()\n{\n    new\n        BigEndian:a = 7;\n    printf("%d", _:a);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Numerele normale de amanet sunt stocate \xeen ceea ce se nume\u0219te mic endian. Acest operator v\u0103 permite s\u0103 defini\u021Bi o sarcin\u0103 pentru a converti un num\u0103r normal \xeentr-un num\u0103r mare endian. Diferen\u021Ba dintre endianul mare \u0219i endianul mic este ordinea de octe\u021Bi. 7 \xeen endian mic este stocat ca:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"07 00 00 00\n"})}),"\n",(0,r.jsx)(n.p,{children:"7 este bigendian si este stocat ca:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"00 00 00 07\n"})}),"\n",(0,r.jsx)(n.p,{children:"Prin urmare, dac\u0103 tip\u0103ri\u021Bi con\u021Binutul unui num\u0103r mare endian stocat, acesta va \xeencerca s\u0103-l citeasc\u0103 ca un mic num\u0103r endian \u0219i s\u0103 \xeel ob\u021Bin\u0103 \xeenapoi, imprim\xe2nd astfel num\u0103rul 0x07000000, aka 117440512, ceea ce ve\u021Bi ob\u021Bine dac\u0103 rula\u021Bi acest cod."}),"\n",(0,r.jsx)(n.p,{children:"Pute\u021Bi supra\xeenc\u0103rca urm\u0103torii operatori:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"+, -, *, /, %, ++, --, ==, !=, <, >, <=, >=, ! and =\n"})}),"\n",(0,r.jsx)(n.p,{children:"Re\u021Bine\u021Bi, de asemenea, c\u0103 \xeei pute\u021Bi face s\u0103 fac\u0103 orice dori\u021Bi:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'stock BigEndian:operator+(BigEndian:a, BigEndian:b)\n{\n    return BigEndian:42;\n}\n\nmain()\n{\n    new\n        BigEndian:a = 7,\n        BigEndian:b = 199;\n    printf("%d", _:(a + b));\n'})}),"\n",(0,r.jsx)(n.p,{children:"Va da pur \u0219i simplu 42, nimic de-a face cu ad\u0103ugarea."}),"\n",(0,r.jsx)(n.h2,{id:"public",children:(0,r.jsx)(n.code,{children:"public"})}),"\n",(0,r.jsx)(n.p,{children:"public este utilizat pentru a face o func\u021Bie vizibil\u0103 ma\u0219inii virtuale, adic\u0103 permite serverului SA: MP s\u0103 apeleze direct func\u021Bia, \xeen loc s\u0103 permit\u0103 apelarea func\u021Biei numai din interiorul scriptului PAWN. De asemenea, pute\u021Bi face variabile publice pentru a le citi \u0219i scrie valorile de pe server, totu\u0219i acest lucru nu este folosit niciodat\u0103 \xeen SA: MP (de\u0219i s-ar putea s\u0103 \xeel pute\u021Bi utiliza dintr-un plugin, nu am \xeencercat niciodat\u0103) (pute\u021Bi combina \u0219i acest lucru cu const pentru a crea o variabil\u0103 care poate fi modificat\u0103 DOAR de pe server)."}),"\n",(0,r.jsx)(n.p,{children:"O func\u021Bie public\u0103 are numele s\u0103u text stocat \xeen fi\u0219ierul amx, spre deosebire de func\u021Biile normale care \xee\u0219i au adresa stocat\u0103 doar pentru salturi, ceea ce reprezint\u0103 un alt dezavantaj al decompil\u0103rii. Aceasta este astfel \xeenc\xe2t s\u0103 pute\u021Bi apela func\u021Bia dup\u0103 nume din afara scriptului, v\u0103 permite, de asemenea, s\u0103 apela\u021Bi func\u021Biile dup\u0103 nume din interiorul scriptului, ie\u0219ind \u0219i reintroduc\xe2ndu-l. Un apel de func\u021Bie nativ\u0103 este aproape opusul unui apel de func\u021Bie public\u0103, apeleaz\u0103 o func\u021Bie din afara scriptului din interiorul scriptului, spre deosebire de apelarea unei func\u021Bii din interiorul scriptului din afara scriptului. Dac\u0103 combina\u021Bi cele dou\u0103, ve\u021Bi ob\u021Bine func\u021Bii precum SetTimer, SetTimerEx, CallRemoteFunction \u0219i CallLocalFunction care apeleaz\u0103 func\u021Bii dup\u0103 nume, nu adres\u0103."}),"\n",(0,r.jsx)(n.p,{children:"Apelarea unei func\u021Bii dup\u0103 nume:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'forward MyPublicFunc();\n\nmain()\n{\n    CallLocalFunction("MyPublicFunc", "");\n}\n\npublic MyPublicFunc()\n{\n    printf("Hello");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Func\u021Biile public prefixate fie cu \u201Epublic\u201D, fie cu \u201E@\u201D \u0219i, a\u0219a cum se men\u021Bioneaz\u0103 \xeen sec\u021Biunea forward, toate necesit\u0103 redirec\u021Bionare:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'forward MyPublicFunc();\nforward @MyOtherPublicFunc(var);\n\nmain()\n{\n    CallLocalFunction("MyPublicFunc", "");\n    SetTimerEx("@MyOtherPublicFunc", 5000, 0, "i", 7);\n}\n\npublic MyPublicFunc()\n{\n    printf("Hello");\n}\n\n@MyOtherPublicFunc(var)\n{\n    printf("%d", var);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Evident, acest exemplu a introdus SetTimerEx pentru a apela \u201EMyOtherPublicFunc\u201D dup\u0103 5 secunde \u0219i a-i da valoarea \xeentreag\u0103 7 pentru a imprima."}),"\n",(0,r.jsx)(n.p,{children:"main, utilizat \xeen majoritatea acestor exemple, este similar cu o func\u021Bie public\u0103 prin aceea c\u0103 poate fi apelat\u0103 din afara scriptului, totu\u0219i nu este o func\u021Bie public\u0103 - are doar o adres\u0103 cunoscut\u0103 special\u0103, astfel \xeenc\xe2t serverul s\u0103 \u0219tie unde s\u0103 treac\u0103 la rula\u021Bi-l."}),"\n",(0,r.jsx)(n.p,{children:"Toate apelurile de apelare SA: MP sunt publice \u0219i sunt apelate automat din afara scriptului:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'public OnPlayerConnect(playerid)\n{\n    printf("%d connected", playerid);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"C\xe2nd cineva se al\u0103tur\u0103 serverului, acesta va c\u0103uta automat aceast\u0103 func\u021Bie public\u0103 \xeen toate scripturile (mai \xeent\xe2i modul de joc, apoi filtreaz\u0103 scripturile) \u0219i, dac\u0103 \xeel g\u0103se\u0219te, \xeel apeleaz\u0103."}),"\n",(0,r.jsx)(n.p,{children:"Dac\u0103 dori\u021Bi s\u0103 apela\u021Bi o func\u021Bie public\u0103 din interiorul scriptului, totu\u0219i nu trebuie s\u0103 o apela\u021Bi dup\u0103 nume, func\u021Biile publice se comport\u0103 \u0219i ca func\u021Bii normale:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'forward MyPublicFunc();\n\nmain()\n{\n    MyPublicFunc();\n}\n\npublic MyPublicFunc()\n{\n    printf("Hello");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Acest lucru este, evident, mult mai rapid dec\xe2t utilizarea CallLocalFunction sau a altui nativ."}),"\n",(0,r.jsx)(n.h2,{id:"static",children:(0,r.jsx)(n.code,{children:"static"})}),"\n",(0,r.jsx)(n.p,{children:"O variabil\u0103 static\u0103 este ca o nou\u0103 variabil\u0103 global\u0103, dar cu un domeniu de aplicare mai limitat. C\xe2nd statica este utilizat\u0103 global, variabilele create rezultate sunt limitate doar la sec\u021Biunea \xeen care au fost create (a se vedea # sec\u021Biune). A\u0219adar, lu\xe2nd exemplul \u201Enou\u201D anterior:"}),"\n",(0,r.jsx)(n.p,{children:"file1.pwn"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'MyFunc1()\n{\n    // Error, gMyVar doesn\'t exist yet\n    printf("%d", gMyVar);\n}\n\n// gMyVar is declared here\nnew\n    gMyVar = 10;\n\nMuFunc2()\n{\n    // Fine as gMyVar now exists\n    printf("%d", gMyVar);\n}\n\n// Include another file here\n#include "file2.pwn"\n'})}),"\n",(0,r.jsx)(n.p,{children:"file2.pwn"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'MyFunc3()\n{\n    // This is also fine as this file is included in the first file after the declaration and new is not file restricted\n    printf("%d", gMyVar);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"\u0218i modificarea acestuia pentru static\u0103 ar da:"}),"\n",(0,r.jsx)(n.p,{children:"file1.pwn"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'MyFunc1()\n{\n    // Error, g_sMyVar doesn\'t exist yet\n    printf("%d", g_sMyVar);\n}\n\n// g_sMyVar is declared here\nstatic\n    g_sMyVar = 10;\n\nMuFunc2()\n{\n    // Fine as _sgMyVar now exists\n    printf("%d", g_sMyVar);\n}\n\n// Include another file here\n#include "file2.pwn"\n'})}),"\n",(0,r.jsx)(n.p,{children:"file2.pwn"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'MyFunc3()\n{\n    // Error, g_sMyVar is limited to only the file (or section) in which it was declared, this is a different file\n    printf("%d", g_sMyVar);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Aceasta \xeenseamn\u0103 c\u0103 pute\u021Bi avea doi globali cu acela\u0219i nume \xeen fi\u0219iere diferite."}),"\n",(0,r.jsx)(n.p,{children:"Dac\u0103 utiliza\u021Bi static local (adic\u0103 \xeentr-o func\u021Bie), atunci variabila, ca \u0219i variabilele locale create cu nou, poate fi utilizat\u0103 numai \xeen cadrul domeniului (bazat pe paranteze - consulta\u021Bi sec\u021Biunea despre \u201Enou\u201D) \xeen care a fost declarat\u0103. Cu toate acestea, spre deosebire de variabilele \u201Enoi\u201D, variabilele \u201Estatice\u201D nu \xee\u0219i pierd valoarea \xeentre apeluri."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'main()\n{\n    for (new loopVar = 0; loopVar < 4; loopVar++)\n    {\n        MyFunc();\n    }\n}\n\nMyFunc()\n{\n    new\n        i = 0;\n    printf("%d", i);\n    i++;\n    printf("%d", i);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"De fiecare dat\u0103 c\xe2nd func\u021Bia este numit\u0103 i este resetat\u0103 la 0, astfel \xeenc\xe2t ie\u0219irea rezultat\u0103 va fi:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"0\n1\n0\n1\n0\n1\n0\n1\n"})}),"\n",(0,r.jsx)(n.p,{children:"Dac\u0103 \xeenlocuim \u201Enoul\u201D cu \u201Estatic\u201D ob\u021Binem:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'main()\n{\n    for (new loopVar = 0; loopVar < 4; loopVar++)\n    {\n        MyFunc();\n    }\n}\n\nMyFunc()\n{\n    static\n        i = 0;\n    printf("%d", i);\n    i++;\n    printf("%d", i);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"\u0218i, deoarece localnicii statici \xee\u0219i p\u0103streaz\u0103 valoarea \xeentre apeluri, rezultatul rezultat este:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"0\n1\n1\n2\n2\n3\n3\n4\n"})}),"\n",(0,r.jsx)(n.p,{children:"Valoarea dat\u0103 \xeen declara\u021Bie (dac\u0103 este dat\u0103 una, ca \u0219i variabilele statice noi, implicite la 0) este valoarea atribuit\u0103 variabilei la prima apelare a func\u021Biei. Deci, dac\u0103 \u201Estatic i = 5;\u201D au fost folosite \xeen schimb, rezultatul ar fi:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"5\n6\n6\n7\n7\n8\n8\n9\n"})}),"\n",(0,r.jsx)(n.p,{children:"Datorit\u0103 modului \xeen care sunt stocate variabilele statice, ele sunt de fapt variabile globale, compilatorul verific\u0103 dac\u0103 sunt utilizate \xeen locul corect. Ca urmare, scripturile decompilate nu pot face distinc\u021Bie \xeentre globale normale, statici globale \u0219i statici locale \u0219i toate sunt date ca globale normale."}),"\n",(0,r.jsx)(n.p,{children:"De asemenea, pute\u021Bi avea func\u021Bii statice care pot fi apelate numai din fi\u0219ierul \xeen care sunt declarate. Acest lucru este util pentru func\u021Biile de stil privat."}),"\n",(0,r.jsx)(n.h2,{id:"stock",children:(0,r.jsx)(n.code,{children:"stock"})}),"\n",(0,r.jsx)(n.p,{children:"stock este folosit pentru a declara variabile \u0219i func\u021Bii care nu pot fi utilizate, dar pentru care nu dori\u021Bi s\u0103 genera\u021Bi avertismente neutilizate. Cu variabilele stocul este ca const prin faptul c\u0103 este un modificator, nu o declara\u021Bie complet\u0103, deci a\u021Bi putea avea:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"new stock\n    gMayBeUsedVar;\n\nstatic stock\n    g_sMayBeUsedVar;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Dac\u0103 se utilizeaz\u0103 variabila sau func\u021Bia, compilatorul o va include, dac\u0103 nu este utilizat\u0103, o va exclude. Acest lucru este diferit de utilizarea #pragma unused (simbol), deoarece aceasta va suprima (adic\u0103 ascunde) avertismentul \u0219i va include oricum informa\u021Biile, stocul va ignora \xeen totalitate datele neutilizate."}),"\n",(0,r.jsx)(n.p,{children:"stockul este cel mai frecvent utilizat pentru bibliotecile personalizate. Dac\u0103 scrie\u021Bi o bibliotec\u0103, furniza\u021Bi o mul\u021Bime de func\u021Bii pe care alte persoane le pot folosi, dar nu ave\u021Bi nicio idee dac\u0103 le vor folosi sau nu. Dac\u0103 codul dvs. ofer\u0103 o mul\u021Bime de avertismente pentru fiecare func\u021Bie pe care o persoan\u0103 nu o folose\u0219te, oamenii se vor pl\xe2nge (cu excep\u021Bia cazului \xeen care este inten\u021Bionat, deoarece TREBUIE s\u0103 foloseasc\u0103 acea func\u021Bie (de exemplu, pentru ini\u021Bializarea variabilelor). Acestea fiind spuse \xeens\u0103, trec\xe2nd din experien\u021Ba personal\u0103 cu oamenii YSI se va pl\xe2nge oricum."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'main()\n{\n    Func1();\n}\n\nFunc1()\n{\n    printf("Hello");\n}\n\nFunc2()\n{\n    printf("Hi");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Aici Func2 nu este apelat niciodat\u0103, astfel \xeenc\xe2t compilatorul va da un avertisment. Acest lucru poate fi util deoarece a\u021Bi uitat s\u0103-l numi\u021Bi, a\u0219a cum se \xeent\xe2mpl\u0103 \xeen general \xeentr-un script direct, cu toate acestea, dac\u0103 Func1 \u0219i Func2 se afl\u0103 \xeentr-o bibliotec\u0103, este posibil ca utilizatorul s\u0103 nu aib\u0103 nevoie de Func2, deci face\u021Bi:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'main()\n{\n    Func1();\n}\n\nstock Func1()\n{\n    printf("Hello");\n}\n\nstock Func2()\n{\n    printf("Hi");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Iar func\u021Bia nu va fi compilat\u0103 \u0219i avertismentul eliminat."})]})}function o(e={}){let{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},50065:function(e,n,a){a.d(n,{Z:()=>t,a:()=>l});var i=a(67294);let r={},c=i.createContext(r);function l(e){let n=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);