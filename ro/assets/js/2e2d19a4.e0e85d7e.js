"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["70584"],{39210:function(e,a,i){i.r(a),i.d(a,{frontMatter:()=>l,toc:()=>c,default:()=>d,metadata:()=>n,assets:()=>u,contentTitle:()=>s});var n=JSON.parse('{"id":"tutorials/AdvancedStructures","title":"Structuri avansate","description":"Manipularea matricei","source":"@site/i18n/ro/docusaurus-plugin-content-docs/current/tutorials/AdvancedStructures.md","sourceDirName":"tutorials","slug":"/tutorials/AdvancedStructures","permalink":"/ro/docs/tutorials/AdvancedStructures","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/docs/tutorials/AdvancedStructures.md","tags":[],"version":"current","frontMatter":{"title":"Structuri avansate","sidebar_label":"Structuri avansate"},"sidebar":"docsSidebar","previous":{"title":"sa-mp.cfg","permalink":"/ro/docs/client/sa-mp.cfg"},"next":{"title":"Binar","permalink":"/ro/docs/tutorials/Binary"}}'),t=i(85893),r=i(50065);let l={title:"Structuri avansate",sidebar_label:"Structuri avansate"},s=void 0,u={},c=[{value:"Manipularea matricei",id:"manipularea-matricei",level:2},{value:"G\u0103sirea corect\u0103 a unui slot gol",id:"g\u0103sirea-corect\u0103-a-unui-slot-gol",level:3},{value:"Lista",id:"lista",level:3},{value:"Introducere",id:"introducere",level:4},{value:"Types",id:"types",level:4},{value:"Liste mixte",id:"liste-mixte",level:4},{value:"Cod",id:"cod",level:4},{value:"Copaci binari",id:"copaci-binari",level:3},{value:"Introducere",id:"introducere-1",level:4},{value:"Balansat si nebalansat",id:"balansat-si-nebalansat",level:4},{value:"Adaugare",id:"adaugare",level:4},{value:"Stergere",id:"stergere",level:4}];function o(e){let a={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.h2,{id:"manipularea-matricei",children:"Manipularea matricei"}),"\n",(0,t.jsx)(a.h3,{id:"g\u0103sirea-corect\u0103-a-unui-slot-gol",children:"G\u0103sirea corect\u0103 a unui slot gol"}),"\n",(0,t.jsx)(a.p,{children:"Acest exemplu arat\u0103 cum s\u0103 g\u0103si\u021Bi un slot gol \xeentr-o matrice folosind practicile standard de codare."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"new\n    gMyArray[10];\n\nstock FindEmptySlot()\n{\n    new\n        i = 0;\n    while (i < sizeof (gMyArray) && gMyArray[i])\n    {\n        i++;\n    }\n    if (i == sizeof (gMyArray)) return -1;\n    return i;\n}\n"})}),"\n",(0,t.jsx)(a.p,{children:"Acest exemplu de baz\u0103 presupune c\u0103 un slot de matrice este gol dac\u0103 valoarea sa este 0. Bucla parcurge toate valorile din matrice (s-ar putea face \u0219i cu o constant\u0103) at\xe2ta timp c\xe2t valorile nu sunt 0. C\xe2nd atinge una care este 0 \xeen timp ce starea va e\u0219ua \u0219i bucla se termin\u0103 f\u0103r\u0103 a utiliza o pauz\u0103, a\u0219a cum este practic\u0103 obi\u0219nuit\u0103, dar descurajat\u0103 \xeen astfel de situa\u021Bii. Aceast\u0103 func\u021Bie returneaz\u0103 \u0219i -1 dac\u0103 nu se g\u0103se\u0219te un slot liber, care ar trebui verificat la cel\u0103lalt cap\u0103t. \xcen mod obi\u0219nuit, a\u021Bi folosi imediat identificatorul g\u0103sit:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:'MyFunction()\n{\n    new\n        i = 0;\n    while (i < sizeof (gMyArray) && gMyArray[i])\n    {\n        i++;\n    }\n    if (i == sizeof (gMyArray))\n    {\n        printf("No free slot found");\n        return 0;\n    }\n    printf("Slot %d is empty", i);\n    // Use the found slot in your code for whatever\n    return 1;\n}\n'})}),"\n",(0,t.jsx)(a.p,{children:"Evident, a\u021Bi \xeenlocui expresia \u201EgMyArray[i]\u201D cu propria dvs. indica\u021Bie a unui slot \xeen uz."}),"\n",(0,t.jsx)(a.h3,{id:"lista",children:"Lista"}),"\n",(0,t.jsx)(a.h4,{id:"introducere",children:"Introducere"}),"\n",(0,t.jsx)(a.p,{children:"Listele sunt un tip de structur\u0103 foarte util\u0103, sunt practic o matrice \xeen care urm\u0103toarea pies\u0103 sau datele relevante sunt ar\u0103tate de ultima pies\u0103."}),"\n",(0,t.jsx)(a.p,{children:"Exemplu:"}),"\n",(0,t.jsx)(a.p,{children:"Spune\u021Bi c\u0103 ave\u021Bi urm\u0103toarea matrice:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"3, 1, 64, 2, 4, 786, 2, 9\n"})}),"\n",(0,t.jsx)(a.p,{children:"Dac\u0103 dori\u021Bi s\u0103 sorta\u021Bi matricea, ve\u021Bi termina cu:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"1, 2, 2, 3, 4, 9, 64, 786\n"})}),"\n",(0,t.jsx)(a.p,{children:"Dac\u0103 totu\u0219i a\u021Bi dorit s\u0103 l\u0103sa\u021Bi datele \xeen ordinea ini\u021Bial\u0103, dar \u0219ti\u021Bi numerele \xeen ordine din anumite motive (este doar un exemplu), ave\u021Bi o problem\u0103, cum dori\u021Bi s\u0103 ave\u021Bi numere \xeen dou\u0103 ordine simultan? Aceasta ar fi o bun\u0103 utilizare a listelor. Pentru a construi o list\u0103 din aceste date, ar trebui s\u0103 transforma\u021Bi matricea \xeentr-o matrice 2d, unde a doua dimensiune avea 2 celule mari, prima dimensiune con\u021Bin\xe2nd num\u0103rul original, cealalt\u0103 con\u021Bin\xe2nd indexul urm\u0103torului num\u0103r cel mai mare. De asemenea, a\u021Bi avea nevoie de o variabil\u0103 separat\u0103 pentru a men\u021Bine indicele celui mai mic num\u0103r, astfel \xeenc\xe2t noua matrice ar ar\u0103ta astfel:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"start = 1\n3, 1, 64, 2, 4, 786, 2, 9\n4, 3, 5,  6, 7, -1,  0, 2\n"})}),"\n",(0,t.jsx)(a.p,{children:"Urm\u0103torul index asociat cu 786 este -1, acesta este un index de matrice nevalid \u0219i indic\u0103 sf\xe2r\u0219itul listei, adic\u0103 nu mai sunt numere. Cele dou\u0103 2 ar putea fi, evident, \xeen sens invers, primul din matrice este \u0219i primul din list\u0103, deoarece este cel mai probabil s\u0103 fie \xeent\xe2mpinat mai \xeent\xe2i."}),"\n",(0,t.jsx)(a.p,{children:"Cel\u0103lalt avantaj al acestei metode de sortare a numerelor este c\u0103 se adaug\u0103 mai multe numere este mult mai rapid. Dac\u0103 dori\u021Bi s\u0103 ad\u0103uga\u021Bi un alt num\u0103r 3 la matricea sortat\u0103, ar trebui s\u0103 schimba\u021Bi mai \xeent\xe2i cel pu\u021Bin 4 numere un slot spre dreapta pentru a face spa\u021Biu, nu teribil aici, dar foarte lent \xeen matrici mai mari. Cu versiunea list\u0103, pute\u021Bi ad\u0103uga doar 3 la sf\xe2r\u0219itul matricei \u0219i pute\u021Bi modifica o singur\u0103 valoare din list\u0103:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"start = 1\n3, 1, 64, 2, 4, 786, 2, 9, 3\n8, 3, 5,  6, 7, -1,  0, 2, 4\n^ modifica aceasta valoare ^ urmatorul cel mai mare slot\n"})}),"\n",(0,t.jsx)(a.p,{children:"Niciunul dintre celelalte numere nu s-a mutat, astfel \xeenc\xe2t niciunul dintre ceilal\u021Bi indici nu trebuie actualizat, trebuie doar s\u0103 indica\u021Bi urm\u0103torul num\u0103r cel mai sc\u0103zut c\u0103tre noul num\u0103r \u0219i s\u0103 face\u021Bi ca noul num\u0103r s\u0103 fie num\u0103rul c\u0103tre urm\u0103torul cel mai sc\u0103zut obi\u0219nuit. Eliminarea unei valori este \u0219i mai u\u0219oar\u0103:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"start = 1\n3, 1, 64, X, 4, 786, 2, 9, 3\n8, 6, 5,  6, 7, -1,  0, 2, 4\n   ^ Changed to jump over the removed value\n"})}),"\n",(0,t.jsx)(a.p,{children:"Aici primele 2 au fost eliminate \u0219i num\u0103rul care indica acest num\u0103r (1) a fost actualizat pentru a indica num\u0103rul c\u0103tre care era \xeendreptat num\u0103rul eliminat. \xcen acest exemplu, nici indicatorul \u0219i num\u0103rul num\u0103rului eliminat nu au fost eliminate, dar nu pute\u021Bi ajunge la acel slot urm\xe2nd lista, deci nu conteaz\u0103, este efectiv eliminat."}),"\n",(0,t.jsx)(a.h4,{id:"types",children:"Types"}),"\n",(0,t.jsx)(a.p,{children:"Listele din exemplele de mai sus au fost doar liste simple de baz\u0103, pute\u021Bi avea, de asemenea, liste duble \xeen care fiecare valoare indic\u0103 urm\u0103toarea valoare \u0219i ultima valoare, acestea tind s\u0103 aib\u0103 un pointer la sf\xe2r\u0219itul listei \u0219i pentru a merge \xeenapoi (de exemplu la ob\u021Bine\u021Bi numerele \xeen ordine descresc\u0103toare):"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"start = 1\nend = 5\nvalue: 3, 1,  64, 2, 4, 786, 2, 9, 3\nnext:  8, 3,  5,  6, 7, -1,  0, 2, 4\nlast:  6, -1, 7,  1, 8, 2,   3, 4, 0\n"})}),"\n",(0,t.jsx)(a.p,{children:"Trebuie s\u0103 ave\u021Bi grij\u0103 la acestea, mai ales atunci c\xe2nd ave\u021Bi mai mult de una dintre orice valori, ca ultimul indicator s\u0103 indice num\u0103rul care este urm\u0103torul indicator care revine direct \xeenapoi, de exemplu, acest lucru este gre\u0219it:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"2,  3, 3\n1,  2, -1\n-1, 2, 0\n"})}),"\n",(0,t.jsx)(a.p,{children:"Urm\u0103torul indicator al 2 indic\u0103 3 \xeen slotul unu, dar ultimul indicator al lui 3 nu revine la cele dou\u0103, ambele liste sunt \xeen ordine pe cont propriu (deoarece cele dou\u0103 trei pot fi \xeen sens invers), dar \xeempreun\u0103 sunt gre\u0219ite , versiunea corect\u0103 ar fi:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"2,  3, 3\n1,  2, -1\n-1, 0, 2\n"})}),"\n",(0,t.jsx)(a.p,{children:"Ambele liste \xeencep \u0219i se termin\u0103 la sf\xe2r\u0219itul a dou\u0103 numere, lista din spate \xeen exemplul gre\u0219it a \xeenceput pe num\u0103rul din mijloc."}),"\n",(0,t.jsx)(a.p,{children:"Cel\u0103lalt tip de list\u0103 este cel \xeen bucl\u0103, unde ultima valoare arat\u0103 \xeenapoi la prima. Avantajul evident al acestui lucru este c\u0103 pute\u021Bi ajunge la orice valoare din orice alt\u0103 valoare f\u0103r\u0103 s\u0103 \u0219ti\u021Bi \xeen prealabil dac\u0103 \u021Binta este \xeenainte sau dup\u0103 punctul de pornire, trebuie doar s\u0103 ave\u021Bi grij\u0103 s\u0103 nu intra\u021Bi \xeentr-o bucl\u0103 infinit\u0103, deoarece nu exist\u0103 niciun fel explicit - 1 punct final. Aceste liste au \xeenc\u0103 puncte de \xeenceput. Pute\u021Bi face, de asemenea, liste cu bucl\u0103 dubl\u0103, \xeen cazul \xeen care ave\u021Bi o list\u0103 urm\u0103toare \u0219i ultima, ambele rotunjite \xeen bucl\u0103:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"start = 1\nend = 5\n3, 1,  64, 2, 4, 786, 2, 9, 3\n8, 3,  5,  6, 7, 1,   0, 2, 4\n6, 5,  7,  1, 8, 2,   3, 4, 0\n"})}),"\n",(0,t.jsx)(a.h4,{id:"liste-mixte",children:"Liste mixte"}),"\n",(0,t.jsx)(a.p,{children:"Listele mixte sunt tablouri care con\u021Bin mai multe liste simultan. Un exemplu ar putea fi o serie de valori, sortate dup\u0103 o list\u0103, cu o alt\u0103 list\u0103 care leag\u0103 toate sloturile neutilizate, astfel \xeenc\xe2t s\u0103 \u0219ti\u021Bi unde pute\u021Bi ad\u0103uga o nou\u0103 valoare. Exemplu (X \xeenseamn\u0103 slot nefolosit (gol)):"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"sortedStart = 3\nunusedStart = 1\nvalue: 34, X, X, 6, 34, 46, X,  54, 23, 25, X,  75, X, 45\nsort:  4,        8, 13, 7,      11, 9,  0,      -1,    5\nfree:      2, 6,            10,             12,     -1\n"})}),"\n",(0,t.jsx)(a.p,{children:"Evident, cele dou\u0103 liste nu interac\u021Bioneaz\u0103 niciodat\u0103, astfel \xeenc\xe2t ambele pot folosi acela\u0219i slot pentru urm\u0103toarea lor valoare:"}),"\n",(0,t.jsx)(a.h4,{id:"cod",children:"Cod"}),"\n",(0,t.jsx)(a.p,{children:"\xcenainte de a \xeencepe codul, trebuie s\u0103 decide\u021Bi ce tip de list\u0103 este cel mai potrivit pentru aplica\u021Bia dvs., aceasta se bazeaz\u0103 \xeen totalitate pe aplica\u021Bie care nu poate fi acoperit\u0103 cu u\u0219urin\u021B\u0103 aici. Toate aceste exemple sunt liste mixte, o list\u0103 pentru valorile necesare, una pentru sloturile neutilizate."}),"\n",(0,t.jsx)(a.p,{children:"Acest exemplu arat\u0103 cum se scrie cod pentru o list\u0103 sortat\u0103 numeric cresc\u0103tor."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"#define NUMBER_OF_VALUES (10)\n\nenum E_DATA_LIST\n{\n    E_DATA_LIST_VALUE,\n    E_DATA_LIST_NEXT\n}\n\nnew\n    gListData[NUMBER_OF_VALUES][E_DATA_LIST],\n    gUnusedStart = 0,\n    gListStart = -1; // Starts off with no list\n\n// This function initializes the list\nList_Setup()\n{\n    new\n        i,\n        size = NUMBER_OF_VALUES;\n    size--;\n    for (i = 0; i < size; i++)\n    {\n        // To start with all slots are unused\n        gListData[i][E_DATA_LIST_NEXT] = i + 1;\n    }\n    // End the list\n    gListData[size][E_DATA_LIST_NEXT] = -1;\n}\n\n// This function adds a value to the list (using basic sorting)\nList_Add(value)\n{\n    // Check if there are free slots in the array\n    if (gUnusedStart == -1) return -1;\n    new\n        pointer = gListStart,\n        last = -1,\n        slot = gUnusedStart;\n    // Add the value to the array\n    gListData[slot][E_DATA_LIST_VALUE] = value;\n    // Update the empty list\n    gUnusedStart = gListData[slot][E_DATA_LIST_NEXT];\n    // Loop through the list till we get to bigger/same size number\n    while (pointer != -1 && gListData[pointer][E_DATA_LIST_VALUE] < value)\n    {\n        // Save the position of the last value\n        last = pointer;\n        // Move on to the next slot\n        pointer = gListData[pointer][E_DATA_LIST_NEXT];\n    }\n    // If we got here we ran out of values or reached a larger one\n    // Check if we checked any numbers\n    if (last == -1)\n    {\n        // The first number was bigger or there is no list\n        // Either way add the new value to the start of the list\n        gListData[slot][E_DATA_LIST_NEXT] = gListStart;\n        gListStart = slot;\n    }\n    else\n    {\n        // Place the new value in the list\n        gListData[slot][E_DATA_LIST_NEXT] = pointer;\n        gListData[last][E_DATA_LIST_NEXT] = slot;\n    }\n    return slot;\n}\n\n// This function removes a value from a given slot in the array (returned by List_Add)\nList_Remove(slot)\n{\n    // Is this a valid slot\n    if (slot < 0 || slot >= NUMBER_OF_VALUES) return 0;\n    // First find the slot before\n    new\n        pointer = gListStart,\n        last = -1;\n    while (pointer != -1 && pointer != slot)\n    {\n        last = pointer;\n        pointer = gListData[pointer][E_DATA_LIST_NEXT];\n    }\n    // Did we find the slot in the list\n    if (pointer == -1) return 0;\n    if (last == -1)\n    {\n        // The value is the first in the list\n        // Skip over this slot in the list\n        gListStart = gListData[slot][E_DATA_LIST_NEXT];\n    }\n    else\n    {\n        // The value is in the list\n        // Skip over this slot in the list\n        gListData[last][E_DATA_LIST_NEXT] = gListData[slot][E_DATA_LIST_NEXT];\n    }\n    // Add this slot to the unused list\n    // The unused list isn't in any order so this doesn't matter\n    gListData[slot][E_DATA_LIST_NEXT] = gUnusedStart;\n    gUnusedStart = slot;\n    return 1;\n}\n"})}),"\n",(0,t.jsx)(a.h3,{id:"copaci-binari",children:"Copaci binari"}),"\n",(0,t.jsx)(a.h4,{id:"introducere-1",children:"Introducere"}),"\n",(0,t.jsx)(a.p,{children:"Arborii binari sunt o metod\u0103 foarte rapid\u0103 de c\u0103utare a datelor \xeentr-o matrice utiliz\xe2nd un sistem de liste foarte special. Cel mai cunoscut arbore binar este probabil jocul cu 20 de \xeentreb\u0103ri, cu doar 20 de \xeentreb\u0103ri da / nu pe care le pute\u021Bi avea peste 1048576 articole. Un arbore binar, a\u0219a cum sugereaz\u0103 \u0219i numele, este un tip de arbore, similar cu un arbore genealogic, \xeen care fiecare articol are 0, 1 sau 2 copii. Nu sunt folosite pentru a comanda date, cum ar fi o list\u0103, ci pentru a sorta datele pentru o c\u0103utare foarte eficient\u0103. Practic, \xeencepe\u021Bi cu un element undeva aproape de mijlocul listei ordonate de obiecte (de exemplu, num\u0103rul de mijloc dintr-o matrice sortat\u0103) \u0219i compara\u021Bi-l cu valoarea pe care dori\u021Bi s\u0103 o g\u0103si\u021Bi. Dac\u0103 este la fel c\u0103 a\u021Bi g\u0103sit articolul dvs., dac\u0103 este mai mare, v\u0103 deplasa\u021Bi la articolul la dreapta (nu imediat la dreapta, elementul din dreapta elementului din mijloc ar fi elementul de la punctul trei sferturi), dac\u0103 este mai pu\u021Bin s\u0103 v\u0103 mi\u0219ca\u021Bi la st\xe2nga,\napoi repeta\u021Bi procesul."}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"Exemplu"})}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-c",children:"1 2 5 6 7 9 12 14 17 19 23 25 28 33 38\n"})}),"\n",(0,t.jsx)(a.p,{children:"Ave\u021Bi matricea ordonat\u0103 precedent\u0103 \u0219i dori\u021Bi s\u0103 afla\u021Bi \xeen ce slot este num\u0103rul 7 (dac\u0103 este deloc), \xeen acest exemplu este probabil mai eficient s\u0103 face\u021Bi doar o bucl\u0103 direct\u0103 prin matrice pentru a o g\u0103si, dar asta nu este punctul metoda cre\u0219te \xeen timp liniar cu dimensiunea tabloului, un timp de c\u0103utare binar cre\u0219te liniar pe m\u0103sur\u0103 ce tabloul cre\u0219te exponen\u021Bial ca dimensiune. Adic\u0103 o matrice 128 mare va dura de dou\u0103 ori mai mult pentru a c\u0103uta direct ca o matrice 64 mare, dar o c\u0103utare binar\u0103 128 mare va lua doar un cec mai mult dec\xe2t o c\u0103utare binar\u0103 64 mare, deloc mult."}),"\n",(0,t.jsxs)(a.p,{children:["Dac\u0103 construim un arbore binar din datele de mai sus, ob\u021Binem: ",(0,t.jsx)(a.img,{src:"https://web.archive.org/web/20190416012239im_/https://wiki.sa-mp.com/wroot/images2/f/fe/Binarytree.GIF",alt:"Imgur"})]}),"\n",(0,t.jsx)(a.p,{children:"Dac\u0103 citi\u021Bi de la st\xe2nga la dreapta, ignor\xe2nd aspectul vertical, pute\u021Bi vedea c\u0103 numerele sunt \xeen ordine. Acum putem \xeencerca s\u0103 g\u0103sim 7."}),"\n",(0,t.jsx)(a.p,{children:"Num\u0103rul de start este 14, 7 este mai mic dec\xe2t 14, a\u0219a c\u0103 mergem la slotul indicat de ramura din st\xe2nga a 14. Aceasta ne aduce la 6, 7 este mai mare dec\xe2t 6, a\u0219a c\u0103 mergem la dreapta la 9, apoi din nou la st\xe2nga la 7. Aceast\u0103 metod\u0103 a f\u0103cut 4 compara\u021Bii pentru a g\u0103si num\u0103rul (inclusiv verificarea final\u0103 pentru a confirma c\u0103 suntem pe 7), folosind o c\u0103utare direct\u0103 ar fi fost necesare 5."}),"\n",(0,t.jsxs)(a.p,{children:["S\u0103 spunem c\u0103 nu exist\u0103 7, am ajunge la acest arbore binar: ",(0,t.jsx)(a.img,{src:"https://web.archive.org/web/20190416012239im_/https://wiki.sa-mp.com/wroot/images2/e/e5/Binarytree-7-less.GIF",alt:"Binarytree-7-less"})]}),"\n",(0,t.jsx)(a.p,{children:"Acesta, spre deosebire de exemplul de mai sus, are un singur num\u0103r copil (cel 9), precum \u0219i 2 \u0219i 0 numere copil. Ob\u021Bine\u021Bi un arbore perfect numai atunci c\xe2nd exist\u0103 (2 ^ n) -1 numere (0, 1, 3, 7, 15, 31 ...), orice alte numere vor da un arbore nu destul de complet. \xcen acest caz, c\xe2nd ajungem la 9, unde va fi 7, vom descoperi c\u0103 nu exist\u0103 ramur\u0103 st\xe2ng\u0103, adic\u0103 7 nu exist\u0103 (nu poate fi nic\u0103ieri altundeva \xeen copac, g\xe2ndi\u021Bi-v\u0103 la asta), deci return\u0103m -1 pentru slot nevalid."}),"\n",(0,t.jsx)(a.h4,{id:"balansat-si-nebalansat",children:"Balansat si nebalansat"}),"\n",(0,t.jsxs)(a.p,{children:["Arborii din exemplele de mai sus sunt numi\u021Bi arbori binari echilibra\u021Bi, aceasta \xeenseamn\u0103 c\xe2t mai aproape posibil toate ramurile au aceea\u0219i lungime (evident c\u0103 \xeen al doilea nu exist\u0103 suficiente numere pentru ca acest lucru s\u0103 fie cazul, dar este c\xe2t mai aproape posibil). Construirea copacilor echilibra\u021Bi nu este u\u0219oar\u0103, metoda general acceptat\u0103 de a construi copaci aproape echilibra\u021Bi este plasarea numerelor \xeentr-o ordine aleatorie, acest lucru poate \xeensemna c\u0103 ve\u021Bi ajunge la a\u0219a ceva: ",(0,t.jsx)(a.img,{src:"https://web.archive.org/web/20190416012239im_/https://wiki.sa-mp.com/wroot/images2/a/a2/Binarytree-uneven.GIF",alt:"Binarytree-uneven"})]}),"\n",(0,t.jsx)(a.p,{children:"Evident, acest arbore este \xeenc\u0103 valabil, dar partea dreapt\u0103 este mult mai mare dec\xe2t st\xe2nga, totu\u0219i g\u0103sirea a 25 necesit\u0103 doar 7 compara\u021Bii \xeen acest raport fa\u021B\u0103 de 12 din lista dreapt\u0103. De asemenea, at\xe2ta timp c\xe2t \xeencepe\u021Bi cu un num\u0103r destul de mediu, metoda de inserare aleatorie ar trebui s\u0103 produc\u0103 un arbore destul de echilibrat. Cel mai r\u0103u lucru posibil pe care \xeel pute\u021Bi face este s\u0103 pune\u021Bi numerele \xeen ordine, deoarece atunci nu vor exista deloc ramuri st\xe2ngi (sau ramuri dreapta dac\u0103 se face invers), totu\u0219i chiar \u0219i \xeen acest caz cel mai r\u0103u arborele binar nu va mai dura s\u0103 caute dec\xe2t lista dreapt\u0103."}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"Modificare"})}),"\n",(0,t.jsx)(a.h4,{id:"adaugare",children:"Adaugare"}),"\n",(0,t.jsx)(a.p,{children:"Ad\u0103ugarea unei valori unui copac binar este relativ u\u0219or, trebuie doar s\u0103 urm\u0103ri\u021Bi copacul, folosind valoarea pe care dori\u021Bi s\u0103 o ad\u0103uga\u021Bi ca referin\u021B\u0103 p\xe2n\u0103 c\xe2nd ajunge\u021Bi la o ramur\u0103 goal\u0103 \u0219i ad\u0103uga\u021Bi num\u0103rul acolo. De exemplu. dac\u0103 a\u021Bi dori s\u0103 ad\u0103uga\u021Bi num\u0103rul 15 la arborele nostru echilibrat original, acesta ar ajunge pe ramura din st\xe2nga a 17. Dac\u0103 am dori s\u0103 ad\u0103ug\u0103m num\u0103rul 8 la al doilea arbore echilibrat (cel f\u0103r\u0103 7) ar ajunge \xeen vechiul slot al 7 din st\xe2nga lui 9."}),"\n",(0,t.jsx)(a.h4,{id:"stergere",children:"Stergere"}),"\n",(0,t.jsx)(a.p,{children:"\u0218tergerea unui num\u0103r dintr-un arbore binar poate fi dificil\u0103 sau poate fi u\u0219oar\u0103. Dac\u0103 num\u0103rul este la sf\xe2r\u0219itul unei ramuri (de exemplu, 1, 5, 7, 12 etc. \xeen arborele original) pur \u0219i simplu le elimina\u021Bi. Dac\u0103 un num\u0103r are un singur copil (de exemplu, 9 \xeen al doilea exemplu), pur \u0219i simplu \xeel muta\u021Bi pe copil (de exemplu, 12) \xeen pozi\u021Bia lor (deci copiii lui 6 ar fi 2 \u0219i 12 \xeen noul al doilea exemplu, cu 9 elimina\u021Bi). \u0218tergerea devine interesant\u0103 numai atunci c\xe2nd un nod are doi copii. Exist\u0103 cel pu\u021Bin patru moduri de a face acest lucru:"}),"\n",(0,t.jsx)(a.p,{children:"Prima metod\u0103 este cea mai simpl\u0103 din punct de vedere calculatic. Practic, alege\u021Bi una dintre ramuri (st\xe2nga sau dreapta, asuma\u021Bi dreapta pentru aceast\u0103 explica\u021Bie) \u0219i \xeenlocui\u021Bi nodul pe care l-a\u021Bi eliminat cu primul nod al acelei ramuri (adic\u0103 copilul drept al nodului pe care l-a\u021Bi eliminat). Apoi merge\u021Bi la st\xe2nga prin noua ramur\u0103 p\xe2n\u0103 ajunge\u021Bi la cap\u0103t \u0219i a\u0219eza\u021Bi ramura st\xe2ng\u0103 acolo. De exemplu. dac\u0103 a\u021Bi eliminat 14 din exampe-ul original, a\u021Bi ajunge cu 25 ocup\xe2ndu-i locul \xeen v\xe2rful copacului \u0219i 6 ata\u0219at la ramura st\xe2ng\u0103 a 17. Aceast\u0103 metod\u0103 este rapid\u0103, dar se termin\u0103 cu copaci foarte dezechilibra\u021Bi foarte repede."}),"\n",(0,t.jsx)(a.p,{children:"A doua metod\u0103 este s\u0103 ob\u021Bine\u021Bi toate numerele care sunt copiii nodului pe care tocmai l-a\u021Bi eliminat \u0219i s\u0103 reconstrui\u021Bi un nou arbore binar din ele, apoi s\u0103 pune\u021Bi partea de sus a acelui arbore \xeen nodul pe care tocmai l-a\u021Bi eliminat. Acest lucru men\u021Bine arborele destul de bine echilibrat, dar este evident mai lent."}),"\n",(0,t.jsx)(a.p,{children:"A treia metod\u0103 este de a combina cele dou\u0103 metode de mai sus \u0219i de a reconstrui arborele \xeen linie, acest lucru este mai complex de codat, dar men\u021Bine arborele echilibrat \u0219i este mai rapid dec\xe2t cea de-a doua metod\u0103 (de\u0219i nu este aproape la fel de rapid ca prima)."}),"\n",(0,t.jsx)(a.p,{children:"Mentalul final enumerat aici este s\u0103 seta\u021Bi pur \u0219i simplu un steag pe o valoare spun\xe2nd c\u0103 nu mai este utilizat\u0103, aceasta este chiar mai rapid\u0103 dec\xe2t prima metod\u0103 \u0219i men\u021Bine structura, dar \xeenseamn\u0103 c\u0103 nu pute\u021Bi reutiliza sloturile dec\xe2t dac\u0103 pute\u021Bi g\u0103si o valoare pentru \xeenlocui\u021Bi-l cu mai t\xe2rziu."})]})}function d(e={}){let{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},50065:function(e,a,i){i.d(a,{Z:()=>s,a:()=>l});var n=i(67294);let t={},r=n.createContext(t);function l(e){let a=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(r.Provider,{value:a},e.children)}}}]);