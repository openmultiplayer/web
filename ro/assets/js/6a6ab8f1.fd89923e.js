"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["45144"],{83326:function(e,i,n){n.r(i),n.d(i,{frontMatter:()=>c,toc:()=>u,default:()=>o,metadata:()=>a,assets:()=>s,contentTitle:()=>l});var a=JSON.parse('{"id":"tutorials/Binary","title":"Binar","description":"O privire aprofundat\u0103 asupra operatorilor binari \u0219i bit-bit","source":"@site/i18n/ro/docusaurus-plugin-content-docs/current/tutorials/Binary.md","sourceDirName":"tutorials","slug":"/tutorials/Binary","permalink":"/ro/docs/tutorials/Binary","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/docs/tutorials/Binary.md","tags":[],"version":"current","frontMatter":{"title":"Binar","sidebar_label":"Binar","description":"O privire aprofundat\u0103 asupra operatorilor binari \u0219i bit-bit"},"sidebar":"docsSidebar","previous":{"title":"Structuri avansate","permalink":"/ro/docs/tutorials/AdvancedStructures"},"next":{"title":"Ghid pentru meniuri","permalink":"/ro/docs/tutorials/MenuGuide"}}'),r=n(85893),t=n(50065);let c={title:"Binar",sidebar_label:"Binar",description:"O privire aprofundat\u0103 asupra operatorilor binari \u0219i bit-bit"},l=void 0,s={},u=[{value:"Credite",id:"credite",level:2},{value:"Ce este binarul?",id:"ce-este-binarul",level:2},{value:"O privire mai profund\u0103 asupra bi\u021Bilor",id:"o-privire-mai-profund\u0103-asupra-bi\u021Bilor",level:3},{value:"Numere \xeentregi semnate",id:"numere-\xeentregi-semnate",level:4},{value:"Numere \xeentregi nesemnate",id:"numere-\xeentregi-nesemnate",level:4},{value:"Operatori binari",id:"operatori-binari",level:2},{value:"Bitwise AND",id:"bitwise-and",level:3},{value:"Bitwise OR",id:"bitwise-or",level:3},{value:"Bitwise XOR",id:"bitwise-xor",level:3},{value:"Bitwise NU",id:"bitwise-nu",level:3},{value:"Bit Shifting",id:"bit-shifting",level:3},{value:"Schimb\u0103ri aritmetice",id:"schimb\u0103ri-aritmetice",level:4},{value:"Schimbare dreapta",id:"schimbare-dreapta",level:4},{value:"Schimbare st\xe2nga",id:"schimbare-st\xe2nga",level:4},{value:"Schimb\u0103ri logice",id:"schimb\u0103ri-logice",level:4},{value:"Schimbare dreapta",id:"schimbare-dreapta-1",level:5},{value:"Schimbare st\xe2nga",id:"schimbare-st\xe2nga-1",level:5}];function d(e){let i={code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.h2,{id:"credite",children:"Credite"}),"\n",(0,r.jsxs)(i.p,{children:["Acesta este dintr-un subiect Tutorial din SA-MP Forums. Autorul este ",(0,r.jsx)(i.strong,{children:"Kyosaur"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"ce-este-binarul",children:"Ce este binarul?"}),"\n",(0,r.jsxs)(i.p,{children:["Binarul este un sistem numeric care folose\u0219te dou\u0103 simboluri unice pentru a reprezenta numerele. \xcen timp ce sistemul zecimal mai obi\u0219nuit folose\u0219te zece cifre (",(0,r.jsx)(i.strong,{children:"baza 10"}),"), binarul folose\u0219te doar 0 \u0219i 1. Acest lucru poate suna inutil \xeen via\u021Ba de zi cu zi, dar binarul este esen\u021Bial atunci c\xe2nd vine vorba de computere. Calculatoarele la cel mai sc\u0103zut nivel \xee\u0219i efectueaz\u0103 toate calculele prin manipularea fluxului de energie electric\u0103 pentru a indica st\u0103rile de pornire \u0219i oprire. Exact asta este binarul, doar o ton\u0103 de comutatoare pornite \u0219i oprite. Acesta este un fel de concept extraterestru pentru majoritatea oamenilor, a\u0219a c\u0103 s\u0103 arunc\u0103m o privire la sistemul zecimal \u0219i binar unul l\xe2ng\u0103 cel\u0103lalt."]}),"\n",(0,r.jsx)(i.p,{children:"Zecimal (baza 10)"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n"})}),"\n",(0,r.jsx)(i.p,{children:"Binar (baza 2)"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"0 //0\n1 //1\n10 //2\n11 //3\n100 //4\n101 //5\n110 //6\n111 //7\n1000 //8\n1001 //9\n1010 //10\n1011 //11\n1100 //12\n1101 //13\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Privind ambele sisteme unul l\xe2ng\u0103 altul, ve\u021Bi observa c\u0103 se comport\u0103 exact la fel. Odat\u0103 ce a\u021Bi ajuns la ultimul num\u0103r disponibil, trebuie s\u0103 trece\u021Bi la un alt loc. Aceste locuri \xeen binar sunt denumite bi\u021Bi (",(0,r.jsx)(i.strong,{children:"b"})," inary dig ",(0,r.jsx)(i.strong,{children:"its"}),") \u0219i sunt pur \u0219i simplu puteri a dou\u0103; la fel cum locurile din sistemul zecimal sunt puteri de 10. Pentru a demonstra acest lucru, s\u0103 arunc\u0103m o privire la num\u0103rul 13 din nota\u021Bia standard."]}),"\n",(0,r.jsx)(i.p,{children:"** NOT\u0102: ** '^' este putere \xeen urm\u0103toarele c\xe2teva exemple, nu este exclusiv bitologic (pe care \xeel vom acoperi mai t\xe2rziu)."}),"\n",(0,r.jsx)(i.p,{children:"Zecimal (baza 10)"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"13\n\n//which equals\n\n1 * (10^1) + 3 * (10^0)\n\n//which equals\n\n10+3\n\n//which equals\n\n13\n"})}),"\n",(0,r.jsx)(i.p,{children:"Binar (baza 2)"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"1101\n\n//which equals\n\n1 * (2^3) + 1 * (2^2) + 0 * (2^1) + 1 * (2^0)\n\n//which equals\n\n8+4+0+1\n\n//which equals\n\n13\n"})}),"\n",(0,r.jsx)(i.p,{children:"Putem vedea din exemplul precedent c\u0103, dac\u0103 un bit este setat la 0, \xeel putem ignora \u0219i continua; la urma urmei, orice \xeenmul\u021Bit cu 0 va fi 0. Exemplul anterior a fost pu\u021Bin complicat \u0219i am \xeencercat doar s\u0103 fiu absolut clar. C\xe2nd face\u021Bi conversia din binar, tot ce trebuie s\u0103 v\u0103 face\u021Bi griji este s\u0103 ad\u0103uga\u021Bi puterile tuturor bi\u021Bilor care sunt aprin\u0219i."}),"\n",(0,r.jsx)(i.p,{children:"Iat\u0103 12 puteri de 2 chiar l\xe2ng\u0103 v\xe2rful capului meu:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"4096,2048,1024,512,256,128,64,32,16,8,4,2,1\n"})}),"\n",(0,r.jsx)(i.p,{children:"Dac\u0103 nu \u0219tii nimic despre lucrul cu puteri, probabil c\u0103 acest lucru nu are deloc sens pentru tine. O putere este un num\u0103r \xeenmul\u021Bit cu el \xeensu\u0219i x de c\xe2te ori. Av\xe2nd \xeen vedere aceste informa\u021Bii, lista precedent\u0103 de puteri are probabil mai mult sens; Ei bine, cu excep\u021Bia lui 1. S-ar putea s\u0103 fi\u021Bi curios de ce 2 ridicat la puterea lui 0 d\u0103 un rezultat de 1, tot ce pot spune la acest lucru este c\u0103 doar o face."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"2^1 = 2, 2^3 = 4, 2^4 = 8\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Putem vedea c\u0103 atunci c\xe2nd ne deplas\u0103m spre dreapta, valoarea noastr\u0103 anterioar\u0103 este \xeenmul\u021Bit\u0103 cu 2; deci este sigur s\u0103 presupunem c\u0103 atunci c\xe2nd ne deplas\u0103m spre st\xe2nga noua noastr\u0103 valoare este doar num\u0103rul anterior \xeemp\u0103r\u021Bit la 2. Av\xe2nd \xeen vedere acest lucru, pute\u021Bi vedea cum putem ajunge cu 2 la puterea zero egal cu 1. Dac\u0103 nu este satisf\u0103c\u0103tor suficient, sunt sigur c\u0103 pute\u021Bi g\u0103si mai multe dovezi pe ",(0,r.jsx)(i.strong,{children:"**"}),". Toate acestea fiind spuse, s\u0103 arunc\u0103m o privire la un ultim exemplu \u0219i s\u0103 \xeel facem oarecum complicat!"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"111011001011111000 //242424\n\n//Remember, ignore the bits that arent turned on.\n\n1 * (2^17) = 131072\n\n1 * (2^16) = 65536\n\n1 * (2^15) = 32768\n\n1 * (2^13) = 8192\n\n1 * (2^12) = 4096\n\n1 * (2^9) = 512\n\n1 * (2^7) = 128\n\n1 * (2^6) = 64\n\n1 * (2^5) = 32\n\n1 * (2^4) = 16\n\n1 * (2^3) = 8\n\n\n131072+65536+32768+8192+4096+512+128+64+32+16+8\n=\n242424\n"})}),"\n",(0,r.jsx)(i.p,{children:"Aminti\u021Bi-v\u0103 c\xe2nd face\u021Bi conversia: prima putere este 0, a\u0219a c\u0103 nu face\u021Bi gre\u0219eala v\u0103z\xe2nd locul 18 ca 2 ^ 18. Exist\u0103 \xeentr-adev\u0103r 18 puteri, dar asta include puterea lui 0, deci 17 este de fapt puterea noastr\u0103 cea mai mare."}),"\n",(0,r.jsx)(i.h3,{id:"o-privire-mai-profund\u0103-asupra-bi\u021Bilor",children:"O privire mai profund\u0103 asupra bi\u021Bilor"}),"\n",(0,r.jsx)(i.p,{children:"Majoritatea limbajelor de programare permit diferite tipuri de date care variaz\u0103 \xeen cantitatea de bi\u021Bi care pot fi utiliza\u021Bi pentru a stoca informa\u021Bii; totu\u0219i pionul este un limbaj de 32 de bi\u021Bi f\u0103r\u0103 tip. Aceasta \xeenseamn\u0103 c\u0103 pionul va avea \xeentotdeauna 32 de bi\u021Bi disponibili pentru stocarea informa\u021Biilor. Ce se \xeent\xe2mpl\u0103 atunci c\xe2nd ave\u021Bi multe informa\u021Bii? R\u0103spunsul la aceast\u0103 \xeentrebare const\u0103 \xeen numere \xeentregi semnate \u0219i nesemnate."}),"\n",(0,r.jsx)(i.h4,{id:"numere-\xeentregi-semnate",children:"Numere \xeentregi semnate"}),"\n",(0,r.jsx)(i.p,{children:"A\u021Bi observat vreodat\u0103 c\u0103 atunci c\xe2nd un num\u0103r \xeentreg din pion ajunge la mare se transform\u0103 \xeentr-un negativ? Aceast\u0103 \u201E\xeempachetare\u201D se datoreaz\u0103 dep\u0103\u0219irii valorii maxime \xeen pion, care este:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"2^31 - 1 //Power, not bitwise exclusive. Also the -1 is because we count 0 (there ARE 2,147,483,648 values, but that is with 0, So technically 2,147,483,647 is the max).\n\n//which equals\n\n2,147,483,647\n\n//which in binary is\n\n1111111111111111111111111111111 //31 bits- all on\n"})}),"\n",(0,r.jsx)(i.p,{children:"S-ar putea s\u0103 v\u0103 \xeentreba\u021Bi de ce ACEASTA este valoarea maxim\u0103 \u0219i nu 2 ^ 32-1 (4.294.967.295). Aici intr\u0103 \xeen joc \xeentregi semnate \u0219i nesemnate. Numerele \xeentregi semnate au capacitatea de a stoca valori negative, unde numerele \xeentregi nesemnate nu. S-ar putea s\u0103 par\u0103 c\u0103 m\u0103 ab\u0103t de la \xeentrebare, dar v\u0103 asigur c\u0103 nu sunt. Motivul pentru care num\u0103rul \xeentreg maxim nu este 2 ^ 32-1 se datoreaz\u0103 faptului c\u0103 bitul 32 este folosit ca un fel de comutare pentru valori negative \u0219i pozitive. Aceasta se nume\u0219te MSB (bitul cel mai semnificativ) dac\u0103 MSB este pornit, num\u0103rul va fi negativ; dac\u0103 este dezactivat, num\u0103rul este pozitiv. Destul de simplu, nu?"}),"\n",(0,r.jsx)(i.p,{children:"\xcenainte de a ar\u0103ta c\xe2teva valori negative, trebuie s\u0103 explic cum sunt reprezentate valorile negative \xeen pion. Pawn folose\u0219te un sistem numit complement 2 pentru a reprezenta valori negative, ceea ce \xeenseamn\u0103 practic c\u0103 r\u0103suci\u021Bi fiecare bit din num\u0103rul dvs. \u0219i ad\u0103uga\u021Bi 1 la noul num\u0103r pentru a-l face negativ."}),"\n",(0,r.jsx)(i.p,{children:"S\u0103 arunc\u0103m o privire asupra c\xe2torva valori negative \xeen timp ce aceast\u0103 idee este \xeenc\u0103 \xeen cap:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"11111111111111111111111111111111 //all 32 bits turned on\n\n//equals\n\n-1\n\n//and\n\n11111111111111111111111111111110\n\n//equals\n\n-2\n\n//and finally\n\n10000000000000000000000000000000\n\n//equals\n\n-2147483648\n"})}),"\n",(0,r.jsx)(i.p,{children:"Vezi, toate numerele negative sunt pur \u0219i simplu num\u0103rul pozitiv ini\u021Bial, cu to\u021Bi bi\u021Bii s\u0103i r\u0103sturna\u021Bi \u0219i crescu\u021Bi cu unul. Acest lucru este foarte clar cu ultimul nostru exemplu, deoarece cel mai \xeenalt num\u0103r POZITIV este 2147483647."}),"\n",(0,r.jsx)(i.p,{children:"Din aceasta putem vedea c\u0103 intervalul numeric din pawn este de fapt:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"&#8722;2^31 to +2^31 \u2212 1\n"})}),"\n",(0,r.jsx)(i.h4,{id:"numere-\xeentregi-nesemnate",children:"Numere \xeentregi nesemnate"}),"\n",(0,r.jsx)(i.p,{children:"Nu exist\u0103 astfel de numere \xeentregi nesemnate \xeen pawn, dar ad\u0103ug acest lucru doar pentru a fi echilibrat. Singura diferen\u021B\u0103 \xeentre un num\u0103r \xeentreg semnat \u0219i un \xeentreg nesemnat este c\u0103 numerele \xeentregi nesemnate nu pot stoca valori negative; Numerele \xeentregi se \xeencheie, dar se \xeentorc la 0, \xeen loc de o valoare negativ\u0103."}),"\n",(0,r.jsx)(i.h2,{id:"operatori-binari",children:"Operatori binari"}),"\n",(0,r.jsx)(i.p,{children:"Operatorii binari v\u0103 permit s\u0103 manipula\u021Bi bi\u021Bi individuali dintr-un model de bi\u021Bi. S\u0103 arunc\u0103m o privire la o list\u0103 de operatori bi\u021Bi disponibili."}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Deplasare aritmetic\u0103 \xeen bi\u021Bi: >> \u0219i <<"}),"\n",(0,r.jsx)(i.li,{children:"Deplasare logic\u0103 \xeen bi\u021Bi: >>>"}),"\n",(0,r.jsx)(i.li,{children:"Bitwise NOT (aka complement): ~"}),"\n",(0,r.jsx)(i.li,{children:"Bitwise \u0218I: &"}),"\n",(0,r.jsx)(i.li,{children:"OR bit: |"}),"\n",(0,r.jsx)(i.li,{children:"Bitwise XOR (aka exclusive-or): ^"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"bitwise-and",children:"Bitwise AND"}),"\n",(0,r.jsx)(i.p,{children:"** NOT\u0102:** Nu trebuie confundat de operatorul logic AND '&&'"}),"\n",(0,r.jsx)(i.p,{children:"Un AND binar ia pur \u0219i simplu AND-ul logic al bi\u021Bilor din fiecare pozi\u021Bie a unui num\u0103r sub form\u0103 binar\u0103. Sun\u0103 pu\u021Bin confuz, a\u0219a c\u0103 s\u0103 arunc\u0103m o privire \xeen ac\u021Biune!"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:'1100 //12\n&\n0100 //4\n=\n0100 //4 as they both have "100" in them (which is 4)\n'})}),"\n",(0,r.jsx)(i.p,{children:"A fost pu\u021Bin u\u0219or, s\u0103 arunc\u0103m o privire mai grea:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"10111000 //184\n&\n01001000 //72\n=\n00001000 //8\n"})}),"\n",(0,r.jsx)(i.p,{children:"Privirea exemplelor ar trebui s\u0103 v\u0103 ofere o idee destul de bun\u0103 despre ceea ce face acest operator. Compar\u0103 dou\u0103 seturi de bi\u021Bi \xeempreun\u0103, dac\u0103 ambele partajeaz\u0103 un bit de 1, rezultatul va avea acela\u0219i bit activat. Dac\u0103 nu \xeempart deloc bi\u021Bi, atunci rezultatul este 0."}),"\n",(0,r.jsx)(i.h3,{id:"bitwise-or",children:"Bitwise OR"}),"\n",(0,r.jsx)(i.p,{children:"** NOT\u0102:** Nu trebuie confundat de operatorul SAU logic '||'"}),"\n",(0,r.jsx)(i.p,{children:"Bitwise OR func\u021Bioneaz\u0103 aproape exact la fel ca bitwise AND. Singura diferen\u021B\u0103 dintre cele dou\u0103 este c\u0103 SAU \xeen bi\u021Bi are nevoie doar de unul dintre cele dou\u0103 modele de bi\u021Bi pentru a avea un bit activat pentru ca rezultatul s\u0103 aib\u0103 acela\u0219i bit activat. S\u0103 arunc\u0103m o privire la c\xe2teva exemple!"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"1100 //12\n|\n0100 //4\n=\n1100 //12.\n"})}),"\n",(0,r.jsx)(i.p,{children:"S\u0103 arunc\u0103m o privire la \xeenc\u0103 un exemplu."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"10111000 //184\n|\n01001000 //72\n=\n11111000 //248\n"})}),"\n",(0,r.jsx)(i.p,{children:"Cred c\u0103 acest lucru se explic\u0103 destul de mult, dac\u0103 oricare dintre numere au pornit pu\u021Bin, rezultatul va avea \u0219i acel bit activat."}),"\n",(0,r.jsx)(i.h3,{id:"bitwise-xor",children:"Bitwise XOR"}),"\n",(0,r.jsx)(i.p,{children:"Acest operator este pu\u021Bin asem\u0103n\u0103tor cu operatorul OR \xeen bi\u021Bi, dar exist\u0103 o diferen\u021B\u0103. S\u0103 ne uit\u0103m la acela\u0219i exemplu folosit \xeen sec\u021Biunea OR bitwise \u0219i s\u0103 vedem dac\u0103 pute\u021Bi observa diferen\u021Ba."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"1100 //12\n^\n0100 //4\n=\n1000 //8.\n"})}),"\n",(0,r.jsx)(i.p,{children:"\u0219i, \xeen sf\xe2r\u0219it:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"10111000 //184\n^\n01001000 //72\n=\n11110000 //240\n"})}),"\n",(0,r.jsx)(i.h3,{id:"bitwise-nu",children:"Bitwise NU"}),"\n",(0,r.jsx)(i.p,{children:"Acest operator \xeentoarce fiecare bit \xeen modelul de bi\u021Bi, transform\xe2nd toate 1 \xeen 0 \u0219i vice versa."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"~0\n=\n11111111111111111111111111111111 //-1\n\n//and\n\n~100 //4\n=\n11111111111111111111111111111011 //-5\n\n//and\n\n~1111111111111111111111111111111 //2147483647 (not to be confused with -1, which has 32 bits, not 31)\n=\n10000000000000000000000000000000 //-2147483648 (32nd bit turned on)\n"})}),"\n",(0,r.jsx)(i.p,{children:"Dac\u0103 nu \xeen\u021Belege\u021Bi de ce valorile negative sunt un fel de \u201E\xeenapoi\u201D, v\u0103 rug\u0103m s\u0103 citi\u021Bi sec\u021Biunea despre numerele \xeentregi semnate."}),"\n",(0,r.jsx)(i.h3,{id:"bit-shifting",children:"Bit Shifting"}),"\n",(0,r.jsx)(i.p,{children:"Bit shifting face exact ceea ce \u021Bi-ai imagina c\u0103 face; deplaseaz\u0103 bi\u021Bii \xeentr-un num\u0103r c\u0103tre o anumit\u0103 direc\u021Bie. Dac\u0103 v\u0103 aminti\u021Bi mai devreme \xeen articol am men\u021Bionat c\u0103 PAWN are un anumit interval de memorie (32 de bi\u021Bi care pot fi utiliza\u021Bi pentru stocare). Ce se \xeent\xe2mpl\u0103 c\xe2nd trece\u021Bi un num\u0103r peste acel interval? R\u0103spunsul la aceast\u0103 \xeentrebare const\u0103 \xeen ce operator de schimbare folosi\u021Bi \u0219i \xeen ce direc\u021Bie v\u0103 deplasa\u021Bi."}),"\n",(0,r.jsx)(i.p,{children:"** NOT\u0102:** \xcen exemplele urm\u0103toare, toate numerele binare vor fi scrise integral (to\u021Bi cei 32 de bi\u021Bi) pentru a evita orice confuzii."}),"\n",(0,r.jsx)(i.h4,{id:"schimb\u0103ri-aritmetice",children:"Schimb\u0103ri aritmetice"}),"\n",(0,r.jsx)(i.h4,{id:"schimbare-dreapta",children:"Schimbare dreapta"}),"\n",(0,r.jsx)(i.p,{children:"To\u021Bi bi\u021Bii dintr-un num\u0103r sunt deplasa\u021Bi de c\xe2te ori spre dreapta atunci c\xe2nd se utilizeaz\u0103 acest operator. S\u0103 arunc\u0103m o privire rapid\u0103 la un exemplu simplu."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"00000000000000000000000000001000  //8\n>>\n2\n\n=\n\n00000000000000000000000000000010 //2\n"})}),"\n",(0,r.jsx)(i.p,{children:"Pute\u021Bi vedea din exemplul precedent c\u0103 fiecare bit s-a deplasat la dreapta cu dou\u0103 locuri, iar dou\u0103 zerouri au fost ad\u0103ugate pe partea st\xe2ng\u0103 ca umplutur\u0103. Aceste dou\u0103 zerouri sunt de fapt valoarea MSB (Cel mai semnificativ bit) \u0219i sunt foarte importante atunci c\xe2nd vine vorba de deplasarea cu semn \xeentreg. Motivul pentru care MSB este folosit ca umplutur\u0103 este c\u0103 p\u0103str\u0103m semnul num\u0103rului care este mutat. S\u0103 arunc\u0103m o privire la acela\u0219i exemplu, cu excep\u021Bia s\u0103 \xeel facem negativ."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"11111111111111111111111111111000 //-8\n>>\n2\n\n=\n\n11111111111111111111111111111110 //-2\n"})}),"\n",(0,r.jsx)(i.p,{children:"\xcen mod clar, acest lucru se comport\u0103 exact la fel ca \xeen exemplul anterior, cu excep\u021Bia bi\u021Bilor din st\xe2nga folosi\u021Bi pentru umplere; ceea ce dovede\u0219te c\u0103 umplerea deplas\u0103rii aritmetice drepte este valoarea MSB."}),"\n",(0,r.jsx)(i.h4,{id:"schimbare-st\xe2nga",children:"Schimbare st\xe2nga"}),"\n",(0,r.jsx)(i.p,{children:"Acesta este exact opusul operatorului de schimbare aritmetic\u0103 dreapta. Deplaseaz\u0103 to\u021Bi bi\u021Bii dintr-un num\u0103r la st\xe2nga x de c\xe2te ori. S\u0103 vedem un exemplu."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"00000000000000000000000000001000  //8\n<<\n2\n\n=\n\n00000000000000000000000000100000 //32\n"})}),"\n",(0,r.jsx)(i.p,{children:"Singura diferen\u021B\u0103 dintre deplasarea aritmetic\u0103 st\xe2ng\u0103 \u0219i dreapt\u0103 (\xeen afar\u0103 de direc\u021Bia deplas\u0103rii) ar fi modul \xeen care gestioneaz\u0103 umplutura. Cu schimbarea aritmetic\u0103 dreapt\u0103, umplerea este valoarea MSB (Cel mai semnificativ bit), dar cu schimbarea aritmetic\u0103 st\xe2ng\u0103 valoarea este doar 0. Acest lucru se datoreaz\u0103 faptului c\u0103 nu exist\u0103 informa\u021Bii relevante, cum ar fi semnul unui num\u0103r de care s\u0103 \u021Bine\u021Bi eviden\u021Ba."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"11111111111111111111111111111000 //-8\n<<\n2\n\n=\n\n11111111111111111111111111100000 //-32\n"})}),"\n",(0,r.jsx)(i.p,{children:"Vedea? Chiar dac\u0103 umplerea este \xeentotdeauna 0, semnul num\u0103rului este p\u0103strat \xeen continuare. Singurul lucru de care trebuie s\u0103 \xee\u021Bi faci griji este trecerea la departe. Dac\u0103 deplasa\u021Bi un num\u0103r pozitiv peste cel mai mare num\u0103r posibil, acesta va deveni negativ \u0219i va fi invers cu valori negative (\xeen cele din urm\u0103 ve\u021Bi atinge 0)."}),"\n",(0,r.jsx)(i.h4,{id:"schimb\u0103ri-logice",children:"Schimb\u0103ri logice"}),"\n",(0,r.jsx)(i.h5,{id:"schimbare-dreapta-1",children:"Schimbare dreapta"}),"\n",(0,r.jsx)(i.p,{children:"Aceasta este inversa schimb\u0103rii aritmetice la st\xe2nga. Cel mai bun mod de a-l descrie ar fi un hibrid \xeentre cele dou\u0103 schimb\u0103ri aritmetice. S\u0103 arunc\u0103m o privire \xeen ac\u021Biune!"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"00000000000000000000000000001000  //8\n>>>\n2\n\n=\n\n00000000000000000000000000000010 //2\n"})}),"\n",(0,r.jsx)(i.p,{children:"Bi\u021Bii din num\u0103rul 8 s-au deplasat de 2 ori spre dreapta. Deci, \xeen ce fel este diferit acest lucru de schimbarea aritmetic\u0103 dreapt\u0103? R\u0103spunsul este c\u0103ptu\u0219eala. Cu deplasarea aritmetic\u0103 la dreapta, umplerea este valoarea MSB, dar cu deplasarea logic\u0103 la dreapta, umplerea este doar 0 (la fel cum este cu deplasarea aritmetic\u0103 la st\xe2nga). Aceasta \xeenseamn\u0103 c\u0103 nu va p\u0103stra num\u0103rul semnului, iar rezultatul nostru va fi \xeentotdeauna pozitiv. Pentru a demonstra acest lucru, s\u0103 schimb\u0103m un num\u0103r negativ!"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-c",children:"11111111111111111111111111111000 //-8\n>>>\n2\n\n=\n\n00111111111111111111111111111110 //1073741822\n"})}),"\n",(0,r.jsx)(i.p,{children:"Asta dovede\u0219te c\u0103 nu vom ob\u021Bine valori negative \xeen timp ce folosim schimbarea logic\u0103 dreapt\u0103!"}),"\n",(0,r.jsx)(i.h5,{id:"schimbare-st\xe2nga-1",children:"Schimbare st\xe2nga"}),"\n",(0,r.jsx)(i.p,{children:"Nu exist\u0103 o deplasare logic\u0103 la st\xe2nga, deoarece ar face exact acela\u0219i lucru cu deplasarea st\xe2ng\u0103 aritmetic\u0103. Tocmai am ad\u0103ugat acest lucru pentru a evita confuzii de orice fel \u0219i, de asemenea, pentru a men\u021Bine sec\u021Biunea echilibrat\u0103."})]})}function o(e={}){let{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},50065:function(e,i,n){n.d(i,{Z:()=>l,a:()=>c});var a=n(67294);let r={},t=a.createContext(r);function c(e){let i=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),a.createElement(t.Provider,{value:i},e.children)}}}]);