"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["50621"],{50053:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>s,toc:()=>o,default:()=>u,metadata:()=>i,assets:()=>d,contentTitle:()=>l});var i=JSON.parse('{"id":"tutorials/AdvancedStructures","title":"Geavanceerde structuren","description":"Array-manipulatie","source":"@site/i18n/nl/docusaurus-plugin-content-docs/current/tutorials/AdvancedStructures.md","sourceDirName":"tutorials","slug":"/tutorials/AdvancedStructures","permalink":"/nl/docs/tutorials/AdvancedStructures","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/i18n/nl/docusaurus-plugin-content-docs/current/tutorials/AdvancedStructures.md","tags":[],"version":"current","frontMatter":{"title":"Geavanceerde structuren","sidebar_label":"Geavanceerde structuren"},"sidebar":"docsSidebar","previous":{"title":"sa-mp.cfg","permalink":"/nl/docs/client/sa-mp.cfg"},"next":{"title":"Binary","permalink":"/nl/docs/tutorials/Binary"}}'),r=t(85893),a=t(50065);let s={title:"Geavanceerde structuren",sidebar_label:"Geavanceerde structuren"},l=void 0,d={},o=[{value:"Array-manipulatie",id:"array-manipulatie",level:2},{value:"Een lege slot correct vinden",id:"een-lege-slot-correct-vinden",level:3},{value:"Lijst",id:"lijst",level:3},{value:"Introductie",id:"introductie",level:4},{value:"Typen",id:"typen",level:4},{value:"Gemengde lijsten",id:"gemengde-lijsten",level:4},{value:"Code",id:"code",level:4},{value:"Binaire bomen",id:"binaire-bomen",level:3},{value:"Introductie",id:"introductie-1",level:4},{value:"Gebalanceerd vs. ongebalanceerd",id:"gebalanceerd-vs-ongebalanceerd",level:4},{value:"Aanpassen (toevoegen/verwijderen)",id:"aanpassen-toevoegenverwijderen",level:4}];function c(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"array-manipulatie",children:"Array-manipulatie"}),"\n",(0,r.jsx)(n.h3,{id:"een-lege-slot-correct-vinden",children:"Een lege slot correct vinden"}),"\n",(0,r.jsx)(n.p,{children:"Onderstaand voorbeeld laat zien hoe je met standaard codepraktijken een lege slot in een array vindt."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-pawn",children:"new\n    gMyArray[10];\n\nstock FindEmptySlot()\n{\n    new\n        i = 0;\n    while (i < sizeof (gMyArray) && gMyArray[i])\n    {\n        i++;\n    }\n    if (i == sizeof (gMyArray)) return -1;\n    return i;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Dit basisvoorbeeld gaat ervan uit dat een array-slot leeg is als de waarde 0 is. De lus loopt door alle waarden in de array (kan ook met een constant) zolang de waarden niet 0 zijn. Bij de eerste 0 faalt de while-conditie en stopt de lus zonder ",(0,r.jsx)(n.code,{children:"break"}),". De functie retourneert -1 als er geen vrije slot is gevonden; check dat aan de aanroepende kant. Vaak gebruik je het gevonden id direct:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-pawn",children:'MyFunction()\n{\n    new\n        i = 0;\n    while (i < sizeof (gMyArray) && gMyArray[i])\n    {\n        i++;\n    }\n    if (i == sizeof (gMyArray))\n    {\n        printf("No free slot found");\n        return 0;\n    }\n    printf("Slot %d is empty", i);\n    // Gebruik de gevonden slot\n    return 1;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Vervang uiteraard ",(0,r.jsx)(n.code,{children:"gMyArray[i]"})," door jouw eigen indicatie dat een slot in gebruik is."]}),"\n",(0,r.jsx)(n.h3,{id:"lijst",children:"Lijst"}),"\n",(0,r.jsx)(n.h4,{id:"introductie",children:"Introductie"}),"\n",(0,r.jsx)(n.p,{children:"Lijsten zijn een nuttige structuur: feitelijk een array waarbij elk element naar het volgende relevante element wijst."}),"\n",(0,r.jsx)(n.p,{children:"Voorbeeld gesorteerde lijst op indices, met start- en next-indexen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-pawn",children:"start = 1\n3, 1, 64, 2, 4, 786, 2, 9\n4, 3, 5,  6, 7, -1,  0, 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"Het laatste index bij 786 is -1: einde van de lijst. Toevoegen en verwijderen kan door alleen de \u2018pointers\u2019 (next-indexen) te wijzigen in plaats van alle waarden te verplaatsen. Zie varianten en voorbeelden in de codeblokken verderop."}),"\n",(0,r.jsx)(n.h4,{id:"typen",children:"Typen"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enkelvoudige lijst: iedere waarde wijst naar de volgende"}),"\n",(0,r.jsx)(n.li,{children:"Dubbele lijst: iedere waarde wijst naar zowel vorige als volgende"}),"\n",(0,r.jsx)(n.li,{children:"Loopende lijst: laatste wijst terug naar eerste (pas op voor eindeloze lussen)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Voorbeeld dubbele looplijst (met ",(0,r.jsx)(n.code,{children:"start"}),", ",(0,r.jsx)(n.code,{children:"end"}),", ",(0,r.jsx)(n.code,{children:"next"}),", ",(0,r.jsx)(n.code,{children:"last"}),"), zie code in de Engelse versie; de structuur blijft identiek, alleen uitleg is vertaald."]}),"\n",(0,r.jsx)(n.h4,{id:"gemengde-lijsten",children:"Gemengde lijsten"}),"\n",(0,r.jsx)(n.p,{children:"Gemengde lijsten combineren meerdere lijsten in \xe9\xe9n array, bv. een gesorteerde lijst en een vrije-slots-lijst om nieuwe elementen snel te plaatsen."}),"\n",(0,r.jsx)(n.h4,{id:"code",children:"Code"}),"\n",(0,r.jsx)(n.p,{children:"Kies eerst het lijsttype dat bij je toepassing past. Onderstaande voorbeelden tonen een numeriek oplopend gesorteerde gemengde lijst met een tweede lijst voor vrije slots."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-pawn",children:"#define NUMBER_OF_VALUES (10)\n\nenum E_DATA_LIST\n{\n    E_DATA_LIST_VALUE,\n    E_DATA_LIST_NEXT\n}\n\nnew\n    gListData[NUMBER_OF_VALUES][E_DATA_LIST],\n    gUnusedStart = 0,\n    gListStart = -1; // Start zonder lijst\n\nList_Setup()\n{\n    new i, size = NUMBER_OF_VALUES;\n    size--;\n    for (i = 0; i < size; i++)\n    {\n        gListData[i][E_DATA_LIST_NEXT] = i + 1; // Aanvankelijk zijn alle slots vrij\n    }\n    gListData[size][E_DATA_LIST_NEXT] = -1; // Einde vrijelijst\n}\n\nList_Add(value)\n{\n    if (gUnusedStart == -1) return -1; // Geen vrije slots\n    new pointer = gListStart,\n        last = -1,\n        slot = gUnusedStart;\n    gListData[slot][E_DATA_LIST_VALUE] = value;\n    gUnusedStart = gListData[slot][E_DATA_LIST_NEXT];\n    while (pointer != -1 && gListData[pointer][E_DATA_LIST_VALUE] < value)\n    {\n        last = pointer;\n        pointer = gListData[pointer][E_DATA_LIST_NEXT];\n    }\n    if (last == -1)\n    {\n        gListData[slot][E_DATA_LIST_NEXT] = gListStart;\n        gListStart = slot;\n    }\n    else\n    {\n        gListData[slot][E_DATA_LIST_NEXT] = pointer;\n        gListData[last][E_DATA_LIST_NEXT] = slot;\n    }\n    return slot;\n}\n\nList_Remove(slot)\n{\n    if (slot < 0 || slot >= NUMBER_OF_VALUES) return 0;\n    new pointer = gListStart, last = -1;\n    while (pointer != -1 && pointer != slot)\n    {\n        last = pointer;\n        pointer = gListData[pointer][E_DATA_LIST_NEXT];\n    }\n    if (pointer == -1) return 0; // Niet gevonden\n    if (last == -1)\n    {\n        gListStart = gListData[slot][E_DATA_LIST_NEXT];\n    }\n    else\n    {\n        gListData[last][E_DATA_LIST_NEXT] = gListData[slot][E_DATA_LIST_NEXT];\n    }\n    // Voeg slot terug aan de vrije lijst\n    gListData[slot][E_DATA_LIST_NEXT] = gUnusedStart;\n    gUnusedStart = slot;\n    return 1;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"binaire-bomen",children:"Binaire bomen"}),"\n",(0,r.jsx)(n.h4,{id:"introductie-1",children:"Introductie"}),"\n",(0,r.jsx)(n.p,{children:"Binaire bomen zijn een snelle zoekmethode door telkens links/rechts te kiezen t.o.v. een middenwaarde (zoals 20-vragen). Ze ordenen niet per se data fysiek, maar bieden effici\xebnte zoekstructuren. De voorbeelden en afbeeldingen (binary tree) uit de originele tekst zijn onveranderd van toepassing."}),"\n",(0,r.jsx)(n.h4,{id:"gebalanceerd-vs-ongebalanceerd",children:"Gebalanceerd vs. ongebalanceerd"}),"\n",(0,r.jsx)(n.p,{children:"Een gebalanceerde boom houdt de dieptes ongeveer gelijk; ongebalanceerde bomen kunnen nog steeds sneller zoeken dan lineair, maar zijn minder effici\xebnt. Willekeurige invoegvolgorde helpt meestal balans te benaderen; invoegen in al-gesorteerde volgorde is het slechtst."}),"\n",(0,r.jsx)(n.h4,{id:"aanpassen-toevoegenverwijderen",children:"Aanpassen (toevoegen/verwijderen)"}),"\n",(0,r.jsx)(n.p,{children:"Toevoegen: volg links/rechts tot een lege tak en plaats de waarde. Verwijderen: makkelijk bij een blad of \xe9\xe9n kind; lastiger bij twee kinderen (diverse strategie\xebn zoals vervangen door opvolger/voorloper of herbouwen van subboom)."})]})}function u(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},50065:function(e,n,t){t.d(n,{Z:()=>l,a:()=>s});var i=t(67294);let r={},a=i.createContext(r);function s(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);