"use strict";(self.webpackChunkomp_web=self.webpackChunkomp_web||[]).push([["62437"],{62609:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>s,toc:()=>d,default:()=>h,metadata:()=>a,assets:()=>l,contentTitle:()=>o});var a=JSON.parse('{"id":"tutorials/PluginDevelopmentGuide","title":"Plugin Development Guide","description":"A guide to developing plugins","source":"@site/docs/tutorials/PluginDevelopmentGuide.md","sourceDirName":"tutorials","slug":"/tutorials/PluginDevelopmentGuide","permalink":"/fil/docs/tutorials/PluginDevelopmentGuide","draft":false,"unlisted":false,"editUrl":"https://github.com/openmultiplayer/web/edit/master/frontend/docs/tutorials/PluginDevelopmentGuide.md","tags":[],"version":"current","frontMatter":{"title":"Plugin Development Guide","sidebar_label":"Plugin Development Guide","description":"A guide to developing plugins"},"sidebar":"docsSidebar","previous":{"title":"Pickup Guide","permalink":"/fil/docs/tutorials/PickupGuide"},"next":{"title":"Port Forwarding","permalink":"/fil/docs/tutorials/PortForwarding"}}'),i=t(85893),r=t(50065);let s={title:"Plugin Development Guide",sidebar_label:"Plugin Development Guide",description:"A guide to developing plugins"},o=void 0,l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"This is not a C/++ help forum",id:"this-is-not-a-c-help-forum",level:2},{value:"FAQ",id:"faq",level:2},{value:"Quick Questions",id:"quick-questions",level:3},{value:"Getting started",id:"getting-started",level:2},{value:"Source file (*.cpp)",id:"source-file-cpp",level:3},{value:"Module definition file (*.def)",id:"module-definition-file-def",level:3},{value:"Examining the code",id:"examining-the-code",level:2},{value:"The module definition file",id:"the-module-definition-file",level:3},{value:"What is &quot;<strong>EXPORTS</strong>&quot;",id:"what-is-exports",level:4},{value:"Exported functions",id:"exported-functions",level:4},{value:"Defines and structures",id:"defines-and-structures",level:3},{value:"Amx functions",id:"amx-functions",level:2},{value:"Key",id:"key",level:3},{value:"amx_Allot",id:"amx_allot",level:2},{value:"Syntax",id:"syntax",level:3},{value:"amx_ctof",id:"amx_ctof",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"amx_Exec",id:"amx_exec",level:2},{value:"Syntax",id:"syntax-2",level:3},{value:"amx_FindPublic",id:"amx_findpublic",level:2},{value:"Syntax",id:"syntax-3",level:3},{value:"amx_ftoc",id:"amx_ftoc",level:2},{value:"Syntax",id:"syntax-4",level:3},{value:"amx_GetAddr",id:"amx_getaddr",level:2},{value:"Syntax",id:"syntax-5",level:3},{value:"amx_GetString",id:"amx_getstring",level:2},{value:"Syntax",id:"syntax-6",level:3},{value:"amx_Push",id:"amx_push",level:2},{value:"Syntax",id:"syntax-7",level:3},{value:"amx_PushArray",id:"amx_pusharray",level:2},{value:"Syntax",id:"syntax-8",level:3},{value:"amx_PushString",id:"amx_pushstring",level:2},{value:"Syntax",id:"syntax-9",level:3},{value:"amx_Register",id:"amx_register",level:2},{value:"Syntax",id:"syntax-10",level:3},{value:"amx_Release",id:"amx_release",level:2},{value:"Syntax",id:"syntax-11",level:3},{value:"amx_SetString",id:"amx_setstring",level:2},{value:"Syntax",id:"syntax-12",level:3},{value:"amx_StrLen",id:"amx_strlen",level:2},{value:"Syntax",id:"syntax-13",level:3},{value:"amx_StrParam",id:"amx_strparam",level:2},{value:"Syntax",id:"syntax-14",level:3},{value:"Amx function examples",id:"amx-function-examples",level:2},{value:"Registering natives",id:"registering-natives",level:3},{value:"Getting a string and its length",id:"getting-a-string-and-its-length",level:3},{value:"Alternative way to get a string",id:"alternative-way-to-get-a-string",level:3},{value:"How to set a string",id:"how-to-set-a-string",level:3},{value:"Casting and returning floats",id:"casting-and-returning-floats",level:3},{value:"Passing parameters by reference",id:"passing-parameters-by-reference",level:3},{value:"Getting and modding array values",id:"getting-and-modding-array-values",level:3},{value:"Call a callback",id:"call-a-callback",level:3},{value:"Calling natives and hooking callbacks",id:"calling-natives-and-hooking-callbacks",level:2},{value:"Invoke",id:"invoke",level:3},{value:"Getting started",id:"getting-started-1",level:4},{value:"Adding SA-MP natives",id:"adding-sa-mp-natives",level:4},{value:"Calling natives",id:"calling-natives",level:4},{value:"Hooking callbacks",id:"hooking-callbacks",level:3},{value:"Closing",id:"closing",level:2},{value:"Plugin include",id:"plugin-include",level:3},{value:"Plugin source code",id:"plugin-source-code",level:3},{value:"Special thanks",id:"special-thanks",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"I decided to create this topic to address issues and questions that are frequently asked about plugin development. I'm no where near an expert when it comes to C/++, or the plugin SDK, i am simply sharing what i have come to learn over my time of developing plugins. Hopefully once this topic is done it will become more of a group project with other users contributing information that i might not know, or have forgotten to include. This is a pretty big topic to try and cover, so i will need assistance."}),"\n",(0,i.jsx)(n.h2,{id:"this-is-not-a-c-help-forum",children:"This is not a C/++ help forum"}),"\n",(0,i.jsxs)(n.p,{children:['People seem to be very confused when it comes to this post. I\'ve seen a lot of people ask completely valid questions regarding the plugin SDK who end up with multiple "This is not a C/++ help forum!" quotes. Just because someone is expected to know the languages ',(0,i.jsx)(n.strong,{children:"doesn't"})," mean they're not allowed to ask questions about the actual SDK! There is a difference between asking what a pointer is, and asking something like how to create callbacks!"]}),"\n",(0,i.jsx)(n.p,{children:"With that being said there are excellent sites and forums dedicated to teaching and answering questions about C/++. Here are a few that i have used:"}),"\n",(0,i.jsx)(n.p,{children:"These sites have excellent tutorials to learn from:"}),"\n",(0,i.jsx)(n.p,{children:"cprogramming.com"}),"\n",(0,i.jsx)(n.p,{children:"cplusplus.com"}),"\n",(0,i.jsx)(n.p,{children:"learncpp.com"}),"\n",(0,i.jsx)(n.p,{children:"If you get stuck on a C/++ issue you can use one of these forums to ask for assistance:"}),"\n",(0,i.jsx)(n.p,{children:"dreamincode.net"}),"\n",(0,i.jsx)(n.p,{children:"stackoverflow.com"}),"\n",(0,i.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,i.jsx)(n.h3,{id:"quick-questions",children:"Quick Questions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," How are plugins made?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Answer:"})," Plugins are made in C/++ using the plugin SDK. This FAQ assumes you know C/++ already, and will provide some information on the actual SDK later on in the article."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," Can i create a plugin in a programming language other than C/++?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Answer:"})," It's possible in theory. There have been attempts at porting the SA-MP plugin SDK to the programming language D, which supports C's application binary interface. While I've never seen a fully working plugin written in D, this example has shed light on the possibility of writing plugins in languages that support C/++. There also has been talk about the possibility of bindings, but i've yet to see any backing on this."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," How can i get my plugin to be multiplatform (Available on linux and windows)?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Answer: Linux and windows are two different operating systems which both have their own differing API's and implementations. Getting your code to work on both platforms means you have to use platform independent code or a sort of framework that handles everything having to do with platforms FOR you. After you're sure your code doesn't rely on any one API, you simply have to compile your code in your desired environment (once again, this guide assumes you know how to do this)."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," Can my plugin use memory hacking?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Answer: To be honest this is a sort of grey area. Using memory hacking to hook callbacks or call functions seems to be completely acceptable. Anything that modifies the servers memory seems to be off limits (See This). If your planing on making a plugin that needs to use memory hacking for anything other callback hooking or function calling, ask permission before hand and get approval before posting; That honestly is the best way to find out!"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," Is it possible to make a plugin that ",(0,i.jsx)(n.strong,{children:"______"})," ?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Answer:"})," In most cases any idea is completely possible to implement. It may require a stand alone application that communicates to the plugin, but its likely possible. Questions like these should ",(0,i.jsx)(n.strong,{children:"not"})," be posted. You heard the answer, now move on! This is not a plugin request section. Hopefully there will be a day when there is enough plugin creators to have a section or sticky topic for requests (This guide is designed to introduce and help new plugin developers, so lets hope)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," What IDE/Compiler should i use for ",(0,i.jsx)(n.strong,{children:"______"})," ?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Answer:"})," That is completely up to you! I personally will be using VC++ 2010 express as my windows IDE and Compiler, and plan on using g++ for my Linux compiler. Just mess around with different options and see which one you like the best!"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," What is a module definition file (.def)?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Answer:"})," A module definition file is a special file in the Visual Studio IDE that provides the linker with information about the program that's being linked. When it comes to writing plugins for SA-MP we only really use the \"EXPORTS\" statement which provides information about our exported functions. We'll be looking at this statement later in the article."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," When i release a plugin, does it have to have the source with it?"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Answer:"})," If you're releasing something on this forum it ",(0,i.jsx)(n.strong,{children:"always"})," has to have the source with it. Plugins are no exception (unless the plugin is approved by a developer to be posted without a source - maybe an anti-cheat?)."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,i.jsx)(n.p,{children:"You would be shocked how many times i get asked \"How do i get started with plugin development?\". I decided to add this entire section to answer that question! Just because you know the language doesn't mean you know your way around the IDE after all; I think that's especially true when it comes to VC++ 2010. Visual studio can be a very intimidating place to new users. I hardly think its fair to just hand you the plugin SDK without showing you around first! Messing with property pages/the linker can easily scare people away, so I'm going to guide you through it."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," If you chose to use a different IDE/compiler that targets Windows, you're out of luck! It seems that the only way to successfully export functions is to use a module definition file (.DEF). I've tried to include an alternative method in this article using __declspec(dllexport), but this simply didn't work due to the __stdcall calling convention mangling the exported function's names (See: ",(0,i.jsx)(n.a,{href:"https://pastebin.com/y3xkVY70",children:"Here"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"Here are the downloads you'll need for this section:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Visual C++ 2010 express:"})," ",(0,i.jsx)(n.a,{href:"https://visualstudio.microsoft.com/vs/express/",children:"Free download"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Plugin SDK (Plain):"})," ",(0,i.jsx)(n.a,{href:"https://github.com/Zeex/samp-plugin-sdk",children:"Download"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The first thing we want to do is create a new project. Select file->new->project to do just that."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Once you create a new project its going to ask you what type of project you're creating. Select Win32 project, enter a project name, and press OK to continue."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Once your project setting are taken care of this dialog should appear. Press next to continue."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"After you clicked continue you should see this dialog popup asking for your application type and settings. For the type select DLL (Dynamic-link library) and for the settings select empty project. Once you're done press the finish button at the bottom."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'The next thing we want to do is go to our solution explorer. The solution explorer is normally on the left side of the IDE. If you accidentally disabled it you can enable it once again by pressing CTRL+ALT+L or by selecting view->other windows->solution explorer. Once you find the solution explorer right click the project name (In this example its "Test") and select properties.'}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Once you see the property pages navigate to Configuration properties->Linker->Input on the left side. Once you're there you want to add a module definition file. You can name this file anything you like as long as it has a \".def\" extension at the end of it; People normally name def files after their project. Once you've named your definition file press OK."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'Now all we have to do is add our files (this includes our definition file!). To add a file to your project navigate to the solution explorer again, right click the project name, click add, and then select new item. In this example we\'ll be adding our definition file. Since there isnt an option for definition files, just pick a source file (.cpp) and type the name of the module definition file you decided on (Note: Make sure you include the ".def" extension, other wise a ".cpp" extension will be added!). After this is done add a source file for the project the same way (except dont add an extension). Most people use the name "Main" for there main source file.'}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Before we can start adding anything to our two currently empty files, we have to actually add the SDK to the project. If you haven't already, download the SDK from the link that was provided in the beginning of this section. Once its downloaded, extract the SDK folder into your current project's directory. Note This part is optional: I personally like to create filters to organize all our files and code. A filter is an organizational tool in visual studio that creates folders in your project, but doesn't create corresponding Windows folders (its recommended to create matching window folders). To create a filter right click your project in the solution explorer->add->New Filter and select a name for your filter (Name it SDK in this case)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The next step is to add all the SDK files to our current project. To add existing files to a project simply right click the folder or project you wish to add them to and select add -> Existing item. You'll want to add everything that is inside the SDK folder in your project directory (Note: You can select multiple files by holding Ctrl while clicking the files to add). For folder consistency we're gonna create another filter inside the SDK filter, and name it amx. You'll of course want to add all the contents of the SDK\\amx\\ folder into the amx filter."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Now it's time to get this plugin compiled! You should have a module definition file and a source file open if you followed the instructions correctly; If not, go back a few steps and follow the instructions carefully. Go ahead and copy and paste the following information into their corresponding files. Don't worry if you don't understand any of it, we'll be addressing it all in the next section."}),"\n",(0,i.jsx)(n.h3,{id:"source-file-cpp",children:"Source file (*.cpp)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "SDK\\amx\\amx.h"\n#include "SDK\\plugincommon.h"\n\n\ntypedef void (*logprintf_t)(const char* format, ...);\nlogprintf_t logprintf;\nextern void *pAMXFunctions;\n\n\ncell AMX_NATIVE_CALL HelloWorld(AMX* amx, cell* params)\n{\n    logprintf("This was printed from the Test plugin! Yay!");\n    return 1;\n}\n\nPLUGIN_EXPORT unsigned int PLUGIN_CALL Supports()\n{\n    return SUPPORTS_VERSION | SUPPORTS_AMX_NATIVES;\n}\n\nPLUGIN_EXPORT bool PLUGIN_CALL Load(void **ppData)\n{\n    pAMXFunctions = ppData[PLUGIN_DATA_AMX_EXPORTS];\n    logprintf = (logprintf_t) ppData[PLUGIN_DATA_LOGPRINTF];\n\n    logprintf(" * Test plugin was loaded.");\n    return true;\n}\n\nPLUGIN_EXPORT void PLUGIN_CALL Unload()\n{\n    logprintf(" * Test plugin was unloaded.");\n}\n\nAMX_NATIVE_INFO PluginNatives[] =\n{\n    {"HelloWorld", HelloWorld},\n    {0, 0}\n};\n\nPLUGIN_EXPORT int PLUGIN_CALL AmxLoad( AMX *amx )\n{\n    return amx_Register(amx, PluginNatives, -1);\n}\n\n\nPLUGIN_EXPORT int PLUGIN_CALL AmxUnload( AMX *amx )\n{\n    return AMX_ERR_NONE;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"module-definition-file-def",children:"Module definition file (*.def)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"EXPORTS\n      Supports\n      Load\n      Unload\n      AmxLoad\n      AmxUnload\n"})}),"\n",(0,i.jsx)(n.h2,{id:"examining-the-code",children:"Examining the code"}),"\n",(0,i.jsxs)(n.p,{children:["In this section we'll be taking a look at some of the defines, structures, and functions that the SA-MP plugin SDK has to offer. You should have a comfortable understanding of C/++ before proceeding, as i will ",(0,i.jsx)(n.strong,{children:"just"})," be explaining SDK related information once we hit the coded segments. From here on out, there wont be any hand holding!"]}),"\n",(0,i.jsx)(n.h3,{id:"the-module-definition-file",children:"The module definition file"}),"\n",(0,i.jsx)(n.p,{children:"Before we take a look at the code, we're gonna check out the module definition file we created in the previous section. First of all, what exactly is a module definition file? We know its a visual studio exclusive feature, but what exactly does it do? Its simple! A module definition file provides information to the linker about the code that is being linked. There are a lot of rules and statements that can be used in these files, but we're just gonna talk about one, the EXPORTS statement."}),"\n",(0,i.jsxs)(n.h4,{id:"what-is-exports",children:['What is "',(0,i.jsx)(n.strong,{children:"EXPORTS"}),'"']}),"\n",(0,i.jsx)(n.p,{children:"Exports is a statement that allows us to... well, export stuff to our application! Why do we do this? Because we have to, its as simple as that. The functions we export are entry points in our DLL file. Applications can only touch the functions in our DLL that we export; if we don't export them they remain private to the DLL file. We don't want that now, do we? No. So we export everything that that application is going to be directly accessing."}),"\n",(0,i.jsx)(n.h4,{id:"exported-functions",children:"Exported functions"}),"\n",(0,i.jsxs)(n.p,{children:["There are currently 6 functions that need to be exported. We use 5 of them inside of our project that we've been setting up. Don't worry about the ",(0,i.jsx)(n.code,{children:"PLUGIN_EXPORT"}),", and ",(0,i.jsx)(n.code,{children:"PLUGIN_CALL"})," definitions you see in the function declarations. We will be covering these along with some other important definitions (marked by green text) later in the article."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Functions"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Supports()"})}),(0,i.jsxs)(n.td,{children:["This function tells the server what capabilities our plugin will have based on what it returns. Generally we only use 3 support flags in plugins: ",(0,i.jsx)(n.strong,{children:"SUPPORTS_VERSION"}),", ",(0,i.jsx)(n.strong,{children:"SUPPORTS_AMX_NATIVES"}),", and ",(0,i.jsx)(n.strong,{children:"SUPPORTS_PROCESS_TICK"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Load(void**)"})}),(0,i.jsxs)(n.td,{children:["The Load function is pretty straight forward. This is called when the plugin is loaded and gets passed an array of addresses that the plugin will use to function. The two indexes we typically use are ",(0,i.jsx)(n.strong,{children:"PLUGIN_DATA_AMX_EXPORTS"}),", and ",(0,i.jsx)(n.strong,{children:"PLUGIN_DATA_LOGPRINTF"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Unload()"})}),(0,i.jsx)(n.td,{children:"Unload is called when the plugin is unloaded (server is shutdown)."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AmxLoad(AMX*)"})}),(0,i.jsx)(n.td,{children:"This is called when a new AMX instance is loaded into the server. This will be called for every filterscript/gamemode! Because of this it isn't a good idea to store a single AMX instance for the entire plugin, instead use a queue/list/vector. In this function we also register our custom native functions we wish to provide PAWN with."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AmxUnload(AMX*)"})}),(0,i.jsx)(n.td,{children:"This function is called when ever an AMX instance is unloaded. If you store AMX instances, make sure you remove them. Otherwise you'll have instances to non-existing gamemodes/filterscripts."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ProcessTick()"})}),(0,i.jsxs)(n.td,{children:["ProcessTick is a function that gets called on every iteration of the server's loop. People generally use this function as a method of managing time by keeping track of the amount of ticks that have passed. The SA-MP server is said to have a sleep time of 5ms, so if 50 ticks go by you have an idea of the elapsed time (5 * 50 = 250ms). ",(0,i.jsx)(n.strong,{children:"Note:"})," Anyone who uses threads in their plugins and require PAWN interaction needs to use this function to ensure PAWN isnt busy doing another task!"]})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"defines-and-structures",children:"Defines and structures"}),"\n",(0,i.jsx)(n.p,{children:"Now comes the fun part, we get to take a look at the code! You'll probably notice right off the bat that we're using a ton of defines and structures through our little example from the previous section. If you haven't ever developed a SA-MP plugin before, these can appear very confusing and even intimidating. We'll be shedding some light on these defines and structures in this section."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Defines/Structures"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"cell"})}),(0,i.jsxs)(n.td,{children:['A "cell" is a typedef that is simply there for portability. PAWN offers support for 16bit, 32bit, and 64bit integers. The typedef "cell" will always be the correct size while "int" might not be. Generally with SA-MP plugins, this typedef will always be a 32bit integer. ',(0,i.jsx)(n.strong,{children:"Note:"}),' There is also a "ucell" typedef for unsigned integers, but this is hardly used.']})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AMX_NATIVE_CALL"})}),(0,i.jsx)(n.td,{children:"This defines the calling convention that our native functions will use. At the moment its defined to nothing, so the default will be used."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AMX"})}),(0,i.jsx)(n.td,{children:"The name of this structure should be pretty clear, its an AMX instance. This structure has tons of information relating to the data segments along with tons of other amx related information. This structure must be present in all native function declarations along with a cell pointer to the passed parameters; Without this info we dont know what script is calling our native, nor do we know what was passed."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"PLUGIN_EXPORT"})}),(0,i.jsx)(n.td,{children:'This is defined as "PLUGIN_EXTERN_C".'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"PLUGIN_EXTERN_C"})}),(0,i.jsx)(n.td,{children:'If using a C++ compiler this is defined as "extern "C"". This is for compatibility with C. C++ offers things like function overloading so additional information like the number/size of arguments is stored with the function\'s name, this is refered to as "name mangling". When this define is used, it tells C++ to use C-style linkage and thus avoids C++ name mangling.'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"PLUGIN_CALL"})}),(0,i.jsx)(n.td,{children:"This define tells C/++ what calling convention to use for our exported functions. If you use a compiler targeting windows, this is defined as __stdcall. Otherwise its defined as nothing and the default convention is used."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"SUPPORTS_VERSION"})}),(0,i.jsx)(n.td,{children:'This define is to be used in a bit mask that is returned by our "Supports()" function. This flag is used to check for compatibility with the server.'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"SUPPORTS_AMX_NATIVES"})}),(0,i.jsx)(n.td,{children:'This is yet another define that is to be used by our "Supports()" function. Any plugin that uses AMX functions must use this flag! Without this flag you\'ll get a run time 19 error due to your natives not registering with the server (amx_Register).'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"SUPPORTS_PROCESS_TICK"})}),(0,i.jsx)(n.td,{children:'Our last flag for our "Supports()" function. If you\'re going to be using the "ProcessTick()" function, you have to add this to our "Supports()" function\'s returned bit mask.'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"PLUGIN_DATA_AMX_EXPORTS"})}),(0,i.jsx)(n.td,{children:"This is used as an index to the multidimensional array that gets passed on Load. This particular index holds the AMX function table. All plugins must use this index to assign the address of the function table to pAMXFunctions."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"PLUGIN_DATA_LOGPRINTF"})}),(0,i.jsx)(n.td,{children:"Yet another index that is to be used with the multidimensional array that gets passed on Load. This index holds the address of the logprintf function which prints information and saves said information to the server's log file. If your plugin uses this function you must use this index to assign the address to the logprintf function pointer."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AMX_NATIVE_INFO"})}),(0,i.jsx)(n.td,{children:"This struct is used in conjunction with amx_Register. It contains a string that holds your new native's name, and a pointer to it's address."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["There are a few other important definitions that relate to AMX function errors, but they're already documented inside of the amx header. So instead of reinventing the wheel, I'm just going to post the enum with all the error codes and their corresponding comments. ",(0,i.jsx)(n.strong,{children:"Note:"})," Every amx function, with the exception of amx_NativeInfo, returns one of these error codes if a problem was encountered."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"enum\n{\n  AMX_ERR_NONE,\n  /* reserve the first 15 error codes for exit codes of the abstract machine */\n  AMX_ERR_EXIT,         /* forced exit */\n  AMX_ERR_ASSERT,       /* assertion failed */\n  AMX_ERR_STACKERR,     /* stack/heap collision */\n  AMX_ERR_BOUNDS,       /* index out of bounds */\n  AMX_ERR_MEMACCESS,    /* invalid memory access */\n  AMX_ERR_INVINSTR,     /* invalid instruction */\n  AMX_ERR_STACKLOW,     /* stack underflow */\n  AMX_ERR_HEAPLOW,      /* heap underflow */\n  AMX_ERR_CALLBACK,     /* no callback, or invalid callback */\n  AMX_ERR_NATIVE,       /* native function failed */\n  AMX_ERR_DIVIDE,       /* divide by zero */\n  AMX_ERR_SLEEP,        /* go into sleepmode - code can be restarted */\n  AMX_ERR_INVSTATE,     /* invalid state for this access */\n\n  AMX_ERR_MEMORY = 16,  /* out of memory */\n  AMX_ERR_FORMAT,       /* invalid file format */\n  AMX_ERR_VERSION,      /* file is for a newer version of the AMX */\n  AMX_ERR_NOTFOUND,     /* function not found */\n  AMX_ERR_INDEX,        /* invalid index parameter (bad entry point) */\n  AMX_ERR_DEBUG,        /* debugger cannot run */\n  AMX_ERR_INIT,         /* AMX not initialized (or doubly initialized) */\n  AMX_ERR_USERDATA,     /* unable to set user data field (table full) */\n  AMX_ERR_INIT_JIT,     /* cannot initialize the JIT */\n  AMX_ERR_PARAMS,       /* parameter error */\n  AMX_ERR_DOMAIN,       /* domain error, expression result does not fit in range */\n  AMX_ERR_GENERAL,      /* general error (unknown or unspecific error) */\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"amx-functions",children:"Amx functions"}),"\n",(0,i.jsx)(n.p,{children:"The amx functions are very well documented documented inside of the PAWN implementers guide, which can be found here. Instead of reinventing the wheel and explaining all the functions in my own words, im simply going to copy them here from the implementers guide, and make them a bit more presentable; I believe this will make the content much more accessible. With that said, this section will be mostly a reference for the next section which is focused on something that the implementers guide lacks, example code. Note: I will only be covering the functions that i think are vital for plugins (for now). Anything else can be found in the implementers guide, just make sure you use the version i linked to in this section!"}),"\n",(0,i.jsx)(n.h3,{id:"key",children:"Key"}),"\n",(0,i.jsx)(n.p,{children:"+ => Not Available"}),"\n",(0,i.jsx)(n.h2,{id:"amx_allot",children:"amx_Allot"}),"\n",(0,i.jsx)(n.p,{children:"- Reserve heap space in the abstract machine"}),"\n",(0,i.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_Allot(AMX *amx, int cells, cell *amx_addr, cell **phys_addr);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"cells"})}),(0,i.jsx)(n.td,{children:"The number of cells to reserve."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx_addr"})}),(0,i.jsx)(n.td,{children:"The address of the allocated cell as the pawn program (that runs in the abstract machine) can access it. phys_addr The address of the cell for C/C++ programs to access."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," In earlier releases of pawn, arrays and strings had to be passed to a script after explicitly allocating memory for it on the amx stack. In the current release, this functionality has been largely replaced by the functions amx_PushArray and amx_PushString. A pawn function can only access memory inside its abstract machine. If a parameter is to be passed \u201Cby reference\u201D to a pawn function, one must pass the address of that parameter to amx_Exec. In addition, that address itself must be within the address range of the abstract machine too. An added complexity is that the abstract machine uses addresses that are relative to the data section of the abstract machine, and the host program uses address relative to the environment that the operating system gives it."]}),"\n",(0,i.jsx)(n.p,{children:"amx_Allot allocates memory cells inside the abstract machine and it returns two addresses. The amx_addr parameter is the address of the variable relative to the \u201Cdata section\u201D of the abstract machine; this is the value you should pass to amx_Exec (via amx_Push). Pa- rameter phys_addr holds the address relative to the host program\u2019s address space. So a C/C++ program can use this address and write into the allocated memory. After amx_Exec returns, you may inspect the memory block (the pawn function called by amx_Exec may have written into it) and finally release it by calling amx_Release."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_exec",children:"amx_Exec"}),", ",(0,i.jsx)(n.a,{href:"#amx_pusharray",children:"amx_PushArray"}),", ",(0,i.jsx)(n.a,{href:"#amx_pushstring",children:"amx_PushString"}),", ",(0,i.jsx)(n.a,{href:"#amx_release",children:"amx_Release"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_ctof",children:"amx_ctof"}),"\n",(0,i.jsx)(n.p,{children:"- Cast \u201Ccell\u201D to \u201Cfloat\u201D"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"[float] amx_ctof([cell] c);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"c"})}),(0,i.jsx)(n.td,{children:"The value to cast from \u201Ccell\u201D type to \u201Cfloat\u201D."})]})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," The same bit pattern, but now as a floating point type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This macro casts a \u201Ccell\u201D type into a \u201Cfloat\u201D type without changing the bit pattern. A normal type cast in C/C++ changes the memory representation of the expression so that its numeric value in IEEE 754 format comes closest to the original integer value. The pawn parser and abstract machine store floating point values in a cell \u2014 when retrieving a floating point value from a cell, the bit pattern must not be changed."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_ftoc",children:"amx_ftoc"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_exec",children:"amx_Exec"}),"\n",(0,i.jsx)(n.p,{children:"- Run code"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-2",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  int amx_Exec(AMX *amx, long *retval, int index);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine from which to call a function."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"retval"})}),(0,i.jsx)(n.td,{children:"Will hold the return value of the called function uponreturn. This parameter may be NULL if you are notinterested in the return value."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"index"})}),(0,i.jsx)(n.td,{children:"An index into the \u201Cpublic function table\u201D; it indicatesthe function to execute. See amx_FindPublic formoreinformation. Use AMX_EXEC_MAIN to start executingat the main function, and AMX_EXEC_CONT to continueexecution from a \u201Csleep state\u201D."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This function runs the script, starting at the indicated function. It calls the callback function for any native function call that the code in the amx makes. amx_Exec assumes that all native functions are correctly initialized with amx_Register."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_findpublic",children:"amx_FindPublic"}),", ",(0,i.jsx)(n.a,{href:"#amx_register",children:"amx_Register"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_findpublic",children:"amx_FindPublic"}),"\n",(0,i.jsx)(n.p,{children:"- Return the index of a public function"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-3",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_FindPublic(AMX *amx, char *funcname, int *index);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"funcname"})}),(0,i.jsx)(n.td,{children:"The name of the public function to find."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"index"})}),(0,i.jsx)(n.td,{children:"Upon return, this parameter holds the index of therequested public function."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_exec",children:"amx_Exec"}),", amx_FindNative+, amx_FindPubVar+, amx_GetPublic+, amx_NumPublics+"]}),"\n",(0,i.jsx)(n.h2,{id:"amx_ftoc",children:"amx_ftoc"}),"\n",(0,i.jsx)(n.p,{children:"- Cast \u201Cfloat\u201D to \u201Ccell\u201D"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-4",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"[cell] amx_ftoc([float] f);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"f"})}),(0,i.jsx)(n.td,{children:"The value to cast from \u201Cfloat\u201D type to \u201Ccell\u201D."})]})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," The same bit pattern, but now as a \u201Ccell\u201D type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This macro casts a \u201Cfloat\u201D type into a \u201Ccell\u201D type without changing the bit pattern. A normal type cast in C/C++ changes the memory representation of the expression so that its numeric value in integer format is the integral (truncated) value of the original rational value. The pawn parser and abstract machine store floating point values in a cell \u2014when storing a floating point value in a cell, the bit pattern must not be changed."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_ctof",children:"amx_ctof"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_getaddr",children:"amx_GetAddr"}),"\n",(0,i.jsx)(n.p,{children:"- Resolve an AMX address"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-5",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_GetAddr(AMX *amx,cell amx_addr,cell **phys_addr);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx_addr"})}),(0,i.jsx)(n.td,{children:"The address relative to the abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"phys_addr"})}),(0,i.jsx)(n.td,{children:"A pointer to the variable that will hold the memoryaddress of the indicated cell. If the amx_addr parame-ter is not a valid address inside the abstract machine,phys_addr will be set to NULL."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This function returns the memory address of an address in the abstract machine. One typically uses this function in an extension module, because it allows you to access variables inside the abstract machine."]}),"\n",(0,i.jsx)(n.h2,{id:"amx_getstring",children:"amx_GetString"}),"\n",(0,i.jsx)(n.p,{children:"- Retrieve a string from the abstract machine"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-6",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_GetString(char *dest, cell *source, int use_wchar, size_t size);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"dest"})}),(0,i.jsx)(n.td,{children:"A pointer to a character array of sufficient size to holdthe converted source string."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"source"})}),(0,i.jsx)(n.td,{children:"A pointer to the source string. Use amx_GetAddr toconvert a string address in the amx to the physicaladdress."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"use_wchar"})}),(0,i.jsx)(n.td,{children:"A non-zero value interprets the dest argument as apointer to \u201Cwide characters\u201D \u2014i.e. wchar_t, regard-less of its char type. This allows the function to storeUnicode strings."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"size"})}),(0,i.jsx)(n.td,{children:"The maximum number of characters to store in dest,including the terminating zero byte. If the string inthe source is longer, the string in dest will be trun-cated."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This function converts both packed strings and unpacked strings from the \u201Cpawn\u201D format to the \u201CC format. When retrieving an unpacked string with parameter use_wchar set to zero, the function may truncate characters from wide characters to 8-bit ASCII/ANSI."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_setstring",children:"amx_SetString"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_push",children:"amx_Push"}),"\n",(0,i.jsx)(n.p,{children:"- Pass a numeric argument \u201Cby-value\u201D"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-7",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_Push(AMX *amx, cell value);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"value"})}),(0,i.jsx)(n.td,{children:"The value to pass to the public function."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," Any parameters to a public function must be pushed to the function before calling amx_Exec. If a public function has multiple arguments, the arguments must be pushed int reverse order."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_exec",children:"amx_Exec"}),", ",(0,i.jsx)(n.a,{href:"#amx_pusharray",children:"amx_PushArray"}),", ",(0,i.jsx)(n.a,{href:"#amx_pushstring",children:"amx_PushString"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_pusharray",children:"amx_PushArray"}),"\n",(0,i.jsx)(n.p,{children:"- Pass an argument or array \u201Cby-reference\u201D"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-8",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_PushArray(AMX *amx, cell *amx_addr, cell **phys_addr, const cell array[], int numcells);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx_addr"})}),(0,i.jsx)(n.td,{children:"The address of the allocated cell as the pawn program (that runs in the abstract machine) can access it, needed to release the memory block. This parameter may be NULL."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"phys_addr"})}),(0,i.jsx)(n.td,{children:"The address of the cell for C/C++ programs to access. This parameter may be NULL."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"array"})}),(0,i.jsx)(n.td,{children:"The array of values to pass to the public function. A single cell that must be passed by-reference is regarded as a single-cell array."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"numcells"})}),(0,i.jsx)(n.td,{children:"The number of elements in the array."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," Any parameters to a public function must be pushed to the function before calling amx_Exec. If a public function has multiple arguments, the arguments must be pushed int reverse order. The function allocates memory for the array inside the \u201Cheap\u201D of the abstract machine. This memory must be freed with amx_Release. See function amx_Allot for details on the parameters amx_addr and phys_addr."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_exec",children:"amx_Exec"}),", ",(0,i.jsx)(n.a,{href:"#amx_push",children:"amx_Push"}),", ",(0,i.jsx)(n.a,{href:"#amx_pushstring",children:"amx_PushString"}),", ",(0,i.jsx)(n.a,{href:"#amx_release",children:"amx_Release"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_pushstring",children:"amx_PushString"}),"\n",(0,i.jsx)(n.p,{children:"- Pass a string argument"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-9",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx PushString(AMX *amx, cell *amx_addr, cell **phys_addr, const char *string, int pack, int use_wchar);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx_addr"})}),(0,i.jsx)(n.td,{children:"The address of the allocated cell as the pawn program (that runs in the abstract machine) can access it, needed to release the memory block. This parameter may be NULL."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"phys_addr"})}),(0,i.jsx)(n.td,{children:"The address of the cell for C/C++ programs to access. This parameter may be NULL."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"string"})}),(0,i.jsx)(n.td,{children:"The string to pass to the public function."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"pack"})}),(0,i.jsx)(n.td,{children:"Non-zero to convert the source string to a packed string in the abstract machine, zero to convert the source string to a cell string."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"use_wchar"})}),(0,i.jsx)(n.td,{children:"A non-zero value interprets the string argument as a pointer to \u201Cwide characters\u201D i.e. wchar_t, regardless of its char type. This allows the function to accept Unicode strings."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," Any parameters to a public function must be pushed to the function before calling amx_Exec. If a public function has multiple arguments, the arguments must be pushed int reverse order. The function allocates memory for the array inside the \u201Cheap\u201D of the abstract machine. This memory must be freed with amx_Release. See function amx_Allot for details on the parameters amx_addr and phys_addr. When you pass in an Unicode string and request a packed format in the abstract machine (i.e. both pack and use_wchar are true), the characters are truncated to 8-bits."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_exec",children:"amx_Exec"}),", ",(0,i.jsx)(n.a,{href:"#amx_push",children:"amx_Push"}),", ",(0,i.jsx)(n.a,{href:"#amx_pusharray",children:"amx_PushArray"}),", ",(0,i.jsx)(n.a,{href:"#amx_release",children:"amx_Release"}),", ",(0,i.jsx)(n.a,{href:"#amx_setstring",children:"amx_SetString"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_register",children:"amx_Register"}),"\n",(0,i.jsx)(n.p,{children:"- Make native functions known"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-10",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx Register(AMX *amx, AMX NATIVE INFO *list, int number);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"list"})}),(0,i.jsx)(n.td,{children:"An array with structures where each structure holdsa pointer to the name of a native function and a function pointer. The list is optionally terminated with astructure holding two NULL pointers."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"number"})}),(0,i.jsx)(n.td,{children:"The number of structures in the list array, or -1 if thelist ends with a structure holding two NULL pointers."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," On success, this function returns 0 (AMX_ERR_NONE). If this function returns the error code AMX_ERR_NOTFOUND, one or more native functions that are used by the pawn program are not found in the provided list. You can call amx_Register again to register additional function lists."]}),"\n",(0,i.jsx)(n.p,{children:"To check whether all native functions used in the compiled script have been registered, call amx_Register with the parameter list set to NULL. This call will not register any new native functions, but still return AMX_ERR_NOTFOUND if any native function is unregistered."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," amx_NativeInfo+"]}),"\n",(0,i.jsx)(n.h2,{id:"amx_release",children:"amx_Release"}),"\n",(0,i.jsx)(n.p,{children:"- Free heap space in the abstract machine"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-11",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx Release(AMX *amx,cell amx_addr);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx_addr"})}),(0,i.jsx)(n.td,{children:"The address of the allocated cell as the pawn program (that runs in the abstract machine) sees it. This value is returned by amx_Allot, amx_PushArray and amx_PushString."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," amx_Allot allocates memory on the heap in ascending order (the heap grows upwards). amx_Release frees all memory above the value of the input parameter amx_addr. That is, a single call to amx_Release can free multiple calls to amx_Allot if you pass the amx_addr value of the first allocation.amx_PushArray and amx_PushString use amx_Allot internally, so the same procedure applies to these functions as well."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_allot",children:"amx_Allot"}),", ",(0,i.jsx)(n.a,{href:"#amx_pusharray",children:"amx_PushArray"}),", ",(0,i.jsx)(n.a,{href:"#amx_pushstring",children:"amx_PushString"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_setstring",children:"amx_SetString"}),"\n",(0,i.jsx)(n.p,{children:"- Store a string in the abstract machine"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-12",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx SetString(cell *dest, char *source, int pack, int use_wchar, size_t size);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"dest"})}),(0,i.jsx)(n.td,{children:"A pointer to a character array in the amx where the converted string is stored. Use amx_GetAddr to convert a string address in the amx to the physical address."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"source"})}),(0,i.jsx)(n.td,{children:"A pointer to the source string."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"pack"})}),(0,i.jsx)(n.td,{children:"Non-zero to convert the source string to a packed string in the abstract machine, zero to convert the source string to a cell string."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"string"})}),(0,i.jsx)(n.td,{children:"The string to pass to the public function."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"use_wchar"})}),(0,i.jsx)(n.td,{children:"A non-zero value interprets the string argument as a pointer to \u201Cwide characters\u201D i.e. wchar_t, regardless of its char type. This allows the function to accept Unicode strings."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"size"})}),(0,i.jsx)(n.td,{children:"The maximum number of cells to store in dest, including the terminating zero byte or cell. If the string in the source is longer than can fit in the number of cells in dest, it will be truncated."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," When you pass in an Unicode string and request a packed format in the abstract machine (i.e. both pack and use_wchar are true), the characters are truncated to 8-bits."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_getstring",children:"amx_GetString"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx_strlen",children:"amx_StrLen"}),"\n",(0,i.jsx)(n.p,{children:"- Get the string length in characters"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-13",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int amx_StrLen(const cell *cstring, int *length);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"cstring"})}),(0,i.jsx)(n.td,{children:"The string in the abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"length"})}),(0,i.jsx)(n.td,{children:"This parameter will hold the string length upon return."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This function determines the length in characters of the string, not including the zero-terminating character (or cell). A packed string occupies less cells than its number if characters. If the cstring parameter is NULL, the length parameter is set to zero (0) and the function returns with an error code. For converting unpacked strings to UTF-8, function amx_UTF8Len may be more convenient."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_getaddr",children:"amx_GetAddr"}),", ",(0,i.jsx)(n.a,{href:"#amx_getstring",children:"amx_GetString"}),", ",(0,i.jsx)(n.a,{href:"#amx_setstring",children:"amx_SetString"}),", ",(0,i.jsx)(n.a,{href:"#amx_strparam",children:"amx_StrParam"}),", amx_UTF8Len+"]}),"\n",(0,i.jsx)(n.h2,{id:"amx_strparam",children:"amx_StrParam"}),"\n",(0,i.jsx)(n.p,{children:"- Get a string parameter from an abstract machine"}),"\n",(0,i.jsx)(n.h3,{id:"syntax-14",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"amx_StrParam([AMX*] amx, int] param, [char*] result);\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"amx"})}),(0,i.jsx)(n.td,{children:"The abstract machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"param"})}),(0,i.jsx)(n.td,{children:"The parameter number."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"result"})}),(0,i.jsx)(n.td,{children:"A variable that will hold the result on return."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Notes:"})," This macro allocates a block of memory (with alloca) and copies a string parameter (to a native function) in that block. See page 56 for an example of using this macro."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"See also:"})," ",(0,i.jsx)(n.a,{href:"#amx_getaddr",children:"amx_GetAddr"}),", ",(0,i.jsx)(n.a,{href:"#amx_getstring",children:"amx_GetString"}),", ",(0,i.jsx)(n.a,{href:"#amx_strlen",children:"amx_StrLen"})]}),"\n",(0,i.jsx)(n.h2,{id:"amx-function-examples",children:"Amx function examples"}),"\n",(0,i.jsx)(n.p,{children:"In an attempt at avoiding huge text walls, I've decided to add comments to the code explaining what I'm doing instead of typing it out in the topic. It's probably a good idea to have the wiki article open as a reference while reading the examples."}),"\n",(0,i.jsx)(n.h3,{id:"registering-natives",children:"Registering natives"}),"\n",(0,i.jsx)(n.p,{children:"Every single function we provide PAWN with has to be registered so the abstract machine can be aware of its existence. So i think its probably a good idea to start off with amx_Regester! Luckily we actually already used an example of registering a native one of our previous sections, so I'll be using that example again and adding some comments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"//An array of the functions we wish to register with the abstract machine.\nAMX_NATIVE_INFO PluginNatives[] =\n{\n    //Here we specify our native functions information and terminate the array with two null values.\n    {\"HelloWorld\", HelloWorld},\n    {0, 0}\n};\n\nPLUGIN_EXPORT int PLUGIN_CALL AmxLoad( AMX *amx )\n{\n    //Here we register our natives to the abstract machine. Note how we're using -1. Normally this would have to be the number of\n    //functions we're registering, but since we terminated the array with two null values, we can specify -1.\n    return amx_Register(amx, PluginNatives, -1);\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"getting-a-string-and-its-length",children:"Getting a string and its length"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"//This function demonstrates: how to get a string (and its length) from PAWN.\n//PAWN native: native PrintPawnString(const str[]);\ncell AMX_NATIVE_CALL PrintPawnString(AMX* amx, cell* params)\n{\n    int\n        len = NULL,\n        ret = NULL;\n\n    cell *addr  = NULL;\n\n    //Get the address of our string param (str) and then get its length\n    amx_GetAddr(amx, params[1], &addr);\n    amx_StrLen(addr, &len);\n\n    //if the length of input isnt 0\n    if(len)\n    {\n        //We increase len because we want to make room for the terminating null char when we allocate memory.\n        //Also because GetString's size parameter counts the null chracter, we have to specify the length\n        //of the string + 1; otherwise our string will be truncated to make room for the null char (we'd lose 1 character).\n        len++;\n\n        //Allocate memory to hold our string we're passing (str) and then \"get\" the string using our allocated memory to store it.\n        char* text = new char[ len ];\n        amx_GetString(text, addr, 0, len);\n\n        //Use logprintf to print out string (text). We dont use std::cout because it doesnt write to the server log (only the console).\n        logprintf(text);\n\n        //Deallocate our memory...\n        delete[] text;\n    }\n    return 1;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"alternative-way-to-get-a-string",children:"Alternative way to get a string"}),"\n",(0,i.jsx)(n.p,{children:"I decided to add this section because i know people are going to be tempted by the simplicity of it, and i think they should know the risks and problems that can come from it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"//This function demonstrates: an alternative method to getting strings from pawn- and the possible risks that come with it.\n//PAWN native: native PrintPawnString2(const str[]);\ncell AMX_NATIVE_CALL PrintPawnString2(AMX* amx, cell* params)\n{\n    //This method is NOT recomended as the amx_StrParam macro uses the alloca function which is NOT a standard in C, OR C++.\n    //Using this method comes with risks of overflowing the stack (If you allocate large amounts of memory) and also\n    //gives you the risk of bugs (this function is machine AND compiler dependent- some implementations are said to be bugged).\n\n    char* text = NULL;\n    amx_StrParam(amx, params[1], text);\n\n    //Check if text is null\n    if(text != NULL)\n    {\n        //Use logprintf to print out string (text). We dont use std::cout because it doesnt write to the server log (only the console).\n        logprintf(text);\n    }\n    return 1;\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"how-to-set-a-string",children:"How to set a string"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'//This function demonstrates: how to modify a PAWN string.\n//PAWN native: native SetPawnString(str[], len = sizeof(str));\ncell AMX_NATIVE_CALL SetPawnString(AMX* amx, cell* params)\n{\n    const string message = "This is a string from C/++!!";\n    cell* addr = NULL;\n\n    //Get the address of our string parameter (str) and store our message\n    amx_GetAddr(amx, params[1], &addr);\n    amx_SetString(addr, message.c_str(), 0, 0, params[2]);\n    return 1;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"casting-and-returning-floats",children:"Casting and returning floats"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"//This function demonstrates: how to cast a float to a PAWN float, and return it.\n//PAWN native: native Float:ReturnPawnFloatVal();\ncell AMX_NATIVE_CALL ReturnPawnFloatVal(AMX* amx, cell* params)\n{\n    //Since PAWN is a typeless language it stores everything as a 32bit integer and relies on tags to handle special data.\n    //A floating point number is no exception to this; It's a still 32bit int, but it has a Float tag to show that it shouldnt\n    //be treated like an regular integer. So how do we convert a float to an 32bit integer (for PAWN) without losing data?\n    //The answer is the amx_ftoc macro!\n\n    //The macro amx_ftoc type casts a float into a cell while preserving its bit pattern (amx_ctof does the inverse).\n    const float f = 22.624f;\n    return amx_ftoc(f);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"passing-parameters-by-reference",children:"Passing parameters by reference"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'//This function demonstrates: How to pass parameters by reference.\n//PAWN native: native SetPawnReferenceVars(&value1, &Float:value2);\ncell AMX_NATIVE_CALL SetPawnReferenceVars(AMX* amx, cell* params)\n{\n    const int val = 65;\n    const float val2 = 84.54f;\n\n    cell* addr[2] = {NULL, NULL};\n\n    //Get the addresses of "value1" and "value2"\n    amx_GetAddr(amx, params[1], &addr[0]);\n    amx_GetAddr(amx, params[2], &addr[1]);\n\n    //Dereference our pointers and assign our values. Remember to ALWAYS use the macro "amx_ftoc" to convert floats into\n    //cells (the appropriate float format for PAWN)!\n    *addr[0] = val;\n    *addr[1] = amx_ftoc(val2);\n\n    return 1;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"getting-and-modding-array-values",children:"Getting and modding array values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'//This function demonstrates: how to get and modify array values.\n//PAWN native: native PrintPawnArray(arr[], size = sizeof(arr));\ncell AMX_NATIVE_CALL PrintPawnArray(AMX* amx, cell* params)\n{\n    //Make sure there\'s something to print...\n    if(params[2] > 0)\n    {\n        cell* addr = NULL;\n\n        //Get the address of the first value in our PAWN array.\n        amx_GetAddr(amx, params[1], &addr);\n\n        for(int i = 0, l = params[2]; i < l; i++)\n        {\n            //This is pretty straight forward: We dereference the addr pointer to get our value to print.\n            //You should know this already, but arrays and pointers are almost the same thing, so we can use pointer\n            //arithmetic to add an offset OR just use the subscript operator (in the end *(addr+1) and addr[1] are the same).\n            logprintf("arr[%d] = %d", i, *(addr + i));\n\n            //If you wanted to modify the array you would just change its value by dereferencing addr and assigning a new value.\n            //You should know this as well, im just adding it in for completeness. Here we change the first value of our array\n            //to 5 (Note: Since its the first value, no offset it used).\n\n            // *(addr) = 5;\n        }\n    }\n    return 1;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"call-a-callback",children:"Call a callback"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"//This function demonstrates: How to call a callback that is in a PAWN script.\n//PAWN native: native EmitPawnCallback();\ncell AMX_NATIVE_CALL EmitPawnCallback(AMX* amx, cell* params)\n{\n    int idx;\n\n    const cell var = 3;\n    const cell arr[] = {100, 4, 33};\n    const string str = \"Some random message from C++.\";\n\n\n    //Pawn callback: forward OnPawnCallbackEmitted(var, arr[], str[]);\n    //Find our callback and store its place in the public function table (it's index) into our idx var.\n    if(!amx_FindPublic(amx, \"OnPawnCallbackEmitted\", &idx))\n    {\n        cell\n            ret,\n            addr;\n\n        //Here we push our arguments to our function. Note that if the function has multiple arguments you have to push your\n        //values in reverse order! Thats why we're pushing the string first, then the array, and finally our integer.\n\n        amx_PushString(amx, &addr, NULL, str.c_str(), NULL, NULL);\n        //amx_PushArray(amx, NULL, NULL, arr, sizeof(arr) / sizeof(cell));\n\n        cell\n            amx_addr,\n            *phys_addr;\n\n        //For some reason amx_PushArray seems to be crashing the server, and i have NO idea why. My usage should be completely\n        //valid judging from the implementers guide, and the code itself. Since the function isnt working we'll have to\n        //use the old method and allocate the memory, set it, and push it all ourselves. This is pretty straight forward. We\n        //allocate memory on the heap using amx_Allot (this returns 2 addresses- one of the location in the abstract machine\n        //(amx_addr), and one relative to the actual server's address space (phsy_addr - which we can use in C++)). Once the\n        //memory is allocated we use memcpy to copy the memory from our array to our phys_addr address location.\n        amx_Allot(amx, sizeof(arr) / sizeof(cell), &amx_addr, &phys_addr);\n        memcpy(phys_addr, arr, sizeof(arr));\n        amx_Push(amx, amx_addr);\n\n        //Push our integer value\n        amx_Push(amx, var);\n\n        //Execute our function using our previously obtained idx var.\n        //Note: This function's second parameter is what the callback returned (Can be NULL if you're not interested in return values).\n        amx_Exec(amx, &ret, idx);\n\n        //Release our memory that we allocated. The function amx_Alloc allocates memory on the heap in the abstract machine.\n        //The functions amx_PushString and amx_PushArray both use this function internally so you have to release the memory every time\n        //you use one of those functions. NOTE: We used both amx_PushString and amx_PushArray, and yet we only have ONE release call.\n        //This is because memory on the heap is allocated in ascending order! amx_Release release all the memory above a certain point\n        //(the second parameter, amx_addr - which is our addr variable). Since it does this we ONLY store the address from the amx_PushString\n        //call, as it'll delete everything from that point on.\n        amx_Release(amx, addr);\n\n        //Print the return value (for completeness).\n        logprintf(\"EmitPawnCallback NOTE:  OnPawnCallbackEmitted callback returned %d!\", ret);\n\n    }\n    return 1;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"calling-natives-and-hooking-callbacks",children:"Calling natives and hooking callbacks"}),"\n",(0,i.jsx)(n.p,{children:"Before i get into callback hooking or SA-MP native calling, i thought i should shed light on something first. Some people seem to think that plugins are a replacement for PAWN, this simply isnt the case. Plugins were designed to provide functionality TO PAWN, not to serve as a replacement for it. There are times when developing something as a plugin rather then a PAWN script doesnt make sense- its important to ask yourself if you should really be coding something as a plugin rather then a pawn script."}),"\n",(0,i.jsx)(n.p,{children:"There are a lot of different methods you can use for both callback hooking and sa-mp native calling. Im only going to be focusing on one method oh each for now though."}),"\n",(0,i.jsx)(n.h3,{id:"invoke",children:"Invoke"}),"\n",(0,i.jsxs)(n.p,{children:["Invoke is a SA-MP native function calling method that was created by incognito. You can find it ",(0,i.jsx)(n.a,{href:"https://github.com/Dystans/SA-MP_Invoke_2.0",children:"here"}),". Please note that there is a text file in there containing a function with tons of SA-MP native function calls. This is vital for invoke, and must be added to your plugin's include file. Invoke will not work if you dont have a public PAWN function that uses all the SA-MP natives your plugin requires. This function is only so invoke can find the addresses of the natives, and should ",(0,i.jsx)(n.strong,{children:"never"})," actually be used anywhere."]}),"\n",(0,i.jsx)(n.h4,{id:"getting-started-1",children:"Getting started"}),"\n",(0,i.jsx)(n.p,{children:'Before we can start calling SA-MP natives, we have to setup Invoke. The first thing we have to do is include it inside of our project, you should remember how to do this from the previous "Getting started" section. Once you have the files added to your project there are just a few simple steps to get Invoke working:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Include the invoke header."}),"\n",(0,i.jsx)(n.li,{children:"Allocate memory for the invoke instance under Load."}),"\n",(0,i.jsx)(n.li,{children:"Push back the amx_list member variable every time a new AMX instance is loaded under AmxLoad."}),"\n",(0,i.jsx)(n.li,{children:"Every time a script gets unloaded, iterate through Invoke's amx_list, find the unloaded AMX instance, and erase it under AmxUnload."}),"\n",(0,i.jsx)(n.li,{children:'Create a native that calls Invoke\'s "getAddresses" member function for PAWN to use when a filterscript or gamemode is loaded that uses our plugin.'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Thats about it for getting invoke setup for your plugin. The only thing left to do is to add the public PAWN function found in the invoke package (the txt file we spoke of earlier) to your plugin's include, and use the native from the last setup step when a script is loaded. Anyone who will be creating plugins for public release, i encourage you to look into THIS post. It allows for a clean seamless \"hook\" of the OnGameModeInit/OnFilterScriptInit callbacks so you can register SA-MP's native addresses while not forcing the end user to add a function into those callbacks themselves."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Im aware that explaining this in text form probably isnt ideal for most newer users; however these are all standard C/++ tasks that you should already be familiar with- and those that arent (ie: creating a native) were already explained! If you're having trouble following along, i suggest getting a bit more familiar with C/++. With that being said though there will be an updated source code file (along with an actual include for our plugin) later on in this article with comments on everything we've learned so far. Look at that updated source file if you have any problems."]}),"\n",(0,i.jsx)(n.h4,{id:"adding-sa-mp-natives",children:"Adding SA-MP natives"}),"\n",(0,i.jsx)(n.p,{children:"Sadly invoke isnt magic, and does require maintenance to add new natives or remove deprecated ones. The version from the previous section has all the natives from the 0.2.2 version of SA-MP, so its missing all the newer functions. For these two reasons i decided to add this section! If someone is nice enough to add all the missing natives i will update the invoke package and include them in the credits- if not, i suggest adding natives on an as needed basis."}),"\n",(0,i.jsx)(n.p,{children:'Inside of the invoke header you should see a big array of function names (the array is appropriately called "name") and a lot of static "Native" structure declarations. To add a native you simply have to add its name to the array of names, and declare a Native structure with the appropriate information- name, and parameter specifiers. There are a lot of available parameter specifiers available to use:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"i = integer\nf = float value\ns = string\nv = reference variable (GetPlayerPos, GetPlayerKeys, etc.)\np = string var (GetPlayerName etc.)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Remember to update the public PAWN function that calls all the natives."})," Any time you add a native you need to also add it to said public function."]}),"\n",(0,i.jsx)(n.h4,{id:"calling-natives",children:"Calling natives"}),"\n",(0,i.jsx)(n.p,{children:'Invoke uses the variadic member function appropriately named "callNative" to call natives. The parameters for this function are a pointer to a Native structure (see previous section) containing info on the native function, and an ellipsis for all the parameters for said native function. The function returns the return value of the native that is being called. Here is an example function that calls multiple natives, with differing parameter types (int, reference, and string var).'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"//This function demonstrates: how to use invoke to call SA-MP natives.\n//PAWN native: native WhereIsPlayer(playerid);\ncell AMX_NATIVE_CALL WhereIsPlayer(AMX* amx, cell* params)\n{\n    float\n        x = NULL,\n        y = NULL,\n        z = NULL;\n\n    //Get the player's position (and check to see if he is even connected).\n    if(g_Invoke->callNative(&PAWN::GetPlayerPos, params[1], &x, &y, &z))\n    {\n        char name[24];\n\n        //Get the rest of the player's information (name, interior, and virtualworld) and print it.\n        g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);\n        int interior = g_Invoke->callNative(&PAWN::GetPlayerInterior, params[1]);\n        int virtualworld = g_Invoke->callNative(&PAWN::GetPlayerVirtualWorld, params[1]);\n\n        logprintf(\"%s is at X: %.2f, Y: %.2f, Z: %.2f (Virtual world: %d, Interior %d).\", name, x, y, z, virtualworld, interior);\n        return 1;\n\n    }\n    return 0;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hooking-callbacks",children:"Hooking callbacks"}),"\n",(0,i.jsx)(n.p,{children:"Using the invoke method, there is no 100% transparent hooking method when it comes to callbacks. Plugins that want to hook callbacks that are using invoke have go through PAWN to do so. You can create a native function that you can call inside the PAWN callback you wish to hook, and use that native as a sort of pseudo callback. You can do this in a manner that requires no work on the end user by using the ALS hooking method."}),"\n",(0,i.jsx)(n.p,{children:"The first step is obviously creating the native (remember to add it to our list of natives to register, and also add it in your include later on). The callback i decided to hook is OnPlayerConnect, so im gonna write a native function that has the same arguments as the callback, and then add the code that requires the callback (in this case a little joke)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'//This function demonstrates: how to write a native to act as a callback.\n//PAWN native: native TEST_Hook_OnPlayerConnnect(playerid);\ncell AMX_NATIVE_CALL TEST_Hook_OnPlayerConnnect(AMX* amx, cell* params)\n{\n    //Get the players name\n    char name[24];\n    g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);\n\n    //Check if his name is "Mario".\n    if(string("Mario") == name)\n    {\n        //If it is send our funny little message and kick him.\n        g_Invoke->callNative(&PAWN::SendClientMessage, params[1], 0xFFFFFFFF, "Sorry {FF0000}Mario, {FFFFFF}but your princess is in another server.");\n        g_Invoke->callNative(&PAWN::Kick, params[1]);\n    }\n    return 1;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["TEST_Hook_OnPlayerConnnect will now act as our plugin's OnPlayerConnect callback. Since our plugin's name is \"Test\" and its rather short i decided to let that act as our prefix for hooking. You generally want something unique for your prefixes so you dont collide with other people's plugins/includes. ",(0,i.jsx)(n.strong,{children:"Note:"})," We still have to call this function from PAWN using the ALS method we spoke of earlier for user convenience. Since Y_Less does a great job of explaining the ALS method, there's really no point for me to go into details about it, i will simply provide hooking example for our TEST_Hook_OnPlayerConnect callback. This should be put in your plugins include file."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'public OnPlayerConnect(playerid)\n{\n    TEST_Hook_OnPlayerConnnect(playerid);\n    //..\n\n    if(funcidx("TEST_OnPlayerConnect") != -1)\n    {\n        return CallLocalFunction("TEST_OnPlayerConnect", "d", playerid);\n    }\n    return 1;\n}\n\n#if defined _ALS_OnPlayerConnect\n    #undef OnPlayerConnect\n#else\n    #define _ALS_OnPlayerConnect\n#endif\n#define OnPlayerConnect TEST_OnPlayerConnect\n\nforward TEST_OnPlayerConnect(playerid);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"closing",children:"Closing"}),"\n",(0,i.jsx)(n.p,{children:'Some of you experienced plugin developers might be wondering why i didnt include the GDK in the "Calling natives and hooking callbacks" section. I decided to leave it out for two reasons. The first being that i simply do not have that much available time anymore, and couldnt spare any getting used to this new system. The second reason is that the GDK is very experimental and currently is struggling with crashes amongst other problems. Im quite aware of the speed differences between Invoke and GDK, and definitely will add it some time in the future if no one else does (remember, this is suppose to be a community driven thing). I think its best to wait for some more of the issues to be ironed out for now though (zeex is an amazing coder, and im sure he\'ll iron everything out ).'}),"\n",(0,i.jsx)(n.p,{children:"Also, as i promised, here is the update include/source file with comments on everything we've hopefully learned:"}),"\n",(0,i.jsx)(n.h3,{id:"plugin-include",children:"Plugin include"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'//Anything with the prefix "TEST" should be changed if you called your plugin something\n//different. This also goes for the plugin code (TEST_Hook_OnPlayerConnect specifically).\n#if defined _TEST_INCLUDED\n    #endinput\n#endif\n#define _TEST_INCLUDED\n#pragma library Test\n\n#include <a_samp>\n\n//Example natives\nnative PrintPawnString(const str[]);\nnative PrintPawnString2(const str[]);\nnative SetPawnString(str[], len = sizeof(str));\nnative Float:ReturnPawnFloatVal();\nnative SetPawnReferenceVars(&value1, &Float:value2);\nnative PrintPawnArray(arr[], size = sizeof(arr));\nnative EmitPawnCallback();\nnative WhereIsPlayer(playerid);\nnative TEST_Hook_OnPlayerConnnect(playerid);\n\n//Invoke native\nnative Invoke_GetAddresses();\n\n\n//Callback hooks\npublic OnPlayerConnect(playerid)\n{\n    TEST_Hook_OnPlayerConnnect(playerid);\n    //..\n\n    if(funcidx("TEST_OnPlayerConnect") != -1)\n    {\n        return CallLocalFunction("TEST_OnPlayerConnect", "d", playerid);\n    }\n    return 1;\n}\n\n#if defined _ALS_OnPlayerConnect\n    #undef OnPlayerConnect\n#else\n    #define _ALS_OnPlayerConnect\n#endif\n#define OnPlayerConnect TEST_OnPlayerConnect\n\nforward TEST_OnPlayerConnect(playerid);\n\npublic OnGameModeInit()\n{\n    Invoke_GetAddresses();\n    //..\n\n    if(funcidx("TEST_OnGameModeInit") != -1)\n    {\n        return CallLocalFunction("TEST_OnGameModeInit", "");\n    }\n    return 1;\n}\n\n#if defined _ALS_OnGameModeInit\n    #undef OnGameModeInit\n#else\n    #define _ALS_OnGameModeInit\n#endif\n#define OnGameModeInit TEST_OnGameModeInit\n\nforward TEST_OnGameModeInit();\n\n\npublic OnFilterScriptInit()\n{\n    Invoke_GetAddresses();\n    //..\n\n    if(funcidx("TEST_OnFilterScriptInit") != -1)\n    {\n        return CallLocalFunction("TEST_OnFilterScriptInit", "");\n    }\n    return 1;\n}\n\n#if defined _ALS_OnFilterScriptInit\n    #undef OnFilterScriptInit\n#else\n    #define _ALS_OnFilterScriptInit\n#endif\n#define OnFilterScriptInit TEST_OnFilterScriptInit\n\nforward TEST_OnFilterScriptInit();\n\n\n//Public function for invoke\nforward InvokeFunction();\npublic InvokeFunction()\n{\n    new Float:fVar;\n    new Var[ 256 ];\n    new iVar;\n\n    // a_samp.inc\n    SendClientMessage(0, 0, "");\n    SendClientMessageToAll(0, "");\n    SendDeathMessage(0, 0, 0);\n    GameTextForAll("", 0, 0);\n    GameTextForPlayer(0, "", 0, 0);\n    GetTickCount();\n    GetMaxPlayers();\n    SetGameModeText("");\n    SetTeamCount(0);\n    AddPlayerClass(0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0);\n    AddPlayerClassEx(0, 0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0);\n    AddStaticVehicle(0, 0.0, 0.0, 0.0, 0.0, 0, 0);\n    AddStaticVehicleEx(0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0);\n    AddStaticPickup(0, 0, 0.0, 0.0, 0.0);\n    ShowNameTags(0);\n    ShowPlayerMarkers(0);\n    GameModeExit();\n    SetWorldTime(0);\n    GetWeaponName(0, Var, sizeof( Var ) );\n    EnableTirePopping(0);\n    AllowInteriorWeapons(0);\n    SetWeather(0);\n    SetGravity(0.0);\n    AllowAdminTeleport(0);\n    SetDeathDropAmount(0);\n    CreateExplosion(0.0, 0.0, 0.0, 0, 0.0);\n    //SetDisabledWeapons();\n    EnableZoneNames(0);\n    IsPlayerAdmin(0);\n    Kick(0);\n    Ban(0);\n    SendRconCommand("");\n    ShowPlayerDialog(0,0,0,"lol","lol","lol","lol");\n\n    // a_players.inc\n    SetSpawnInfo(0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0, 0,0);\n    SpawnPlayer(0);\n    SetPlayerPos(0, 0.0, 0.0, 0.0);\n//  SetPlayerPosFindZ(0, 0.0, 0.0, 0.0);\n    GetPlayerPos(0, fVar, fVar, fVar);\n    SetPlayerFacingAngle(0,0.0);\n    GetPlayerFacingAngle(0,fVar);\n    SetPlayerInterior(0,0);\n    GetPlayerInterior(0);\n    SetPlayerHealth(0, 0.0);\n    GetPlayerHealth(0, fVar);\n    SetPlayerArmour(0, 0.0);\n    GetPlayerArmour(0, fVar);\n    SetPlayerAmmo(0, 0,0);\n    GetPlayerAmmo(0);\n    SetPlayerTeam(0,0);\n    GetPlayerTeam(0);\n    SetPlayerScore(0,0);\n    GetPlayerScore(0);\n    SetPlayerColor(0,0);\n    GetPlayerColor(0);\n    SetPlayerSkin(0,0);\n    GivePlayerWeapon(0, 0,0);\n    ResetPlayerWeapons(0);\n    GetPlayerWeaponData(0, 0, iVar, iVar );\n    GivePlayerMoney(0,0);\n    ResetPlayerMoney(0);\n    SetPlayerName(0, "");\n    GetPlayerMoney(0);\n    GetPlayerState(0);\n    GetPlayerIp(0, Var, sizeof( Var ));\n    GetPlayerPing(0);\n    GetPlayerWeapon(0);\n    GetPlayerKeys(0,iVar,iVar,iVar);\n    GetPlayerName(0, Var, sizeof( Var ));\n    PutPlayerInVehicle(0, 0,0);\n    GetPlayerVehicleID(0);\n    RemovePlayerFromVehicle(0);\n    TogglePlayerControllable(0,0);\n    PlayerPlaySound(0, 0, 0.0, 0.0,0.0);\n    SetPlayerCheckpoint(0, 0.0, 0.0, 0.0,0.0);\n    DisablePlayerCheckpoint(0);\n    SetPlayerRaceCheckpoint(0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0);\n    DisablePlayerRaceCheckpoint(0);\n    SetPlayerWorldBounds(0,0.0,0.0,0.0,0.0);\n    SetPlayerMarkerForPlayer(0, 0,0);\n    ShowPlayerNameTagForPlayer(0, 0,0);\n    SetPlayerMapIcon(0, 0, 0.0, 0.0, 0.0, 0,0);\n    RemovePlayerMapIcon(0,0);\n    SetPlayerCameraPos(0,0.0, 0.0, 0.0);\n    SetPlayerCameraLookAt(0, 0.0, 0.0, 0.0);\n    SetCameraBehindPlayer(0);\n    AllowPlayerTeleport(0,0);\n    IsPlayerConnected(0);\n    IsPlayerInVehicle(0,0);\n    IsPlayerInAnyVehicle(0);\n    IsPlayerInCheckpoint(0);\n    IsPlayerInRaceCheckpoint(0);\n    SetPlayerTime(0, 0,0);\n    TogglePlayerClock(0,0);\n    SetPlayerWeather(0,0);\n    GetPlayerTime(0,iVar,iVar);\n    SetPlayerVirtualWorld(0,0);\n    GetPlayerVirtualWorld(0);\n\n    // a_vehicle.inc\n    CreateVehicle(0,0.0,0.0,0.0,0.0,0,0,0);\n    DestroyVehicle(0);\n    GetVehiclePos(0,fVar,fVar,fVar);\n    SetVehiclePos(0,0.0,0.0,0.0);\n    GetVehicleZAngle(0,fVar);\n    SetVehicleZAngle(0,0.0);\n    SetVehicleParamsForPlayer(0,0,0,0);\n    SetVehicleToRespawn(0);\n    LinkVehicleToInterior(0,0);\n    AddVehicleComponent(0,0);\n    ChangeVehicleColor(0,0,0);\n    ChangeVehiclePaintjob(0,0);\n    SetVehicleHealth(0,0.0);\n    GetVehicleHealth(0,fVar);\n    AttachTrailerToVehicle(0, 0);\n    DetachTrailerFromVehicle(0);\n    IsTrailerAttachedToVehicle(0);\n    GetVehicleModel(0);\n    SetVehicleNumberPlate(0,"");\n    SetVehicleVirtualWorld(0,0);\n    GetVehicleVirtualWorld(0);\n\n    ApplyAnimation(0,"","",1.0,0,0,0,0,0);\n\n    // a_objects.inc\n    CreateObject(0,0.0,0.0,0.0,0.0,0.0,0.0);\n    SetObjectPos(0,0.0,0.0,0.0);\n    GetObjectPos(0,fVar,fVar,fVar);\n    SetObjectRot(0,0.0,0.0,0.0);\n    GetObjectRot(0,fVar,fVar,fVar);\n    IsValidObject(0);\n    DestroyObject(0);\n    MoveObject(0,0.0,0.0,0.0,0.0);\n    StopObject(0);\n    CreatePlayerObject(0,0,0.0,0.0,0.0,0.0,0.0,0.0);\n    SetPlayerObjectPos(0,0,0.0,0.0,0.0);\n    GetPlayerObjectPos(0,0,fVar,fVar,fVar);\n    GetPlayerObjectRot(0,0,fVar,fVar,fVar);\n    SetPlayerObjectRot(0,0,0.0,0.0,0.0);\n    IsValidPlayerObject(0,0);\n    DestroyPlayerObject(0,0);\n    MovePlayerObject(0,0,0.0,0.0,0.0,0.0);\n    StopPlayerObject(0,0);\n\n    // Menu\'s\n    CreateMenu("", 0, 0.0, 0.0, 0.0, 0.0);\n    DestroyMenu(Menu:0);\n    AddMenuItem(Menu:0, 0, "");\n    SetMenuColumnHeader(Menu:0, 0, "");\n    ShowMenuForPlayer(Menu:0, 0);\n    HideMenuForPlayer(Menu:0, 0);\n    IsValidMenu(Menu:0);\n    DisableMenu(Menu:0);\n    DisableMenuRow(Menu:0,0);\n\n    // Textdraw\n    TextDrawCreate(0.0,0.0,"");\n    TextDrawDestroy(Text:0);\n    TextDrawLetterSize(Text:0, 0.0,0.0);\n    TextDrawTextSize(Text:0, 0.0,0.0);\n    TextDrawAlignment(Text:0, 0);\n    TextDrawColor(Text:0,0);\n    TextDrawUseBox(Text:0, 0);\n    TextDrawBoxColor(Text:0, 0);\n    TextDrawSetShadow(Text:0, 0);\n    TextDrawSetOutline(Text:0, 0);\n    TextDrawBackgroundColor(Text:0,0);\n    TextDrawFont(Text:0, 0);\n    TextDrawSetProportional(Text:0, 0);\n    TextDrawShowForPlayer(0, Text:0);\n    TextDrawHideForPlayer(0, Text:0);\n    TextDrawShowForAll(Text:0);\n    TextDrawHideForAll(Text:0);\n\n    // Others\n    funcidx("");\n    gettime(iVar,iVar,iVar);\n    getdate(iVar,iVar,iVar);\n    tickcount(iVar);\n\n    return 1;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"plugin-source-code",children:"Plugin source code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "SDK\\amx\\amx.h"\n#include "SDK\\plugincommon.h"\n\n#include "Invoke.h"\n\n#include <string>\n#include <vector>\n\n#include <cstdlib>\n#include <ctime>\n\n\ntypedef void (*logprintf_t)(char* format, ...);\n\nlogprintf_t logprintf;\nextern void *pAMXFunctions;\n\n\nusing namespace std;\n\n\n//This function demonstrates: how to get a string (and its length) from PAWN.\n//PAWN native: native PrintPawnString(const str[]);\ncell AMX_NATIVE_CALL PrintPawnString(AMX* amx, cell* params)\n{\n    int\n        len = NULL,\n        ret = NULL;\n\n    cell *addr  = NULL;\n\n    //Get the address of our string param (str) and then get its length\n    amx_GetAddr(amx, params[1], &addr);\n    amx_StrLen(addr, &len);\n\n    //if the length of input isnt 0\n    if(len)\n    {\n        //We increase len because we want to make room for the terminating null char when we allocate memory.\n        //Also because GetString\'s size parameter counts the null chracter, we have to specify the length\n        //of the string + 1; otherwise our string will be truncated to make room for the null char (we\'d lose 1 character).\n        len++;\n\n        //Allocate memory to hold our string we\'re passing (str) and then "get" the string using our allocated memory to store it.\n        char* text = new char[ len ];\n        amx_GetString(text, addr, 0, len);\n\n        //Use logprintf to print out string (text). We dont use std::cout because it doesnt write to the server log (only the window).\n        logprintf(text);\n\n        //Deallocate our memory...\n        delete[] text;\n    }\n    return 1;\n}\n\n//This function demonstrates: How to call a callback that is in a PAWN script.\n//PAWN native: native EmitPawnCallback();\ncell AMX_NATIVE_CALL EmitPawnCallback(AMX* amx, cell* params)\n{\n    int idx;\n\n    const cell var = 3;\n    const cell arr[] = {100, 4, 33};\n    const string str = "Some random message from C++.";\n\n\n    //Pawn callback: forward OnPawnCallbackEmitted(var, arr[], str[]);\n    //Find our callback and store its place in the public function table (it\'s index) into our idx var.\n    if(!amx_FindPublic(amx, "OnPawnCallbackEmitted", &idx))\n    {\n        cell\n            ret,\n            addr;\n\n        //Here we push our arguments to our function. Note that if the function has multiple arguments you have to push your\n        //values in reverse order! Thats why we\'re pushing the string first, then the array, and finally our integer.\n\n        amx_PushString(amx, &addr, NULL, str.c_str(), NULL, NULL);\n        //amx_PushArray(amx, NULL, NULL, arr, sizeof(arr) / sizeof(cell));\n\n        cell\n            amx_addr,\n            *phys_addr;\n\n        //For some reason amx_PushArray seems to be crashing the server, and i have NO idea why. My usage should be completely\n        //valid judging from the implementers guide, and the code itself. Since the function isnt working we\'ll have to\n        //use the old method and allocate the memory, set it, and push it all ourselves. This is pretty straight forward. We\n        //allocate memory on the heap using amx_Allot (this returns 2 addresses- one of the location in the abstract machine\n        //(amx_addr), and one relative to the actual server\'s address space (phsy_addr - which we can use in C++)). Once the\n        //memory is allocated we use memcpy to copy the memory from our array to our phys_addr address location.\n        amx_Allot(amx, sizeof(arr) / sizeof(cell), &amx_addr, &phys_addr);\n        memcpy(phys_addr, arr, sizeof(arr));\n        amx_Push(amx, amx_addr);\n\n        //Push our integer value\n        amx_Push(amx, var);\n\n        //Execute our function using our previously obtained idx var.\n        //Note: This function\'s second parameter is what the callback returned (Can be NULL if you\'re not interested in return values).\n        amx_Exec(amx, &ret, idx);\n\n        //Release our memory that we allocated. The function amx_Alloc allocates memory on the heap in the abstract machine.\n        //The functions amx_PushString and amx_PushArray both use this function internally so you have to release the memory every time\n        //you use one of those functions. NOTE: We used both amx_PushString and amx_PushArray, and yet we only have ONE release call.\n        //This is because memory on the heap is allocated in ascending order! amx_Release release all the memory above a certain point\n        //(the second parameter, amx_addr - which is our addr variable). Since it does this we ONLY store the address from the amx_PushString\n        //call, as it\'ll delete everything from that point on.\n        amx_Release(amx, addr);\n\n        //Print the return value (for completeness).\n        logprintf("EmitPawnCallback NOTE:  OnPawnCallbackEmitted callback returned %d!", ret);\n\n    }\n    return 1;\n}\n\n\n//This function demonstrates: an alternative method to getting strings from pawn- and the possible risks that come with it.\n//PAWN native: native PrintPawnString2(const str[]);\ncell AMX_NATIVE_CALL PrintPawnString2(AMX* amx, cell* params)\n{\n    //This method is NOT recomended as the amx_StrParam macro uses the alloca function which is NOT a standard in C, OR C++.\n    //Using this method comes with risks of overflowing the stack (If you allocate large amounts of memory) and also\n    //gives you the risk of bugs (this function is machine AND compiler dependent- some implementations are said to be bugged).\n\n    char* text = NULL;\n    amx_StrParam(amx, params[1], text);\n\n    //Check if text is null\n    if(text != NULL)\n    {\n        //Use logprintf to print out string (text). We dont use std::cout because it doesnt write to the server log (only the window).\n        logprintf(text);\n    }\n    return 1;\n}\n\n//This function demonstrates: how to modify a PAWN string.\n//PAWN native: native SetPawnString(str[], len = sizeof(str));\ncell AMX_NATIVE_CALL SetPawnString(AMX* amx, cell* params)\n{\n    const string message = "This is a string from C/++!!";\n    cell* addr = NULL;\n\n    //Get the address of our string parameter (str) and store our message\n    amx_GetAddr(amx, params[1], &addr);\n    amx_SetString(addr, message.c_str(), 0, 0, params[2]);\n    return 1;\n}\n\n//This function demonstrates: how to cast a float to a PAWN float.\n//PAWN native: native Float:ReturnPawnFloatVal();\ncell AMX_NATIVE_CALL ReturnPawnFloatVal(AMX* amx, cell* params)\n{\n    //Since PAWN is a typeless language it stores everything as a 32bit integer and relies on tags to handle special data.\n    //A floating point number is no exception to this; It\'s a still 32bit int, but it has a Float tag to show that it shouldnt\n    //be treated like an regular integer. So how do we convert a float to an 32bit integer (for PAWN) without losing data?\n    //The answer is the amx_ftoc macro!\n\n    //The macro amx_ftoc type casts a float into a cell while preserving its bit pattern (amx_ctof does the inverse).\n    const float f = 22.624f;\n    return amx_ftoc(f);\n}\n\n//This function demonstrates: How to pass parameters by reference.\n//PAWN native: native SetPawnReferenceVars(&value1, &Float:value2);\ncell AMX_NATIVE_CALL SetPawnReferenceVars(AMX* amx, cell* params)\n{\n    const int val = 65;\n    const float val2 = 84.54f;\n\n    cell* addr[2] = {NULL, NULL};\n\n    //Get the addresses of "value1" and "value2"\n    amx_GetAddr(amx, params[1], &addr[0]);\n    amx_GetAddr(amx, params[2], &addr[1]);\n\n    //Dereference our pointers and assign our values. Remember to ALWAYS use the macro "amx_ftoc" to convert floats into\n    //cells (the appropriate float format for PAWN)!\n    *addr[0] = val;\n    *addr[1] = amx_ftoc(val2);\n\n    return 1;\n}\n\n//This function demonstrates: how to get and modify array values.\n//PAWN native: native PrintPawnArray(arr[], size = sizeof(arr));\ncell AMX_NATIVE_CALL PrintPawnArray(AMX* amx, cell* params)\n{\n    //Make sure there\'s something to print...\n    if(params[2] > 0)\n    {\n        cell* addr = NULL;\n\n        //Get the address of the first value in our PAWN array.\n        amx_GetAddr(amx, params[1], &addr);\n\n        for(int i = 0, l = params[2]; i < l; i++)\n        {\n            //This is pretty straight forward: We dereference the addr pointer to get our value to print.\n            //You should know this already, but arrays and pointers are almost the same thing, so we can use pointer\n            //arithmetic to add an offset OR just use the subscript operator (in the end *(addr+1) and addr[1] are the same).\n            logprintf("arr[%d] = %d", i, *(addr + i));\n\n            //If you wanted to modify the array you would just change its value by dereferencing addr and assigning a new value.\n            //You should know this as well, im just adding it in for completeness. Here we change the first value of our array\n            //to 5 (Note: Since its the first value, no offset it used).\n\n            // *(addr) = 5;\n        }\n    }\n    return 1;\n}\n\n//This function demonstrates: setting up invoke (fetching the addresses of our natives).\n//PAWN native: native Invoke_GetAddresses();\ncell AMX_NATIVE_CALL Invoke_GetAddresses(AMX* amx, cell* params)\n{\n    return g_Invoke->getAddresses();\n}\n\n//This function demonstrates: how to use invoke to call SA-MP natives.\n//PAWN native: native WhereIsPlayer(playerid);\ncell AMX_NATIVE_CALL WhereIsPlayer(AMX* amx, cell* params)\n{\n    float\n        x = NULL,\n        y = NULL,\n        z = NULL;\n\n    //Get the player\'s position (and check to see if he is even connected).\n    if(g_Invoke->callNative(&PAWN::GetPlayerPos, params[1], &x, &y, &z))\n    {\n        char name[24];\n\n        //Get the rest of the player\'s information (name, interior, and virtualworld) and print it.\n        g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);\n        int interior = g_Invoke->callNative(&PAWN::GetPlayerInterior, params[1]);\n        int virtualworld = g_Invoke->callNative(&PAWN::GetPlayerVirtualWorld, params[1]);\n\n        logprintf("%s is at X: %.2f, Y: %.2f, Z: %.2f (Virtual world: %d, Interior %d).", name, x, y, z, virtualworld, interior);\n        return 1;\n\n    }\n    return 0;\n}\n\n//This function demonstrates: how to write a native to act as a callback.\n//PAWN native: native TEST_Hook_OnPlayerConnnect(playerid);\ncell AMX_NATIVE_CALL TEST_Hook_OnPlayerConnnect(AMX* amx, cell* params)\n{\n    //Get the players name\n    char name[24];\n    g_Invoke->callNative(&PAWN::GetPlayerName, params[1], name);\n\n    //Check if his name is "Mario".\n    if(string("Mario") == name)\n    {\n        //If it is send our funny little message and kick him.\n        g_Invoke->callNative(&PAWN::SendClientMessage, params[1], 0xFFFFFFFF, "Sorry {FF0000}Mario, {FFFFFF}but your princess is in another server.");\n        g_Invoke->callNative(&PAWN::Kick, params[1]);\n    }\n    return 1;\n}\n\n\n//This function tells the server what capabilities our plugin will have based on what it returns. Generally we only use 3 support flags\n//in plugins: SUPPORTS_VERSION, SUPPORTS_AMX_NATIVES, and SUPPORTS_PROCESS_TICK.\nPLUGIN_EXPORT unsigned int PLUGIN_CALL Supports()\n{\n    //Note: If you\'re using the ProccessTick function, remember to export it in the .def file!\n    return SUPPORTS_VERSION | SUPPORTS_AMX_NATIVES | SUPPORTS_PROCESS_TICK;\n}\n\n//The Load function is pretty straight forward. This is called when the plugin is loaded and gets passed an array of addresses that the plugin\n//will use to function. The two indexes we typically use are PLUGIN_DATA_AMX_EXPORTS, and PLUGIN_DATA_LOGPRINTF.\nPLUGIN_EXPORT bool PLUGIN_CALL Load(void **ppData)\n{\n    //allocate memory for out g_Invoke instance\n    g_Invoke = new Invoke;\n\n    //Assign the addresses of our AMX function table/logprintf function to their corasponding pointers.\n    pAMXFunctions = ppData[PLUGIN_DATA_AMX_EXPORTS];\n    logprintf = (logprintf_t) ppData[PLUGIN_DATA_LOGPRINTF];\n\n    logprintf("* Test plugin was loaded.");\n    return true;\n}\n\n//Unload is called when the plugin is unloaded (server shutdown).\nPLUGIN_EXPORT void PLUGIN_CALL Unload()\n{\n    logprintf("* Test plugin was unloaded.");\n}\n\n//Our array of native info for amx_Register (function name and address).\nAMX_NATIVE_INFO PluginNatives[] =\n{\n    {"PrintPawnString", PrintPawnString},\n    {"PrintPawnString2", PrintPawnString2},\n    {"SetPawnString", SetPawnString},\n    {"ReturnPawnFloatVal", ReturnPawnFloatVal},\n    {"SetPawnReferenceVars", SetPawnReferenceVars},\n    {"PrintPawnArray", PrintPawnArray},\n    {"EmitPawnCallback", EmitPawnCallback},\n    {"WhereIsPlayer", WhereIsPlayer},\n    {"Invoke_GetAddresses", Invoke_GetAddresses},\n    {"TEST_Hook_OnPlayerConnnect", TEST_Hook_OnPlayerConnnect},\n    {0, 0}\n};\n\n//This function is called when a new AMX instance is loaded into the server. This will be called for every filterscript/gamemode! Because of this it isnt\n//a good idea to store a single AMX instance for the entire plugin, instead use a queue/list/vector. In this function we also register our custom\n//native functions we wish to provide PAWN with.\nPLUGIN_EXPORT int PLUGIN_CALL AmxLoad( AMX *amx )\n{\n    //Any time a script is loaded we want to add it to invoke\'s AMX list, so we push back the list with the instance.\n    g_Invoke->amx_list.push_back(amx);\n    return amx_Register(amx, PluginNatives, -1);\n}\n\n//This function is called when every an AMX instance is unloaded. If you store AMX instances, make sure you remove them. Otherwise you\'ll have instances to\n//non-existing gamemodes/filterscripts.\nPLUGIN_EXPORT int PLUGIN_CALL AmxUnload( AMX *amx )\n{\n    //Every script that is unloaded needs to get removed from our AMX instance list. So we iterate through our list and find the instance that is being\n    //unloaded, and we earase it from the list.\n    for(list<AMX *>::iterator i = g_Invoke->amx_list.begin(); i != g_Invoke->amx_list.end(); ++i)\n    {\n        if(*i == amx)\n        {\n            g_Invoke->amx_list.erase(i);\n            break;\n        }\n    }\n    return AMX_ERR_NONE;\n}\n\n//ProcessTick is a function that gets called on every iteration of the server\'s loop. People generally use this function as a method of managing time by\n//keeping track of the amount of ticks that have passed. The SA-MP server is said to have a sleep time of 5ms, so if 50 ticks go by you have an idea of\n// the elapsed time (5 * 50 = 250ms). Note: Anyone who uses threads in their plugins and require PAWN interaction needs to use this function to ensure\n//PAWN isnt busy doing another task!\nPLUGIN_EXPORT void PLUGIN_CALL ProcessTick()\n{\n    static int tick = 0;\n    const int NYAN_COUNT = 100;\n\n    tick++;\n\n    //Use the modulo operator to see if NYAN_COUNT ticks have passed (100 tick. 5ms sleep time * 100 ticks = 500ms).\n    if(!(tick % NYAN_COUNT))\n    {\n        //If 100 ticks have passed send our funny little message to everyone.\n        const char nyan[] = "{FF0000}NYAN {FFA500}NYAN {FFFF00}NYAN {00FF00}NYAN {0000FF}NYAN {551A8B}NYAN";\n        g_Invoke->callNative(&PAWN::SendClientMessageToAll, 0, nyan);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"special-thanks",children:"Special thanks"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RyDeR`"})," - For contributing the pictures from his plugin tutorial."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Incognito"})," - For Invoke, information about ProcessTick, and for all the help over my time learning C++."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Zeex/0x5A656578"})," - For GDK (will be included some time), and for volunteering to answer questions about GDK."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Y_Less"})," - For being generally awesome and constantly helping me when ever im completely baffled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Techboy123"})," - For a ton of productive chats, help, and for listening to my complaints."]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},50065:function(e,n,t){t.d(n,{Z:()=>o,a:()=>s});var a=t(67294);let i={},r=a.createContext(i);function s(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);